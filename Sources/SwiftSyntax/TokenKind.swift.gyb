%{
  # -*- mode: Swift -*-
  from gyb_syntax_support import *
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From TokenKind.swift.gyb.
//// Do Not Edit Directly!
//===----------------- TokenKind.swift - Token Kind Enum ------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// Enumerates the kinds of tokens in the Swift language.
public enum TokenKind {
  case eof
% for token in SYNTAX_TOKENS:
%   kind = token.swift_kind()
%
%   # Tokens that don't have a set text have an associated value that
%   # contains their text.
%   if not token.text:
%     kind += '(String)'
%   end
  case ${kind}
% end

  /// The textual representation of this token kind.
  var text: String {
    switch self {
    case .eof: return ""
% for token in SYNTAX_TOKENS:
%   if token.text:
    case .${token.swift_kind()}: return "${token.text}"
%   else:
    case .${token.swift_kind()}(let text): return text
%   end
% end
    }
  }

  public var isKeyword: Bool {
    switch self {
    case .eof: return false
% for token in SYNTAX_TOKENS:
%   if token.is_keyword:
    case .${token.swift_kind()}: return true
%   else:
    case .${token.swift_kind()}: return false
%   end
% end
    }
  }
  
  var kind: String {
    switch self {
    case .eof: return "eof"
% for token in SYNTAX_TOKENS:
%   kind = token.swift_kind()
%   if not token.text:
%     kind += '(_)'
%   end
    case .${kind}: return "${token.kind}"
% end
    }
  }
}

extension TokenKind: Equatable {
  public static func ==(lhs: TokenKind, rhs: TokenKind) -> Bool {
    switch (lhs, rhs) {
    case (.eof, .eof): return true
% for token in SYNTAX_TOKENS:
%   kind = token.swift_kind()
%   if token.text:
    case (.${kind}, .${kind}): return true
%   else:
    case (.${kind}(let lhsText), .${kind}(let rhsText)):
      return lhsText == rhsText
%   end
% end
    default: return false
    }
  }
}

extension TokenKind {
  static func fromRawValue(kind: CTokenKind,
                           text: Substring) -> TokenKind {
    switch kind {
    case 0: return .eof
% for token in SYNTAX_TOKENS:
    case ${token.serialization_code}:
%   if token.text: # The token does not have text associated with it
      return .${token.swift_kind()}
%   else:
      return .${token.swift_kind()}(String(text))
%   end
% end
    default:
      if !text.isEmpty {
        // Default to an unknown token with the passed text if we don't know
        // its kind.
        return .unknown(String(text))
      } else {
        // If we were not passed the token's text, we cannot recover since we
        // would lose roundtripness.
        fatalError("unexpected token kind \(kind)")
      }
    }
  }
}
