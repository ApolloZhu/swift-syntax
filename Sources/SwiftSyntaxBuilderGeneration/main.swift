//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

private let format = Format(indentWidth: 2)

private func createSpacingCall() -> FunctionCallExpr {
  FunctionCallExpr(calledExpression: MemberAccessExpr(name: "spaces"), leftParen: .leftParen, argumentList: TupleExprElement(expression: IntegerLiteralExpr(1)), rightParen: .rightParen)
}

private func createWithLeadingTriviaCall() -> FunctionCallExpr {
  FunctionCallExpr(calledExpression: MemberAccessExpr(name: "withLeadingTrivia"), leftParen: .leftParen, argumentList: TupleExprElement.init(expression: createSpacingCall()), rightParen: .rightParen)
}

private func createWithTrailingTriviaCall() -> FunctionCallExpr {
  FunctionCallExpr(calledExpression: MemberAccessExpr(name: "withTrailingTrivia"), leftParen: .leftParen, argumentList: TupleExprElement(expression: createSpacingCall()), rightParen: .rightParen)
}

private func createTokenSyntaxPatternBinding(_ pattern: ExpressibleAsPatternBuildable, accessor: ExpressibleAsSyntaxBuildable) -> PatternBinding {
  PatternBinding(pattern: pattern,
                 typeAnnotation: "TokenSyntax",
                 initializer: nil,
                 accessor: accessor)
}

private let copyrightHeader = """
    //// Automatically Generated by SwiftSyntaxBuilderGeneration
    //// Do Not Edit Directly!
    //===----------------------------------------------------------------------===//
    //
    // This source file is part of the Swift.org open source project
    //
    // Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
    // Licensed under Apache License v2.0 with Runtime Library Exception
    //
    // See https://swift.org/LICENSE.txt for license information
    // See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
    //
    //===----------------------------------------------------------------------===//


    """

let tokensFile = SourceFile {
  ImportDecl(importTok: TokenSyntax.import.withLeadingTrivia(.docLineComment(copyrightHeader)), path: "SwiftSyntax")

  ExtensionDecl(extendedType: "TokenSyntax", modifiersBuilder: { TokenSyntax.public.withLeadingTrivia(.newlines(1) + .docLineComment("/// Namespace for commonly used tokens with default trivia.") +
    .newlines(1)) }, membersBuilder: {
      for token in SYNTAX_TOKENS {
        if token.isKeyword {
          VariableDecl(letOrVarKeyword: .var,
                       modifiersBuilder: {
            if let text = token.text {
              TokenSyntax.static.withLeadingTrivia(.newlines(1) + .docLineComment("/// The `\(text)` keyword") + .newlines(1))
            } else {
              TokenSyntax.static
            }
          },
                       bindingsBuilder: {
            // We need to use `CodeBlock` here to ensure there is braces around.

            let accessor = CodeBlock {
              FunctionCallExpr(calledExpression: MemberAccessExpr(base: "SyntaxFactory", name: "make\(token.name)Keyword"),
                               leftParen: .leftParen,
                               rightParen: .rightParen)

              if token.requiresLeadingSpace {
                createWithLeadingTriviaCall()
              }

              if token.requiresTrailingSpace {
                createWithTrailingTriviaCall()
              }
            }

            createTokenSyntaxPatternBinding("`\(token.name.withFirstCharacterLowercased)`", accessor: accessor)
          })
        } else if token.text != nil {
          VariableDecl(letOrVarKeyword: .var,
                       modifiersBuilder: {
            if let text = token.text {
              TokenSyntax.static.withLeadingTrivia(.newlines(1) + .docLineComment("/// The `\(text)` token") + .newlines(1))
            } else {
              TokenSyntax.static
            }
          },
                       bindingsBuilder: {
            // We need to use `CodeBlock` here to ensure there is braces around.
            let accessor = CodeBlock {
              FunctionCallExpr(calledExpression: MemberAccessExpr(base: "SyntaxFactory", name: "make\(token.name)Token"),
                               leftParen: .leftParen,
                               rightParen: .rightParen)

              if token.requiresLeadingSpace {
                createWithLeadingTriviaCall()
              }

              if token.requiresTrailingSpace {
                createWithTrailingTriviaCall()
              }
            }

            createTokenSyntaxPatternBinding("`\(token.name.withFirstCharacterLowercased)`", accessor: accessor)
          })
        } else {
          let signature = FunctionSignature(input: ParameterClause(leftParen: TokenSyntax.leftParen, parameterList: FunctionParameter(attributes: nil, firstName: .wildcard, secondName: .identifier("text"), colon: .colon, type: "String"), rightParen: .rightParen.withTrailingTrivia(.spaces(1))), output: "TokenSyntax")

          FunctionDecl(identifier: .identifier("`\(token.name.withFirstCharacterLowercased)`"),
                       signature: signature,
                       modifiersBuilder: {
            if let text = token.text {
              TokenSyntax.static.withLeadingTrivia(.newlines(1) + .docLineComment("/// The `\(text)` token"))
            } else {
              TokenSyntax.static
            }
          },
                       bodyBuilder: {
            FunctionCallExpr(calledExpression: MemberAccessExpr(base: "SyntaxFactory", name: "make\(token.name)"), leftParen: .leftParen, rightParen: .rightParen, trailingClosure: nil, argumentListBuilder: {
              TupleExprElement(expression: IdentifierExpr("text"))
            })

            if token.requiresLeadingSpace {
              createWithLeadingTriviaCall()
            }

            if token.requiresTrailingSpace {
              createWithTrailingTriviaCall()
            }
          })
        }
      }
      VariableDecl(letOrVarKeyword: .var,
                   modifiersBuilder: { TokenSyntax.static.withLeadingTrivia(.newlines(1) + .docLineComment("/// The `eof` token") + .newlines(1)) },
                   bindingsBuilder: {
        // We need to use `CodeBlock` here to ensure there is braces around.
        let body = CodeBlock {
          FunctionCallExpr(calledExpression: MemberAccessExpr(base: "SyntaxFactory", name: "makeToken"),
                           leftParen: .leftParen,
                           rightParen: .rightParen,
                           argumentListBuilder: {
            TupleExprElement(expression: FunctionCallExpr(calledExpression: MemberAccessExpr(name: "eof")), trailingComma: .comma)
            TupleExprElement(label: TokenSyntax.identifier("presence"), colon: .colon, expression: FunctionCallExpr(calledExpression: MemberAccessExpr(name: "present")))
          })
        }

        createTokenSyntaxPatternBinding("eof", accessor: body)
      })
      VariableDecl(letOrVarKeyword: .var,
                   modifiersBuilder: { TokenSyntax.static.withLeadingTrivia(.newlines(1) + .docLineComment("/// The `open` contextual token") + .newlines(1)) },
                   bindingsBuilder: {
        // We need to use `CodeBlock` here to ensure there is braces around.
        let body = CodeBlock {
          FunctionCallExpr(calledExpression: MemberAccessExpr(base: "SyntaxFactory", name: "makeContextualKeyword"),
                           leftParen: .leftParen,
                           rightParen: .rightParen,
                           argumentListBuilder: {
            TupleExprElement(expression: StringLiteralExpr("open"))
          })

          createWithTrailingTriviaCall()
        }

        createTokenSyntaxPatternBinding("open", accessor: body)
      })
    })
}

let tokenSyntax = tokensFile.buildSyntax(format: format)

guard CommandLine.arguments.count > 1 else {
    fatalError("Please add a destination as the first argument")
}

let destination = CommandLine.arguments[1]

let generatedPath = URL(fileURLWithPath: destination)

try FileManager.default.createDirectory(atPath: generatedPath.path, withIntermediateDirectories: true, attributes: nil)

let filePath = generatedPath.appendingPathComponent("Tokens.swift")
try tokenSyntax.description.write(to: filePath, atomically: true, encoding: .utf8)
