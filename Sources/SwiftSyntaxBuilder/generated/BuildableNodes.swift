
//// Automatically Generated by generate-swift-syntax-builder
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax
/// A CodeBlockItem is any Syntax node that appears on its own line insidea CodeBlock.
public struct CodeBlockItem: SyntaxBuildable, ExpressibleAsCodeBlockItem {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeItem: UnexpectedNodes?
  let item: SyntaxBuildable
  let unexpectedBetweenItemAndSemicolon: UnexpectedNodes?
  let semicolon: Token?
  let unexpectedBetweenSemicolonAndErrorTokens: UnexpectedNodes?
  let errorTokens: SyntaxBuildable?
  /// Creates a `CodeBlockItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeItem: 
  ///   - item: The underlying node inside the code block.
  ///   - unexpectedBetweenItemAndSemicolon: 
  ///   - semicolon: If present, the trailing semicolon at the end of the item.
  ///   - unexpectedBetweenSemicolonAndErrorTokens: 
  ///   - errorTokens: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeItem: ExpressibleAsUnexpectedNodes? = nil, item: ExpressibleAsSyntaxBuildable, unexpectedBetweenItemAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token? = nil, unexpectedBetweenSemicolonAndErrorTokens: ExpressibleAsUnexpectedNodes? = nil, errorTokens: ExpressibleAsSyntaxBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeItem = unexpectedBeforeItem?.createUnexpectedNodes()
    self.item = item.createSyntaxBuildable()
    self.unexpectedBetweenItemAndSemicolon = unexpectedBetweenItemAndSemicolon?.createUnexpectedNodes()
    self.semicolon = semicolon
    assert(semicolon == nil || semicolon!.text == #";"#)
    self.unexpectedBetweenSemicolonAndErrorTokens = unexpectedBetweenSemicolonAndErrorTokens?.createUnexpectedNodes()
    self.errorTokens = errorTokens?.createSyntaxBuildable()
  }
  /// Builds a `CodeBlockItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CodeBlockItemSyntax`.
  func buildCodeBlockItem(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CodeBlockItemSyntax {
    let result = CodeBlockItemSyntax(unexpectedBeforeItem?.buildUnexpectedNodes(format: format, leadingTrivia: nil), item: item.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenItemAndSemicolon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), semicolon: semicolon?.buildToken(), unexpectedBetweenSemicolonAndErrorTokens?.buildUnexpectedNodes(format: format, leadingTrivia: nil), errorTokens: errorTokens?.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCodeBlockItem(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCodeBlockItem`.
  public func createCodeBlockItem() -> CodeBlockItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CodeBlockItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct CodeBlock: SyntaxBuildable, ExpressibleAsCodeBlock {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftBrace: UnexpectedNodes?
  let leftBrace: Token
  let unexpectedBetweenLeftBraceAndStatements: UnexpectedNodes?
  let statements: CodeBlockItemList
  let unexpectedBetweenStatementsAndRightBrace: UnexpectedNodes?
  let rightBrace: Token
  /// Creates a `CodeBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndStatements = unexpectedBetweenLeftBraceAndStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
    self.unexpectedBetweenStatementsAndRightBrace = unexpectedBetweenStatementsAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndStatements: unexpectedBetweenLeftBraceAndStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `CodeBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CodeBlockSyntax`.
  func buildCodeBlock(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CodeBlockSyntax {
    let result = CodeBlockSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBrace: leftBrace.buildToken(), unexpectedBetweenLeftBraceAndStatements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), statements: statements.buildCodeBlockItemList(format: format._indented(), leadingTrivia: nil), unexpectedBetweenStatementsAndRightBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBrace: rightBrace.buildToken().withLeadingTrivia(.newline + format._makeIndent() + (rightBrace.buildToken().leadingTrivia ?? [])))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCodeBlock(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCodeBlock`.
  public func createCodeBlock() -> CodeBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CodeBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct InOutExpr: ExprBuildable, ExpressibleAsInOutExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAmpersand: UnexpectedNodes?
  let ampersand: Token
  let unexpectedBetweenAmpersandAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `InOutExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAmpersand: 
  ///   - ampersand: 
  ///   - unexpectedBetweenAmpersandAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAmpersand: ExpressibleAsUnexpectedNodes? = nil, ampersand: Token = Token.`prefixAmpersand`, unexpectedBetweenAmpersandAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAmpersand = unexpectedBeforeAmpersand?.createUnexpectedNodes()
    self.ampersand = ampersand
    assert(ampersand.text == #"&"#)
    self.unexpectedBetweenAmpersandAndExpression = unexpectedBetweenAmpersandAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `InOutExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InOutExprSyntax`.
  func buildInOutExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> InOutExprSyntax {
    let result = InOutExprSyntax(unexpectedBeforeAmpersand?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ampersand: ampersand.buildToken(), unexpectedBetweenAmpersandAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildInOutExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsInOutExpr`.
  public func createInOutExpr() -> InOutExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `InOutExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundColumnExpr: ExprBuildable, ExpressibleAsPoundColumnExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundColumn: UnexpectedNodes?
  let poundColumn: Token
  /// Creates a `PoundColumnExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundColumn: 
  ///   - poundColumn: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundColumn: ExpressibleAsUnexpectedNodes? = nil, poundColumn: Token = Token.`poundColumn`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundColumn = unexpectedBeforePoundColumn?.createUnexpectedNodes()
    self.poundColumn = poundColumn
    assert(poundColumn.text == #"#column"#)
  }
  /// Builds a `PoundColumnExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundColumnExprSyntax`.
  func buildPoundColumnExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundColumnExprSyntax {
    let result = PoundColumnExprSyntax(unexpectedBeforePoundColumn?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundColumn: poundColumn.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundColumnExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundColumnExpr`.
  public func createPoundColumnExpr() -> PoundColumnExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundColumnExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TryExpr: ExprBuildable, ExpressibleAsTryExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeTryKeyword: UnexpectedNodes?
  let tryKeyword: Token
  let unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodes?
  let questionOrExclamationMark: Token?
  let unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `TryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTryKeyword: 
  ///   - tryKeyword: 
  ///   - unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  ///   - unexpectedBetweenQuestionOrExclamationMarkAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token = Token.`try`, unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil, unexpectedBetweenQuestionOrExclamationMarkAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeTryKeyword = unexpectedBeforeTryKeyword?.createUnexpectedNodes()
    self.tryKeyword = tryKeyword
    assert(tryKeyword.text == #"try"#)
    self.unexpectedBetweenTryKeywordAndQuestionOrExclamationMark = unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.createUnexpectedNodes()
    self.questionOrExclamationMark = questionOrExclamationMark
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.unexpectedBetweenQuestionOrExclamationMarkAndExpression = unexpectedBetweenQuestionOrExclamationMarkAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `TryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TryExprSyntax`.
  func buildTryExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TryExprSyntax {
    let result = TryExprSyntax(unexpectedBeforeTryKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), tryKeyword: tryKeyword.buildToken(), unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionOrExclamationMark: questionOrExclamationMark?.buildToken(), unexpectedBetweenQuestionOrExclamationMarkAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildTryExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTryExpr`.
  public func createTryExpr() -> TryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AwaitExpr: ExprBuildable, ExpressibleAsAwaitExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAwaitKeyword: UnexpectedNodes?
  let awaitKeyword: Token
  let unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `AwaitExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAwaitKeyword: 
  ///   - awaitKeyword: 
  ///   - unexpectedBetweenAwaitKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: Token, unexpectedBetweenAwaitKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAwaitKeyword = unexpectedBeforeAwaitKeyword?.createUnexpectedNodes()
    self.awaitKeyword = awaitKeyword
    assert(awaitKeyword.text == #"await"#)
    self.unexpectedBetweenAwaitKeywordAndExpression = unexpectedBetweenAwaitKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: String, unexpectedBetweenAwaitKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAwaitKeyword: unexpectedBeforeAwaitKeyword, awaitKeyword: Token.`contextualKeyword`(awaitKeyword), unexpectedBetweenAwaitKeywordAndExpression: unexpectedBetweenAwaitKeywordAndExpression, expression: expression)
  }
  /// Builds a `AwaitExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AwaitExprSyntax`.
  func buildAwaitExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AwaitExprSyntax {
    let result = AwaitExprSyntax(unexpectedBeforeAwaitKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), awaitKeyword: awaitKeyword.buildToken(), unexpectedBetweenAwaitKeywordAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildAwaitExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAwaitExpr`.
  public func createAwaitExpr() -> AwaitExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AwaitExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MoveExpr: ExprBuildable, ExpressibleAsMoveExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeMoveKeyword: UnexpectedNodes?
  let moveKeyword: Token
  let unexpectedBetweenMoveKeywordAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `MoveExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMoveKeyword: 
  ///   - moveKeyword: 
  ///   - unexpectedBetweenMoveKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMoveKeyword: ExpressibleAsUnexpectedNodes? = nil, moveKeyword: Token, unexpectedBetweenMoveKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeMoveKeyword = unexpectedBeforeMoveKeyword?.createUnexpectedNodes()
    self.moveKeyword = moveKeyword
    assert(moveKeyword.text == #"_move"#)
    self.unexpectedBetweenMoveKeywordAndExpression = unexpectedBetweenMoveKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMoveKeyword: ExpressibleAsUnexpectedNodes? = nil, moveKeyword: String, unexpectedBetweenMoveKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMoveKeyword: unexpectedBeforeMoveKeyword, moveKeyword: Token.`contextualKeyword`(moveKeyword), unexpectedBetweenMoveKeywordAndExpression: unexpectedBetweenMoveKeywordAndExpression, expression: expression)
  }
  /// Builds a `MoveExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MoveExprSyntax`.
  func buildMoveExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MoveExprSyntax {
    let result = MoveExprSyntax(unexpectedBeforeMoveKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), moveKeyword: moveKeyword.buildToken(), unexpectedBetweenMoveKeywordAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildMoveExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsMoveExpr`.
  public func createMoveExpr() -> MoveExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `MoveExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeclNameArgument: SyntaxBuildable, ExpressibleAsDeclNameArgument {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndColon: UnexpectedNodes?
  let colon: Token
  /// Creates a `DeclNameArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndColon = unexpectedBetweenNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
  }
  /// Builds a `DeclNameArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameArgumentSyntax`.
  func buildDeclNameArgument(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclNameArgumentSyntax {
    let result = DeclNameArgumentSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDeclNameArgument(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclNameArgument`.
  public func createDeclNameArgument() -> DeclNameArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclNameArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeclNameArguments: SyntaxBuildable, ExpressibleAsDeclNameArguments {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
  let arguments: DeclNameArgumentList
  let unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `DeclNameArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArgumentList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArguments = unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createDeclNameArgumentList()
    self.unexpectedBetweenArgumentsAndRightParen = unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `DeclNameArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameArgumentsSyntax`.
  func buildDeclNameArguments(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclNameArgumentsSyntax {
    let result = DeclNameArgumentsSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arguments: arguments.buildDeclNameArgumentList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDeclNameArguments(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclNameArguments`.
  public func createDeclNameArguments() -> DeclNameArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclNameArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IdentifierExpr: ExprBuildable, ExpressibleAsIdentifierExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodes?
  let declNameArguments: DeclNameArguments?
  /// Creates a `IdentifierExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndDeclNameArguments: 
  ///   - declNameArguments: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndDeclNameArguments = unexpectedBetweenIdentifierAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `IdentifierExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IdentifierExprSyntax`.
  func buildIdentifierExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IdentifierExprSyntax {
    let result = IdentifierExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndDeclNameArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildIdentifierExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIdentifierExpr`.
  public func createIdentifierExpr() -> IdentifierExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IdentifierExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SuperRefExpr: ExprBuildable, ExpressibleAsSuperRefExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeSuperKeyword: UnexpectedNodes?
  let superKeyword: Token
  /// Creates a `SuperRefExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSuperKeyword: 
  ///   - superKeyword: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSuperKeyword: ExpressibleAsUnexpectedNodes? = nil, superKeyword: Token = Token.`super`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeSuperKeyword = unexpectedBeforeSuperKeyword?.createUnexpectedNodes()
    self.superKeyword = superKeyword
    assert(superKeyword.text == #"super"#)
  }
  /// Builds a `SuperRefExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SuperRefExprSyntax`.
  func buildSuperRefExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SuperRefExprSyntax {
    let result = SuperRefExprSyntax(unexpectedBeforeSuperKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), superKeyword: superKeyword.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildSuperRefExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSuperRefExpr`.
  public func createSuperRefExpr() -> SuperRefExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SuperRefExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct NilLiteralExpr: ExprBuildable, ExpressibleAsNilLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeNilKeyword: UnexpectedNodes?
  let nilKeyword: Token
  /// Creates a `NilLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeNilKeyword: 
  ///   - nilKeyword: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeNilKeyword: ExpressibleAsUnexpectedNodes? = nil, nilKeyword: Token = Token.`nil`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeNilKeyword = unexpectedBeforeNilKeyword?.createUnexpectedNodes()
    self.nilKeyword = nilKeyword
    assert(nilKeyword.text == #"nil"#)
  }
  /// Builds a `NilLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NilLiteralExprSyntax`.
  func buildNilLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> NilLiteralExprSyntax {
    let result = NilLiteralExprSyntax(unexpectedBeforeNilKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), nilKeyword: nilKeyword.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildNilLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsNilLiteralExpr`.
  public func createNilLiteralExpr() -> NilLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `NilLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DiscardAssignmentExpr: ExprBuildable, ExpressibleAsDiscardAssignmentExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWildcard: UnexpectedNodes?
  let wildcard: Token
  /// Creates a `DiscardAssignmentExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWildcard: 
  ///   - wildcard: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWildcard: ExpressibleAsUnexpectedNodes? = nil, wildcard: Token = Token.`wildcard`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWildcard = unexpectedBeforeWildcard?.createUnexpectedNodes()
    self.wildcard = wildcard
    assert(wildcard.text == #"_"#)
  }
  /// Builds a `DiscardAssignmentExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DiscardAssignmentExprSyntax`.
  func buildDiscardAssignmentExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DiscardAssignmentExprSyntax {
    let result = DiscardAssignmentExprSyntax(unexpectedBeforeWildcard?.buildUnexpectedNodes(format: format, leadingTrivia: nil), wildcard: wildcard.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildDiscardAssignmentExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsDiscardAssignmentExpr`.
  public func createDiscardAssignmentExpr() -> DiscardAssignmentExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `DiscardAssignmentExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AssignmentExpr: ExprBuildable, ExpressibleAsAssignmentExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAssignToken: UnexpectedNodes?
  let assignToken: Token
  /// Creates a `AssignmentExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssignToken: 
  ///   - assignToken: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token = Token.`equal`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAssignToken = unexpectedBeforeAssignToken?.createUnexpectedNodes()
    self.assignToken = assignToken
    assert(assignToken.text == #"="#)
  }
  /// Builds a `AssignmentExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AssignmentExprSyntax`.
  func buildAssignmentExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AssignmentExprSyntax {
    let result = AssignmentExprSyntax(unexpectedBeforeAssignToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), assignToken: assignToken.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildAssignmentExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAssignmentExpr`.
  public func createAssignmentExpr() -> AssignmentExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AssignmentExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SequenceExpr: ExprBuildable, ExpressibleAsSequenceExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeElements: UnexpectedNodes?
  let elements: ExprList
  /// Creates a `SequenceExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsExprList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeElements = unexpectedBeforeElements?.createUnexpectedNodes()
    self.elements = elements.createExprList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, @ExprListBuilder elementsBuilder: () -> ExpressibleAsExprList =  {
    ExprList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeElements: unexpectedBeforeElements, elements: elementsBuilder())
  }
  /// Builds a `SequenceExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SequenceExprSyntax`.
  func buildSequenceExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SequenceExprSyntax {
    let result = SequenceExprSyntax(unexpectedBeforeElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildExprList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildSequenceExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSequenceExpr`.
  public func createSequenceExpr() -> SequenceExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SequenceExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundLineExpr: ExprBuildable, ExpressibleAsPoundLineExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundLine: UnexpectedNodes?
  let poundLine: Token
  /// Creates a `PoundLineExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundLine: 
  ///   - poundLine: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundLine: ExpressibleAsUnexpectedNodes? = nil, poundLine: Token = Token.`poundLine`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundLine = unexpectedBeforePoundLine?.createUnexpectedNodes()
    self.poundLine = poundLine
    assert(poundLine.text == #"#line"#)
  }
  /// Builds a `PoundLineExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundLineExprSyntax`.
  func buildPoundLineExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundLineExprSyntax {
    let result = PoundLineExprSyntax(unexpectedBeforePoundLine?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundLine: poundLine.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundLineExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundLineExpr`.
  public func createPoundLineExpr() -> PoundLineExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundLineExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundFileExpr: ExprBuildable, ExpressibleAsPoundFileExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundFile: UnexpectedNodes?
  let poundFile: Token
  /// Creates a `PoundFileExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFile: 
  ///   - poundFile: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundFile: ExpressibleAsUnexpectedNodes? = nil, poundFile: Token = Token.`poundFile`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundFile = unexpectedBeforePoundFile?.createUnexpectedNodes()
    self.poundFile = poundFile
    assert(poundFile.text == #"#file"#)
  }
  /// Builds a `PoundFileExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFileExprSyntax`.
  func buildPoundFileExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundFileExprSyntax {
    let result = PoundFileExprSyntax(unexpectedBeforePoundFile?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundFile: poundFile.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundFileExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFileExpr`.
  public func createPoundFileExpr() -> PoundFileExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFileExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundFileIDExpr: ExprBuildable, ExpressibleAsPoundFileIDExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundFileID: UnexpectedNodes?
  let poundFileID: Token
  /// Creates a `PoundFileIDExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFileID: 
  ///   - poundFileID: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundFileID: ExpressibleAsUnexpectedNodes? = nil, poundFileID: Token = Token.`poundFileID`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundFileID = unexpectedBeforePoundFileID?.createUnexpectedNodes()
    self.poundFileID = poundFileID
    assert(poundFileID.text == #"#fileID"#)
  }
  /// Builds a `PoundFileIDExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFileIDExprSyntax`.
  func buildPoundFileIDExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundFileIDExprSyntax {
    let result = PoundFileIDExprSyntax(unexpectedBeforePoundFileID?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundFileID: poundFileID.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundFileIDExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFileIDExpr`.
  public func createPoundFileIDExpr() -> PoundFileIDExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFileIDExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundFilePathExpr: ExprBuildable, ExpressibleAsPoundFilePathExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundFilePath: UnexpectedNodes?
  let poundFilePath: Token
  /// Creates a `PoundFilePathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFilePath: 
  ///   - poundFilePath: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundFilePath: ExpressibleAsUnexpectedNodes? = nil, poundFilePath: Token = Token.`poundFilePath`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundFilePath = unexpectedBeforePoundFilePath?.createUnexpectedNodes()
    self.poundFilePath = poundFilePath
    assert(poundFilePath.text == #"#filePath"#)
  }
  /// Builds a `PoundFilePathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFilePathExprSyntax`.
  func buildPoundFilePathExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundFilePathExprSyntax {
    let result = PoundFilePathExprSyntax(unexpectedBeforePoundFilePath?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundFilePath: poundFilePath.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundFilePathExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFilePathExpr`.
  public func createPoundFilePathExpr() -> PoundFilePathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFilePathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundFunctionExpr: ExprBuildable, ExpressibleAsPoundFunctionExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundFunction: UnexpectedNodes?
  let poundFunction: Token
  /// Creates a `PoundFunctionExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFunction: 
  ///   - poundFunction: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundFunction: ExpressibleAsUnexpectedNodes? = nil, poundFunction: Token = Token.`poundFunction`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundFunction = unexpectedBeforePoundFunction?.createUnexpectedNodes()
    self.poundFunction = poundFunction
    assert(poundFunction.text == #"#function"#)
  }
  /// Builds a `PoundFunctionExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFunctionExprSyntax`.
  func buildPoundFunctionExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundFunctionExprSyntax {
    let result = PoundFunctionExprSyntax(unexpectedBeforePoundFunction?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundFunction: poundFunction.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundFunctionExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFunctionExpr`.
  public func createPoundFunctionExpr() -> PoundFunctionExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFunctionExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundDsohandleExpr: ExprBuildable, ExpressibleAsPoundDsohandleExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundDsohandle: UnexpectedNodes?
  let poundDsohandle: Token
  /// Creates a `PoundDsohandleExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundDsohandle: 
  ///   - poundDsohandle: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundDsohandle: ExpressibleAsUnexpectedNodes? = nil, poundDsohandle: Token = Token.`poundDsohandle`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundDsohandle = unexpectedBeforePoundDsohandle?.createUnexpectedNodes()
    self.poundDsohandle = poundDsohandle
    assert(poundDsohandle.text == #"#dsohandle"#)
  }
  /// Builds a `PoundDsohandleExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundDsohandleExprSyntax`.
  func buildPoundDsohandleExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundDsohandleExprSyntax {
    let result = PoundDsohandleExprSyntax(unexpectedBeforePoundDsohandle?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundDsohandle: poundDsohandle.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPoundDsohandleExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundDsohandleExpr`.
  public func createPoundDsohandleExpr() -> PoundDsohandleExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundDsohandleExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SymbolicReferenceExpr: ExprBuildable, ExpressibleAsSymbolicReferenceExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericArgumentClause: UnexpectedNodes?
  let genericArgumentClause: GenericArgumentClause?
  /// Creates a `SymbolicReferenceExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericArgumentClause = unexpectedBetweenIdentifierAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause?.createGenericArgumentClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericArgumentClause: unexpectedBetweenIdentifierAndGenericArgumentClause, genericArgumentClause: genericArgumentClause)
  }
  /// Builds a `SymbolicReferenceExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SymbolicReferenceExprSyntax`.
  func buildSymbolicReferenceExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SymbolicReferenceExprSyntax {
    let result = SymbolicReferenceExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericArgumentClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericArgumentClause: genericArgumentClause?.buildGenericArgumentClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildSymbolicReferenceExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSymbolicReferenceExpr`.
  public func createSymbolicReferenceExpr() -> SymbolicReferenceExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SymbolicReferenceExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PrefixOperatorExpr: ExprBuildable, ExpressibleAsPrefixOperatorExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeOperatorToken: UnexpectedNodes?
  let operatorToken: Token?
  let unexpectedBetweenOperatorTokenAndPostfixExpression: UnexpectedNodes?
  let postfixExpression: ExprBuildable
  /// Creates a `PrefixOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOperatorToken: 
  ///   - operatorToken: 
  ///   - unexpectedBetweenOperatorTokenAndPostfixExpression: 
  ///   - postfixExpression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token? = nil, unexpectedBetweenOperatorTokenAndPostfixExpression: ExpressibleAsUnexpectedNodes? = nil, postfixExpression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeOperatorToken = unexpectedBeforeOperatorToken?.createUnexpectedNodes()
    self.operatorToken = operatorToken
    self.unexpectedBetweenOperatorTokenAndPostfixExpression = unexpectedBetweenOperatorTokenAndPostfixExpression?.createUnexpectedNodes()
    self.postfixExpression = postfixExpression.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: String?, unexpectedBetweenOperatorTokenAndPostfixExpression: ExpressibleAsUnexpectedNodes? = nil, postfixExpression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOperatorToken: unexpectedBeforeOperatorToken, operatorToken: operatorToken.map {
      Token.`prefixOperator`($0)
    }, unexpectedBetweenOperatorTokenAndPostfixExpression: unexpectedBetweenOperatorTokenAndPostfixExpression, postfixExpression: postfixExpression)
  }
  /// Builds a `PrefixOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrefixOperatorExprSyntax`.
  func buildPrefixOperatorExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrefixOperatorExprSyntax {
    let result = PrefixOperatorExprSyntax(unexpectedBeforeOperatorToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), operatorToken: operatorToken?.buildToken(), unexpectedBetweenOperatorTokenAndPostfixExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), postfixExpression: postfixExpression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPrefixOperatorExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPrefixOperatorExpr`.
  public func createPrefixOperatorExpr() -> PrefixOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PrefixOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct BinaryOperatorExpr: ExprBuildable, ExpressibleAsBinaryOperatorExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeOperatorToken: UnexpectedNodes?
  let operatorToken: Token
  /// Creates a `BinaryOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOperatorToken: 
  ///   - operatorToken: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeOperatorToken = unexpectedBeforeOperatorToken?.createUnexpectedNodes()
    self.operatorToken = operatorToken
  }
  /// Builds a `BinaryOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BinaryOperatorExprSyntax`.
  func buildBinaryOperatorExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> BinaryOperatorExprSyntax {
    let result = BinaryOperatorExprSyntax(unexpectedBeforeOperatorToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), operatorToken: operatorToken.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildBinaryOperatorExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsBinaryOperatorExpr`.
  public func createBinaryOperatorExpr() -> BinaryOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `BinaryOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ArrowExpr: ExprBuildable, ExpressibleAsArrowExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAsyncKeyword: UnexpectedNodes?
  let asyncKeyword: Token?
  let unexpectedBetweenAsyncKeywordAndThrowsToken: UnexpectedNodes?
  let throwsToken: Token?
  let unexpectedBetweenThrowsTokenAndArrowToken: UnexpectedNodes?
  let arrowToken: Token
  /// Creates a `ArrowExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsToken: 
  ///   - throwsToken: 
  ///   - unexpectedBetweenThrowsTokenAndArrowToken: 
  ///   - arrowToken: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsToken: ExpressibleAsUnexpectedNodes? = nil, throwsToken: Token? = nil, unexpectedBetweenThrowsTokenAndArrowToken: ExpressibleAsUnexpectedNodes? = nil, arrowToken: Token = Token.`arrow`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAsyncKeyword = unexpectedBeforeAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsToken = unexpectedBetweenAsyncKeywordAndThrowsToken?.createUnexpectedNodes()
    self.throwsToken = throwsToken
    assert(throwsToken == nil || throwsToken!.text == #"throws"#)
    self.unexpectedBetweenThrowsTokenAndArrowToken = unexpectedBetweenThrowsTokenAndArrowToken?.createUnexpectedNodes()
    self.arrowToken = arrowToken
    assert(arrowToken.text == #"->"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsToken: ExpressibleAsUnexpectedNodes? = nil, throwsToken: Token? = nil, unexpectedBetweenThrowsTokenAndArrowToken: ExpressibleAsUnexpectedNodes? = nil, arrowToken: Token = Token.`arrow`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAsyncKeyword: unexpectedBeforeAsyncKeyword, asyncKeyword: asyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncKeywordAndThrowsToken: unexpectedBetweenAsyncKeywordAndThrowsToken, throwsToken: throwsToken, unexpectedBetweenThrowsTokenAndArrowToken: unexpectedBetweenThrowsTokenAndArrowToken, arrowToken: arrowToken)
  }
  /// Builds a `ArrowExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrowExprSyntax`.
  func buildArrowExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ArrowExprSyntax {
    let result = ArrowExprSyntax(unexpectedBeforeAsyncKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asyncKeyword: asyncKeyword?.buildToken(), unexpectedBetweenAsyncKeywordAndThrowsToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), throwsToken: throwsToken?.buildToken(), unexpectedBetweenThrowsTokenAndArrowToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arrowToken: arrowToken.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildArrowExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrowExpr`.
  public func createArrowExpr() -> ArrowExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ArrowExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct InfixOperatorExpr: ExprBuildable, ExpressibleAsInfixOperatorExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftOperand: UnexpectedNodes?
  let leftOperand: ExprBuildable
  let unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodes?
  let operatorOperand: ExprBuildable
  let unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodes?
  let rightOperand: ExprBuildable
  /// Creates a `InfixOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftOperand: 
  ///   - leftOperand: 
  ///   - unexpectedBetweenLeftOperandAndOperatorOperand: 
  ///   - operatorOperand: 
  ///   - unexpectedBetweenOperatorOperandAndRightOperand: 
  ///   - rightOperand: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftOperand: ExpressibleAsUnexpectedNodes? = nil, leftOperand: ExpressibleAsExprBuildable, unexpectedBetweenLeftOperandAndOperatorOperand: ExpressibleAsUnexpectedNodes? = nil, operatorOperand: ExpressibleAsExprBuildable, unexpectedBetweenOperatorOperandAndRightOperand: ExpressibleAsUnexpectedNodes? = nil, rightOperand: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftOperand = unexpectedBeforeLeftOperand?.createUnexpectedNodes()
    self.leftOperand = leftOperand.createExprBuildable()
    self.unexpectedBetweenLeftOperandAndOperatorOperand = unexpectedBetweenLeftOperandAndOperatorOperand?.createUnexpectedNodes()
    self.operatorOperand = operatorOperand.createExprBuildable()
    self.unexpectedBetweenOperatorOperandAndRightOperand = unexpectedBetweenOperatorOperandAndRightOperand?.createUnexpectedNodes()
    self.rightOperand = rightOperand.createExprBuildable()
  }
  /// Builds a `InfixOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InfixOperatorExprSyntax`.
  func buildInfixOperatorExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> InfixOperatorExprSyntax {
    let result = InfixOperatorExprSyntax(unexpectedBeforeLeftOperand?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftOperand: leftOperand.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenLeftOperandAndOperatorOperand?.buildUnexpectedNodes(format: format, leadingTrivia: nil), operatorOperand: operatorOperand.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenOperatorOperandAndRightOperand?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightOperand: rightOperand.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildInfixOperatorExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsInfixOperatorExpr`.
  public func createInfixOperatorExpr() -> InfixOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `InfixOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct FloatLiteralExpr: ExprBuildable, ExpressibleAsFloatLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeFloatingDigits: UnexpectedNodes?
  let floatingDigits: Token
  /// Creates a `FloatLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFloatingDigits: 
  ///   - floatingDigits: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFloatingDigits: ExpressibleAsUnexpectedNodes? = nil, floatingDigits: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeFloatingDigits = unexpectedBeforeFloatingDigits?.createUnexpectedNodes()
    self.floatingDigits = floatingDigits
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFloatingDigits: ExpressibleAsUnexpectedNodes? = nil, floatingDigits: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeFloatingDigits: unexpectedBeforeFloatingDigits, floatingDigits: Token.`floatingLiteral`(floatingDigits))
  }
  /// Builds a `FloatLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FloatLiteralExprSyntax`.
  func buildFloatLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FloatLiteralExprSyntax {
    let result = FloatLiteralExprSyntax(unexpectedBeforeFloatingDigits?.buildUnexpectedNodes(format: format, leadingTrivia: nil), floatingDigits: floatingDigits.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildFloatLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsFloatLiteralExpr`.
  public func createFloatLiteralExpr() -> FloatLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `FloatLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TupleExpr: ExprBuildable, ExpressibleAsTupleExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndElementList: UnexpectedNodes?
  let elementList: TupleExprElementList
  let unexpectedBetweenElementListAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `TupleExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElementList: 
  ///   - elementList: 
  ///   - unexpectedBetweenElementListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, elementList: ExpressibleAsTupleExprElementList, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElementList = unexpectedBetweenLeftParenAndElementList?.createUnexpectedNodes()
    self.elementList = elementList.createTupleExprElementList()
    self.unexpectedBetweenElementListAndRightParen = unexpectedBetweenElementListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TupleExprElementListBuilder elementListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList, elementList: elementListBuilder(), unexpectedBetweenElementListAndRightParen: unexpectedBetweenElementListAndRightParen, rightParen: rightParen)
  }
  /// Builds a `TupleExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleExprSyntax`.
  func buildTupleExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TupleExprSyntax {
    let result = TupleExprSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndElementList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elementList: elementList.buildTupleExprElementList(format: format, leadingTrivia: nil), unexpectedBetweenElementListAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildTupleExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTupleExpr`.
  public func createTupleExpr() -> TupleExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TupleExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ArrayExpr: ExprBuildable, ExpressibleAsArrayExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftSquare: UnexpectedNodes?
  let leftSquare: Token
  let unexpectedBetweenLeftSquareAndElements: UnexpectedNodes?
  let elements: ArrayElementList
  let unexpectedBetweenElementsAndRightSquare: UnexpectedNodes?
  let rightSquare: Token
  /// Creates a `ArrayExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsArrayElementList, unexpectedBetweenElementsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftSquare = unexpectedBeforeLeftSquare?.createUnexpectedNodes()
    self.leftSquare = leftSquare
    assert(leftSquare.text == #"["#)
    self.unexpectedBetweenLeftSquareAndElements = unexpectedBetweenLeftSquareAndElements?.createUnexpectedNodes()
    self.elements = elements.createArrayElementList()
    self.unexpectedBetweenElementsAndRightSquare = unexpectedBetweenElementsAndRightSquare?.createUnexpectedNodes()
    self.rightSquare = rightSquare
    assert(rightSquare.text == #"]"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndElements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`, @ArrayElementListBuilder elementsBuilder: () -> ExpressibleAsArrayElementList =  {
    ArrayElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare, leftSquare: leftSquare, unexpectedBetweenLeftSquareAndElements: unexpectedBetweenLeftSquareAndElements, elements: elementsBuilder(), unexpectedBetweenElementsAndRightSquare: unexpectedBetweenElementsAndRightSquare, rightSquare: rightSquare)
  }
  /// Builds a `ArrayExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayExprSyntax`.
  func buildArrayExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ArrayExprSyntax {
    let result = ArrayExprSyntax(unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftSquare: leftSquare.buildToken(), unexpectedBetweenLeftSquareAndElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildArrayElementList(format: format, leadingTrivia: nil), unexpectedBetweenElementsAndRightSquare?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightSquare: rightSquare.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildArrayExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrayExpr`.
  public func createArrayExpr() -> ArrayExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ArrayExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DictionaryExpr: ExprBuildable, ExpressibleAsDictionaryExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftSquare: UnexpectedNodes?
  let leftSquare: Token
  let unexpectedBetweenLeftSquareAndContent: UnexpectedNodes?
  let content: SyntaxBuildable
  let unexpectedBetweenContentAndRightSquare: UnexpectedNodes?
  let rightSquare: Token
  /// Creates a `DictionaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndContent: 
  ///   - content: 
  ///   - unexpectedBetweenContentAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndContent: ExpressibleAsUnexpectedNodes? = nil, content: ExpressibleAsSyntaxBuildable, unexpectedBetweenContentAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftSquare = unexpectedBeforeLeftSquare?.createUnexpectedNodes()
    self.leftSquare = leftSquare
    assert(leftSquare.text == #"["#)
    self.unexpectedBetweenLeftSquareAndContent = unexpectedBetweenLeftSquareAndContent?.createUnexpectedNodes()
    self.content = content.createSyntaxBuildable()
    self.unexpectedBetweenContentAndRightSquare = unexpectedBetweenContentAndRightSquare?.createUnexpectedNodes()
    self.rightSquare = rightSquare
    assert(rightSquare.text == #"]"#)
  }
  /// Builds a `DictionaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryExprSyntax`.
  func buildDictionaryExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DictionaryExprSyntax {
    let result = DictionaryExprSyntax(unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftSquare: leftSquare.buildToken(), unexpectedBetweenLeftSquareAndContent?.buildUnexpectedNodes(format: format, leadingTrivia: nil), content: content.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenContentAndRightSquare?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightSquare: rightSquare.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildDictionaryExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryExpr`.
  public func createDictionaryExpr() -> DictionaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `DictionaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TupleExprElement: SyntaxBuildable, ExpressibleAsTupleExprElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabel: UnexpectedNodes?
  let label: Token?
  let unexpectedBetweenLabelAndColon: UnexpectedNodes?
  let colon: Token?
  let unexpectedBetweenColonAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `TupleExprElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndExpression = unexpectedBetweenColonAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndTrailingComma = unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `TupleExprElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleExprElementSyntax`.
  func buildTupleExprElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TupleExprElementSyntax {
    let result = TupleExprElementSyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label?.buildToken(), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon?.buildToken(), unexpectedBetweenColonAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTupleExprElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTupleExprElement`.
  public func createTupleExprElement() -> TupleExprElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TupleExprElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeLabel: unexpectedBeforeLabel, label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndExpression: unexpectedBetweenColonAndExpression, expression: expression, unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct ArrayElement: SyntaxBuildable, ExpressibleAsArrayElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `ArrayElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndTrailingComma = unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `ArrayElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayElementSyntax`.
  func buildArrayElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ArrayElementSyntax {
    let result = ArrayElementSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildArrayElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsArrayElement`.
  public func createArrayElement() -> ArrayElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ArrayElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeExpression: unexpectedBeforeExpression, expression: expression, unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct DictionaryElement: SyntaxBuildable, ExpressibleAsDictionaryElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeKeyExpression: UnexpectedNodes?
  let keyExpression: ExprBuildable
  let unexpectedBetweenKeyExpressionAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndValueExpression: UnexpectedNodes?
  let valueExpression: ExprBuildable
  let unexpectedBetweenValueExpressionAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `DictionaryElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeKeyExpression: 
  ///   - keyExpression: 
  ///   - unexpectedBetweenKeyExpressionAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValueExpression: 
  ///   - valueExpression: 
  ///   - unexpectedBetweenValueExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeKeyExpression: ExpressibleAsUnexpectedNodes? = nil, keyExpression: ExpressibleAsExprBuildable, unexpectedBetweenKeyExpressionAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValueExpression: ExpressibleAsUnexpectedNodes? = nil, valueExpression: ExpressibleAsExprBuildable, unexpectedBetweenValueExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeKeyExpression = unexpectedBeforeKeyExpression?.createUnexpectedNodes()
    self.keyExpression = keyExpression.createExprBuildable()
    self.unexpectedBetweenKeyExpressionAndColon = unexpectedBetweenKeyExpressionAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValueExpression = unexpectedBetweenColonAndValueExpression?.createUnexpectedNodes()
    self.valueExpression = valueExpression.createExprBuildable()
    self.unexpectedBetweenValueExpressionAndTrailingComma = unexpectedBetweenValueExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `DictionaryElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryElementSyntax`.
  func buildDictionaryElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DictionaryElementSyntax {
    let result = DictionaryElementSyntax(unexpectedBeforeKeyExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), keyExpression: keyExpression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenKeyExpressionAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndValueExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), valueExpression: valueExpression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenValueExpressionAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDictionaryElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryElement`.
  public func createDictionaryElement() -> DictionaryElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DictionaryElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeKeyExpression: unexpectedBeforeKeyExpression, keyExpression: keyExpression, unexpectedBetweenKeyExpressionAndColon: unexpectedBetweenKeyExpressionAndColon, colon: colon, unexpectedBetweenColonAndValueExpression: unexpectedBetweenColonAndValueExpression, valueExpression: valueExpression, unexpectedBetweenValueExpressionAndTrailingComma: unexpectedBetweenValueExpressionAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct IntegerLiteralExpr: ExprBuildable, ExpressibleAsIntegerLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDigits: UnexpectedNodes?
  let digits: Token
  /// Creates a `IntegerLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDigits: 
  ///   - digits: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDigits: ExpressibleAsUnexpectedNodes? = nil, digits: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDigits = unexpectedBeforeDigits?.createUnexpectedNodes()
    self.digits = digits
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDigits: ExpressibleAsUnexpectedNodes? = nil, digits: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDigits: unexpectedBeforeDigits, digits: Token.`integerLiteral`(digits))
  }
  /// Builds a `IntegerLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IntegerLiteralExprSyntax`.
  func buildIntegerLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IntegerLiteralExprSyntax {
    let result = IntegerLiteralExprSyntax(unexpectedBeforeDigits?.buildUnexpectedNodes(format: format, leadingTrivia: nil), digits: digits.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildIntegerLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIntegerLiteralExpr`.
  public func createIntegerLiteralExpr() -> IntegerLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IntegerLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct BooleanLiteralExpr: ExprBuildable, ExpressibleAsBooleanLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBooleanLiteral: UnexpectedNodes?
  let booleanLiteral: Token
  /// Creates a `BooleanLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBooleanLiteral: 
  ///   - booleanLiteral: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBooleanLiteral: ExpressibleAsUnexpectedNodes? = nil, booleanLiteral: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBooleanLiteral = unexpectedBeforeBooleanLiteral?.createUnexpectedNodes()
    self.booleanLiteral = booleanLiteral
    assert(booleanLiteral.text == #"true"# || booleanLiteral.text == #"false"#)
  }
  /// Builds a `BooleanLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BooleanLiteralExprSyntax`.
  func buildBooleanLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> BooleanLiteralExprSyntax {
    let result = BooleanLiteralExprSyntax(unexpectedBeforeBooleanLiteral?.buildUnexpectedNodes(format: format, leadingTrivia: nil), booleanLiteral: booleanLiteral.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildBooleanLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsBooleanLiteralExpr`.
  public func createBooleanLiteralExpr() -> BooleanLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `BooleanLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct UnresolvedTernaryExpr: ExprBuildable, ExpressibleAsUnresolvedTernaryExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeQuestionMark: UnexpectedNodes?
  let questionMark: Token
  let unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodes?
  let firstChoice: ExprBuildable
  let unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodes?
  let colonMark: Token
  /// Creates a `UnresolvedTernaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeQuestionMark: 
  ///   - questionMark: 
  ///   - unexpectedBetweenQuestionMarkAndFirstChoice: 
  ///   - firstChoice: 
  ///   - unexpectedBetweenFirstChoiceAndColonMark: 
  ///   - colonMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`infixQuestionMark`, unexpectedBetweenQuestionMarkAndFirstChoice: ExpressibleAsUnexpectedNodes? = nil, firstChoice: ExpressibleAsExprBuildable, unexpectedBetweenFirstChoiceAndColonMark: ExpressibleAsUnexpectedNodes? = nil, colonMark: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeQuestionMark = unexpectedBeforeQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
    self.unexpectedBetweenQuestionMarkAndFirstChoice = unexpectedBetweenQuestionMarkAndFirstChoice?.createUnexpectedNodes()
    self.firstChoice = firstChoice.createExprBuildable()
    self.unexpectedBetweenFirstChoiceAndColonMark = unexpectedBetweenFirstChoiceAndColonMark?.createUnexpectedNodes()
    self.colonMark = colonMark
    assert(colonMark.text == #":"#)
  }
  /// Builds a `UnresolvedTernaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedTernaryExprSyntax`.
  func buildUnresolvedTernaryExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> UnresolvedTernaryExprSyntax {
    let result = UnresolvedTernaryExprSyntax(unexpectedBeforeQuestionMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionMark: questionMark.buildToken(), unexpectedBetweenQuestionMarkAndFirstChoice?.buildUnexpectedNodes(format: format, leadingTrivia: nil), firstChoice: firstChoice.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenFirstChoiceAndColonMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colonMark: colonMark.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildUnresolvedTernaryExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedTernaryExpr`.
  public func createUnresolvedTernaryExpr() -> UnresolvedTernaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedTernaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TernaryExpr: ExprBuildable, ExpressibleAsTernaryExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeConditionExpression: UnexpectedNodes?
  let conditionExpression: ExprBuildable
  let unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodes?
  let questionMark: Token
  let unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodes?
  let firstChoice: ExprBuildable
  let unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodes?
  let colonMark: Token
  let unexpectedBetweenColonMarkAndSecondChoice: UnexpectedNodes?
  let secondChoice: ExprBuildable
  /// Creates a `TernaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeConditionExpression: 
  ///   - conditionExpression: 
  ///   - unexpectedBetweenConditionExpressionAndQuestionMark: 
  ///   - questionMark: 
  ///   - unexpectedBetweenQuestionMarkAndFirstChoice: 
  ///   - firstChoice: 
  ///   - unexpectedBetweenFirstChoiceAndColonMark: 
  ///   - colonMark: 
  ///   - unexpectedBetweenColonMarkAndSecondChoice: 
  ///   - secondChoice: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeConditionExpression: ExpressibleAsUnexpectedNodes? = nil, conditionExpression: ExpressibleAsExprBuildable, unexpectedBetweenConditionExpressionAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`infixQuestionMark`, unexpectedBetweenQuestionMarkAndFirstChoice: ExpressibleAsUnexpectedNodes? = nil, firstChoice: ExpressibleAsExprBuildable, unexpectedBetweenFirstChoiceAndColonMark: ExpressibleAsUnexpectedNodes? = nil, colonMark: Token = Token.`colon`, unexpectedBetweenColonMarkAndSecondChoice: ExpressibleAsUnexpectedNodes? = nil, secondChoice: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeConditionExpression = unexpectedBeforeConditionExpression?.createUnexpectedNodes()
    self.conditionExpression = conditionExpression.createExprBuildable()
    self.unexpectedBetweenConditionExpressionAndQuestionMark = unexpectedBetweenConditionExpressionAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
    self.unexpectedBetweenQuestionMarkAndFirstChoice = unexpectedBetweenQuestionMarkAndFirstChoice?.createUnexpectedNodes()
    self.firstChoice = firstChoice.createExprBuildable()
    self.unexpectedBetweenFirstChoiceAndColonMark = unexpectedBetweenFirstChoiceAndColonMark?.createUnexpectedNodes()
    self.colonMark = colonMark
    assert(colonMark.text == #":"#)
    self.unexpectedBetweenColonMarkAndSecondChoice = unexpectedBetweenColonMarkAndSecondChoice?.createUnexpectedNodes()
    self.secondChoice = secondChoice.createExprBuildable()
  }
  /// Builds a `TernaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TernaryExprSyntax`.
  func buildTernaryExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TernaryExprSyntax {
    let result = TernaryExprSyntax(unexpectedBeforeConditionExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), conditionExpression: conditionExpression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenConditionExpressionAndQuestionMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionMark: questionMark.buildToken(), unexpectedBetweenQuestionMarkAndFirstChoice?.buildUnexpectedNodes(format: format, leadingTrivia: nil), firstChoice: firstChoice.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenFirstChoiceAndColonMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colonMark: colonMark.buildToken(), unexpectedBetweenColonMarkAndSecondChoice?.buildUnexpectedNodes(format: format, leadingTrivia: nil), secondChoice: secondChoice.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildTernaryExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTernaryExpr`.
  public func createTernaryExpr() -> TernaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TernaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MemberAccessExpr: ExprBuildable, ExpressibleAsMemberAccessExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBase: UnexpectedNodes?
  let base: ExprBuildable?
  let unexpectedBetweenBaseAndDot: UnexpectedNodes?
  let dot: Token
  let unexpectedBetweenDotAndName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodes?
  let declNameArguments: DeclNameArguments?
  /// Creates a `MemberAccessExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBase: 
  ///   - base: 
  ///   - unexpectedBetweenBaseAndDot: 
  ///   - dot: 
  ///   - unexpectedBetweenDotAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDeclNameArguments: 
  ///   - declNameArguments: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBase: ExpressibleAsUnexpectedNodes? = nil, base: ExpressibleAsExprBuildable? = nil, unexpectedBetweenBaseAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token, unexpectedBetweenDotAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBase = unexpectedBeforeBase?.createUnexpectedNodes()
    self.base = base?.createExprBuildable()
    self.unexpectedBetweenBaseAndDot = unexpectedBetweenBaseAndDot?.createUnexpectedNodes()
    self.dot = dot
    assert(dot.text == #"."# || dot.text == #"."#)
    self.unexpectedBetweenDotAndName = unexpectedBetweenDotAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndDeclNameArguments = unexpectedBetweenNameAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `MemberAccessExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberAccessExprSyntax`.
  func buildMemberAccessExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MemberAccessExprSyntax {
    let result = MemberAccessExprSyntax(unexpectedBeforeBase?.buildUnexpectedNodes(format: format, leadingTrivia: nil), base: base?.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenBaseAndDot?.buildUnexpectedNodes(format: format, leadingTrivia: nil), dot: dot.buildToken(), unexpectedBetweenDotAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndDeclNameArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildMemberAccessExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsMemberAccessExpr`.
  public func createMemberAccessExpr() -> MemberAccessExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `MemberAccessExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct UnresolvedIsExpr: ExprBuildable, ExpressibleAsUnresolvedIsExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIsTok: UnexpectedNodes?
  let isTok: Token
  /// Creates a `UnresolvedIsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIsTok: 
  ///   - isTok: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIsTok: ExpressibleAsUnexpectedNodes? = nil, isTok: Token = Token.`is`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIsTok = unexpectedBeforeIsTok?.createUnexpectedNodes()
    self.isTok = isTok
    assert(isTok.text == #"is"#)
  }
  /// Builds a `UnresolvedIsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedIsExprSyntax`.
  func buildUnresolvedIsExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> UnresolvedIsExprSyntax {
    let result = UnresolvedIsExprSyntax(unexpectedBeforeIsTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), isTok: isTok.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildUnresolvedIsExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedIsExpr`.
  public func createUnresolvedIsExpr() -> UnresolvedIsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedIsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IsExpr: ExprBuildable, ExpressibleAsIsExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndIsTok: UnexpectedNodes?
  let isTok: Token
  let unexpectedBetweenIsTokAndTypeName: UnexpectedNodes?
  let typeName: TypeBuildable
  /// Creates a `IsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndIsTok: 
  ///   - isTok: 
  ///   - unexpectedBetweenIsTokAndTypeName: 
  ///   - typeName: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndIsTok: ExpressibleAsUnexpectedNodes? = nil, isTok: Token = Token.`is`, unexpectedBetweenIsTokAndTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndIsTok = unexpectedBetweenExpressionAndIsTok?.createUnexpectedNodes()
    self.isTok = isTok
    assert(isTok.text == #"is"#)
    self.unexpectedBetweenIsTokAndTypeName = unexpectedBetweenIsTokAndTypeName?.createUnexpectedNodes()
    self.typeName = typeName.createTypeBuildable()
  }
  /// Builds a `IsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IsExprSyntax`.
  func buildIsExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IsExprSyntax {
    let result = IsExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndIsTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), isTok: isTok.buildToken(), unexpectedBetweenIsTokAndTypeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeName: typeName.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildIsExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIsExpr`.
  public func createIsExpr() -> IsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct UnresolvedAsExpr: ExprBuildable, ExpressibleAsUnresolvedAsExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAsTok: UnexpectedNodes?
  let asTok: Token
  let unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodes?
  let questionOrExclamationMark: Token?
  /// Creates a `UnresolvedAsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAsTok: 
  ///   - asTok: 
  ///   - unexpectedBetweenAsTokAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAsTok: ExpressibleAsUnexpectedNodes? = nil, asTok: Token = Token.`as`, unexpectedBetweenAsTokAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAsTok = unexpectedBeforeAsTok?.createUnexpectedNodes()
    self.asTok = asTok
    assert(asTok.text == #"as"#)
    self.unexpectedBetweenAsTokAndQuestionOrExclamationMark = unexpectedBetweenAsTokAndQuestionOrExclamationMark?.createUnexpectedNodes()
    self.questionOrExclamationMark = questionOrExclamationMark
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
  }
  /// Builds a `UnresolvedAsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedAsExprSyntax`.
  func buildUnresolvedAsExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> UnresolvedAsExprSyntax {
    let result = UnresolvedAsExprSyntax(unexpectedBeforeAsTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asTok: asTok.buildToken(), unexpectedBetweenAsTokAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionOrExclamationMark: questionOrExclamationMark?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildUnresolvedAsExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedAsExpr`.
  public func createUnresolvedAsExpr() -> UnresolvedAsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedAsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AsExpr: ExprBuildable, ExpressibleAsAsExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndAsTok: UnexpectedNodes?
  let asTok: Token
  let unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodes?
  let questionOrExclamationMark: Token?
  let unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodes?
  let typeName: TypeBuildable
  /// Creates a `AsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndAsTok: 
  ///   - asTok: 
  ///   - unexpectedBetweenAsTokAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  ///   - unexpectedBetweenQuestionOrExclamationMarkAndTypeName: 
  ///   - typeName: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndAsTok: ExpressibleAsUnexpectedNodes? = nil, asTok: Token = Token.`as`, unexpectedBetweenAsTokAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil, unexpectedBetweenQuestionOrExclamationMarkAndTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndAsTok = unexpectedBetweenExpressionAndAsTok?.createUnexpectedNodes()
    self.asTok = asTok
    assert(asTok.text == #"as"#)
    self.unexpectedBetweenAsTokAndQuestionOrExclamationMark = unexpectedBetweenAsTokAndQuestionOrExclamationMark?.createUnexpectedNodes()
    self.questionOrExclamationMark = questionOrExclamationMark
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.unexpectedBetweenQuestionOrExclamationMarkAndTypeName = unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.createUnexpectedNodes()
    self.typeName = typeName.createTypeBuildable()
  }
  /// Builds a `AsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AsExprSyntax`.
  func buildAsExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AsExprSyntax {
    let result = AsExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndAsTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asTok: asTok.buildToken(), unexpectedBetweenAsTokAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionOrExclamationMark: questionOrExclamationMark?.buildToken(), unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeName: typeName.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildAsExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAsExpr`.
  public func createAsExpr() -> AsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TypeExpr: ExprBuildable, ExpressibleAsTypeExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeType: UnexpectedNodes?
  let type: TypeBuildable
  /// Creates a `TypeExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `TypeExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeExprSyntax`.
  func buildTypeExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeExprSyntax {
    let result = TypeExprSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildTypeExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTypeExpr`.
  public func createTypeExpr() -> TypeExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TypeExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ClosureCaptureItem: SyntaxBuildable, ExpressibleAsClosureCaptureItem, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeSpecifier: UnexpectedNodes?
  let specifier: TokenList?
  let unexpectedBetweenSpecifierAndName: UnexpectedNodes?
  let name: Token?
  let unexpectedBetweenNameAndAssignToken: UnexpectedNodes?
  let assignToken: Token?
  let unexpectedBetweenAssignTokenAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `ClosureCaptureItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSpecifier: 
  ///   - specifier: 
  ///   - unexpectedBetweenSpecifierAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndAssignToken: 
  ///   - assignToken: 
  ///   - unexpectedBetweenAssignTokenAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: ExpressibleAsTokenList? = nil, unexpectedBetweenSpecifierAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token? = nil, unexpectedBetweenAssignTokenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeSpecifier = unexpectedBeforeSpecifier?.createUnexpectedNodes()
    self.specifier = specifier?.createTokenList()
    self.unexpectedBetweenSpecifierAndName = unexpectedBetweenSpecifierAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndAssignToken = unexpectedBetweenNameAndAssignToken?.createUnexpectedNodes()
    self.assignToken = assignToken
    assert(assignToken == nil || assignToken!.text == #"="#)
    self.unexpectedBetweenAssignTokenAndExpression = unexpectedBetweenAssignTokenAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndTrailingComma = unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: ExpressibleAsTokenList? = nil, unexpectedBetweenSpecifierAndName: ExpressibleAsUnexpectedNodes? = nil, name: String?, unexpectedBetweenNameAndAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token? = nil, unexpectedBetweenAssignTokenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSpecifier: unexpectedBeforeSpecifier, specifier: specifier, unexpectedBetweenSpecifierAndName: unexpectedBetweenSpecifierAndName, name: name.map {
      Token.`identifier`($0)
    }, unexpectedBetweenNameAndAssignToken: unexpectedBetweenNameAndAssignToken, assignToken: assignToken, unexpectedBetweenAssignTokenAndExpression: unexpectedBetweenAssignTokenAndExpression, expression: expression, unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `ClosureCaptureItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureCaptureItemSyntax`.
  func buildClosureCaptureItem(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClosureCaptureItemSyntax {
    let result = ClosureCaptureItemSyntax(unexpectedBeforeSpecifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), specifier: specifier?.buildTokenList(format: format, leadingTrivia: nil), unexpectedBetweenSpecifierAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name?.buildToken(), unexpectedBetweenNameAndAssignToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), assignToken: assignToken?.buildToken(), unexpectedBetweenAssignTokenAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildClosureCaptureItem(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureCaptureItem`.
  public func createClosureCaptureItem() -> ClosureCaptureItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureCaptureItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeSpecifier: unexpectedBeforeSpecifier, specifier: specifier, unexpectedBetweenSpecifierAndName: unexpectedBetweenSpecifierAndName, name: name, unexpectedBetweenNameAndAssignToken: unexpectedBetweenNameAndAssignToken, assignToken: assignToken, unexpectedBetweenAssignTokenAndExpression: unexpectedBetweenAssignTokenAndExpression, expression: expression, unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct ClosureCaptureSignature: SyntaxBuildable, ExpressibleAsClosureCaptureSignature {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftSquare: UnexpectedNodes?
  let leftSquare: Token
  let unexpectedBetweenLeftSquareAndItems: UnexpectedNodes?
  let items: ClosureCaptureItemList?
  let unexpectedBetweenItemsAndRightSquare: UnexpectedNodes?
  let rightSquare: Token
  /// Creates a `ClosureCaptureSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndItems: 
  ///   - items: 
  ///   - unexpectedBetweenItemsAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndItems: ExpressibleAsUnexpectedNodes? = nil, items: ExpressibleAsClosureCaptureItemList? = nil, unexpectedBetweenItemsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftSquare = unexpectedBeforeLeftSquare?.createUnexpectedNodes()
    self.leftSquare = leftSquare
    assert(leftSquare.text == #"["#)
    self.unexpectedBetweenLeftSquareAndItems = unexpectedBetweenLeftSquareAndItems?.createUnexpectedNodes()
    self.items = items?.createClosureCaptureItemList()
    self.unexpectedBetweenItemsAndRightSquare = unexpectedBetweenItemsAndRightSquare?.createUnexpectedNodes()
    self.rightSquare = rightSquare
    assert(rightSquare.text == #"]"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndItems: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenItemsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`, @ClosureCaptureItemListBuilder itemsBuilder: () -> ExpressibleAsClosureCaptureItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare, leftSquare: leftSquare, unexpectedBetweenLeftSquareAndItems: unexpectedBetweenLeftSquareAndItems, items: itemsBuilder(), unexpectedBetweenItemsAndRightSquare: unexpectedBetweenItemsAndRightSquare, rightSquare: rightSquare)
  }
  /// Builds a `ClosureCaptureSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureCaptureSignatureSyntax`.
  func buildClosureCaptureSignature(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClosureCaptureSignatureSyntax {
    let result = ClosureCaptureSignatureSyntax(unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftSquare: leftSquare.buildToken(), unexpectedBetweenLeftSquareAndItems?.buildUnexpectedNodes(format: format, leadingTrivia: nil), items: items?.buildClosureCaptureItemList(format: format, leadingTrivia: nil), unexpectedBetweenItemsAndRightSquare?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightSquare: rightSquare.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildClosureCaptureSignature(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureCaptureSignature`.
  public func createClosureCaptureSignature() -> ClosureCaptureSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureCaptureSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ClosureParam: SyntaxBuildable, ExpressibleAsClosureParam, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `ClosureParam` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingComma = unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `ClosureParamSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureParamSyntax`.
  func buildClosureParam(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClosureParamSyntax {
    let result = ClosureParamSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildClosureParam(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureParam`.
  public func createClosureParam() -> ClosureParam {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureParam` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeName: unexpectedBeforeName, name: name, unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct ClosureSignature: SyntaxBuildable, ExpressibleAsClosureSignature {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndCapture: UnexpectedNodes?
  let capture: ClosureCaptureSignature?
  let unexpectedBetweenCaptureAndInput: UnexpectedNodes?
  let input: SyntaxBuildable?
  let unexpectedBetweenInputAndAsyncKeyword: UnexpectedNodes?
  let asyncKeyword: Token?
  let unexpectedBetweenAsyncKeywordAndThrowsTok: UnexpectedNodes?
  let throwsTok: Token?
  let unexpectedBetweenThrowsTokAndOutput: UnexpectedNodes?
  let output: ReturnClause?
  let unexpectedBetweenOutputAndInTok: UnexpectedNodes?
  let inTok: Token
  /// Creates a `ClosureSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndCapture: 
  ///   - capture: 
  ///   - unexpectedBetweenCaptureAndInput: 
  ///   - input: 
  ///   - unexpectedBetweenInputAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsTok: 
  ///   - throwsTok: 
  ///   - unexpectedBetweenThrowsTokAndOutput: 
  ///   - output: 
  ///   - unexpectedBetweenOutputAndInTok: 
  ///   - inTok: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndCapture: ExpressibleAsUnexpectedNodes? = nil, capture: ExpressibleAsClosureCaptureSignature? = nil, unexpectedBetweenCaptureAndInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenInputAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsTok: ExpressibleAsUnexpectedNodes? = nil, throwsTok: Token? = nil, unexpectedBetweenThrowsTokAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil, unexpectedBetweenOutputAndInTok: ExpressibleAsUnexpectedNodes? = nil, inTok: Token = Token.`in`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndCapture = unexpectedBetweenAttributesAndCapture?.createUnexpectedNodes()
    self.capture = capture?.createClosureCaptureSignature()
    self.unexpectedBetweenCaptureAndInput = unexpectedBetweenCaptureAndInput?.createUnexpectedNodes()
    self.input = input?.createSyntaxBuildable()
    self.unexpectedBetweenInputAndAsyncKeyword = unexpectedBetweenInputAndAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsTok = unexpectedBetweenAsyncKeywordAndThrowsTok?.createUnexpectedNodes()
    self.throwsTok = throwsTok
    assert(throwsTok == nil || throwsTok!.text == #"throws"#)
    self.unexpectedBetweenThrowsTokAndOutput = unexpectedBetweenThrowsTokAndOutput?.createUnexpectedNodes()
    self.output = output?.createReturnClause()
    self.unexpectedBetweenOutputAndInTok = unexpectedBetweenOutputAndInTok?.createUnexpectedNodes()
    self.inTok = inTok
    assert(inTok.text == #"in"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndCapture: ExpressibleAsUnexpectedNodes? = nil, capture: ExpressibleAsClosureCaptureSignature? = nil, unexpectedBetweenCaptureAndInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenInputAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsTok: ExpressibleAsUnexpectedNodes? = nil, throwsTok: Token? = nil, unexpectedBetweenThrowsTokAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil, unexpectedBetweenOutputAndInTok: ExpressibleAsUnexpectedNodes? = nil, inTok: Token = Token.`in`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndCapture: unexpectedBetweenAttributesAndCapture, capture: capture, unexpectedBetweenCaptureAndInput: unexpectedBetweenCaptureAndInput, input: input, unexpectedBetweenInputAndAsyncKeyword: unexpectedBetweenInputAndAsyncKeyword, asyncKeyword: asyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncKeywordAndThrowsTok: unexpectedBetweenAsyncKeywordAndThrowsTok, throwsTok: throwsTok, unexpectedBetweenThrowsTokAndOutput: unexpectedBetweenThrowsTokAndOutput, output: output, unexpectedBetweenOutputAndInTok: unexpectedBetweenOutputAndInTok, inTok: inTok)
  }
  /// Builds a `ClosureSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureSignatureSyntax`.
  func buildClosureSignature(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClosureSignatureSyntax {
    let result = ClosureSignatureSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndCapture?.buildUnexpectedNodes(format: format, leadingTrivia: nil), capture: capture?.buildClosureCaptureSignature(format: format, leadingTrivia: nil), unexpectedBetweenCaptureAndInput?.buildUnexpectedNodes(format: format, leadingTrivia: nil), input: input?.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenInputAndAsyncKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asyncKeyword: asyncKeyword?.buildToken(), unexpectedBetweenAsyncKeywordAndThrowsTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), throwsTok: throwsTok?.buildToken(), unexpectedBetweenThrowsTokAndOutput?.buildUnexpectedNodes(format: format, leadingTrivia: nil), output: output?.buildReturnClause(format: format, leadingTrivia: nil), unexpectedBetweenOutputAndInTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inTok: inTok.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildClosureSignature(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureSignature`.
  public func createClosureSignature() -> ClosureSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ClosureExpr: ExprBuildable, ExpressibleAsClosureExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftBrace: UnexpectedNodes?
  let leftBrace: Token
  let unexpectedBetweenLeftBraceAndSignature: UnexpectedNodes?
  let signature: ClosureSignature?
  let unexpectedBetweenSignatureAndStatements: UnexpectedNodes?
  let statements: CodeBlockItemList
  let unexpectedBetweenStatementsAndRightBrace: UnexpectedNodes?
  let rightBrace: Token
  /// Creates a `ClosureExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsClosureSignature? = nil, unexpectedBetweenSignatureAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndSignature = unexpectedBetweenLeftBraceAndSignature?.createUnexpectedNodes()
    self.signature = signature?.createClosureSignature()
    self.unexpectedBetweenSignatureAndStatements = unexpectedBetweenSignatureAndStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
    self.unexpectedBetweenStatementsAndRightBrace = unexpectedBetweenStatementsAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsClosureSignature? = nil, unexpectedBetweenSignatureAndStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndSignature: unexpectedBetweenLeftBraceAndSignature, signature: signature, unexpectedBetweenSignatureAndStatements: unexpectedBetweenSignatureAndStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `ClosureExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureExprSyntax`.
  func buildClosureExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClosureExprSyntax {
    let result = ClosureExprSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBrace: leftBrace.buildToken(), unexpectedBetweenLeftBraceAndSignature?.buildUnexpectedNodes(format: format, leadingTrivia: nil), signature: signature?.buildClosureSignature(format: format, leadingTrivia: nil), unexpectedBetweenSignatureAndStatements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), statements: statements.buildCodeBlockItemList(format: format._indented(), leadingTrivia: nil), unexpectedBetweenStatementsAndRightBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBrace: rightBrace.buildToken().withLeadingTrivia(.newline + format._makeIndent() + (rightBrace.buildToken().leadingTrivia ?? [])))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildClosureExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsClosureExpr`.
  public func createClosureExpr() -> ClosureExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ClosureExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct UnresolvedPatternExpr: ExprBuildable, ExpressibleAsUnresolvedPatternExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePattern: UnexpectedNodes?
  let pattern: PatternBuildable
  /// Creates a `UnresolvedPatternExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
  }
  /// Builds a `UnresolvedPatternExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedPatternExprSyntax`.
  func buildUnresolvedPatternExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> UnresolvedPatternExprSyntax {
    let result = UnresolvedPatternExprSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildUnresolvedPatternExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedPatternExpr`.
  public func createUnresolvedPatternExpr() -> UnresolvedPatternExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedPatternExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MultipleTrailingClosureElement: SyntaxBuildable, ExpressibleAsMultipleTrailingClosureElement {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabel: UnexpectedNodes?
  let label: Token
  let unexpectedBetweenLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndClosure: UnexpectedNodes?
  let closure: ClosureExpr
  /// Creates a `MultipleTrailingClosureElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndClosure: 
  ///   - closure: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndClosure: ExpressibleAsUnexpectedNodes? = nil, closure: ExpressibleAsClosureExpr) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndClosure = unexpectedBetweenColonAndClosure?.createUnexpectedNodes()
    self.closure = closure.createClosureExpr()
  }
  /// Builds a `MultipleTrailingClosureElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MultipleTrailingClosureElementSyntax`.
  func buildMultipleTrailingClosureElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MultipleTrailingClosureElementSyntax {
    let result = MultipleTrailingClosureElementSyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label.buildToken(), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndClosure?.buildUnexpectedNodes(format: format, leadingTrivia: nil), closure: closure.buildClosureExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildMultipleTrailingClosureElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMultipleTrailingClosureElement`.
  public func createMultipleTrailingClosureElement() -> MultipleTrailingClosureElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MultipleTrailingClosureElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct FunctionCallExpr: ExprBuildable, ExpressibleAsFunctionCallExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeCalledExpression: UnexpectedNodes?
  let calledExpression: ExprBuildable
  let unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodes?
  let leftParen: Token?
  let unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodes?
  let argumentList: TupleExprElementList
  let unexpectedBetweenArgumentListAndRightParen: UnexpectedNodes?
  let rightParen: Token?
  let unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodes?
  let trailingClosure: ClosureExpr?
  let unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodes?
  let additionalTrailingClosures: MultipleTrailingClosureElementList?
  /// Creates a `FunctionCallExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCalledExpression: 
  ///   - calledExpression: 
  ///   - unexpectedBetweenCalledExpressionAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightParen: 
  ///   - rightParen: 
  ///   - unexpectedBetweenRightParenAndTrailingClosure: 
  ///   - trailingClosure: 
  ///   - unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: 
  ///   - additionalTrailingClosures: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeCalledExpression = unexpectedBeforeCalledExpression?.createUnexpectedNodes()
    self.calledExpression = calledExpression.createExprBuildable()
    self.unexpectedBetweenCalledExpressionAndLeftParen = unexpectedBetweenCalledExpressionAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgumentList = unexpectedBetweenLeftParenAndArgumentList?.createUnexpectedNodes()
    self.argumentList = argumentList.createTupleExprElementList()
    self.unexpectedBetweenArgumentListAndRightParen = unexpectedBetweenArgumentListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.unexpectedBetweenRightParenAndTrailingClosure = unexpectedBetweenRightParenAndTrailingClosure?.createUnexpectedNodes()
    self.trailingClosure = trailingClosure?.createClosureExpr()
    self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures = unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.createUnexpectedNodes()
    self.additionalTrailingClosures = additionalTrailingClosures?.createMultipleTrailingClosureElementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression, calledExpression: calledExpression, unexpectedBetweenCalledExpressionAndLeftParen: unexpectedBetweenCalledExpressionAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen, rightParen: rightParen, unexpectedBetweenRightParenAndTrailingClosure: unexpectedBetweenRightParenAndTrailingClosure, trailingClosure: trailingClosure, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, additionalTrailingClosures: additionalTrailingClosures)
  }
  /// Builds a `FunctionCallExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionCallExprSyntax`.
  func buildFunctionCallExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FunctionCallExprSyntax {
    let result = FunctionCallExprSyntax(unexpectedBeforeCalledExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), calledExpression: calledExpression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenCalledExpressionAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen?.buildToken(), unexpectedBetweenLeftParenAndArgumentList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), argumentList: argumentList.buildTupleExprElementList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentListAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen?.buildToken(), unexpectedBetweenRightParenAndTrailingClosure?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingClosure: trailingClosure?.buildClosureExpr(format: format, leadingTrivia: nil), unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.buildUnexpectedNodes(format: format, leadingTrivia: nil), additionalTrailingClosures: additionalTrailingClosures?.buildMultipleTrailingClosureElementList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildFunctionCallExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionCallExpr`.
  public func createFunctionCallExpr() -> FunctionCallExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `FunctionCallExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SubscriptExpr: ExprBuildable, ExpressibleAsSubscriptExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeCalledExpression: UnexpectedNodes?
  let calledExpression: ExprBuildable
  let unexpectedBetweenCalledExpressionAndLeftBracket: UnexpectedNodes?
  let leftBracket: Token
  let unexpectedBetweenLeftBracketAndArgumentList: UnexpectedNodes?
  let argumentList: TupleExprElementList
  let unexpectedBetweenArgumentListAndRightBracket: UnexpectedNodes?
  let rightBracket: Token
  let unexpectedBetweenRightBracketAndTrailingClosure: UnexpectedNodes?
  let trailingClosure: ClosureExpr?
  let unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodes?
  let additionalTrailingClosures: MultipleTrailingClosureElementList?
  /// Creates a `SubscriptExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCalledExpression: 
  ///   - calledExpression: 
  ///   - unexpectedBetweenCalledExpressionAndLeftBracket: 
  ///   - leftBracket: 
  ///   - unexpectedBetweenLeftBracketAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightBracket: 
  ///   - rightBracket: 
  ///   - unexpectedBetweenRightBracketAndTrailingClosure: 
  ///   - trailingClosure: 
  ///   - unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: 
  ///   - additionalTrailingClosures: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, unexpectedBetweenRightBracketAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeCalledExpression = unexpectedBeforeCalledExpression?.createUnexpectedNodes()
    self.calledExpression = calledExpression.createExprBuildable()
    self.unexpectedBetweenCalledExpressionAndLeftBracket = unexpectedBetweenCalledExpressionAndLeftBracket?.createUnexpectedNodes()
    self.leftBracket = leftBracket
    assert(leftBracket.text == #"["#)
    self.unexpectedBetweenLeftBracketAndArgumentList = unexpectedBetweenLeftBracketAndArgumentList?.createUnexpectedNodes()
    self.argumentList = argumentList.createTupleExprElementList()
    self.unexpectedBetweenArgumentListAndRightBracket = unexpectedBetweenArgumentListAndRightBracket?.createUnexpectedNodes()
    self.rightBracket = rightBracket
    assert(rightBracket.text == #"]"#)
    self.unexpectedBetweenRightBracketAndTrailingClosure = unexpectedBetweenRightBracketAndTrailingClosure?.createUnexpectedNodes()
    self.trailingClosure = trailingClosure?.createClosureExpr()
    self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures = unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.createUnexpectedNodes()
    self.additionalTrailingClosures = additionalTrailingClosures?.createMultipleTrailingClosureElementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, unexpectedBetweenRightBracketAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression, calledExpression: calledExpression, unexpectedBetweenCalledExpressionAndLeftBracket: unexpectedBetweenCalledExpressionAndLeftBracket, leftBracket: leftBracket, unexpectedBetweenLeftBracketAndArgumentList: unexpectedBetweenLeftBracketAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightBracket: unexpectedBetweenArgumentListAndRightBracket, rightBracket: rightBracket, unexpectedBetweenRightBracketAndTrailingClosure: unexpectedBetweenRightBracketAndTrailingClosure, trailingClosure: trailingClosure, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, additionalTrailingClosures: additionalTrailingClosures)
  }
  /// Builds a `SubscriptExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SubscriptExprSyntax`.
  func buildSubscriptExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SubscriptExprSyntax {
    let result = SubscriptExprSyntax(unexpectedBeforeCalledExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), calledExpression: calledExpression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenCalledExpressionAndLeftBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBracket: leftBracket.buildToken(), unexpectedBetweenLeftBracketAndArgumentList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), argumentList: argumentList.buildTupleExprElementList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentListAndRightBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBracket: rightBracket.buildToken(), unexpectedBetweenRightBracketAndTrailingClosure?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingClosure: trailingClosure?.buildClosureExpr(format: format, leadingTrivia: nil), unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.buildUnexpectedNodes(format: format, leadingTrivia: nil), additionalTrailingClosures: additionalTrailingClosures?.buildMultipleTrailingClosureElementList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildSubscriptExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSubscriptExpr`.
  public func createSubscriptExpr() -> SubscriptExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SubscriptExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct OptionalChainingExpr: ExprBuildable, ExpressibleAsOptionalChainingExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodes?
  let questionMark: Token
  /// Creates a `OptionalChainingExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndQuestionMark = unexpectedBetweenExpressionAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
  }
  /// Builds a `OptionalChainingExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalChainingExprSyntax`.
  func buildOptionalChainingExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> OptionalChainingExprSyntax {
    let result = OptionalChainingExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndQuestionMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionMark: questionMark.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildOptionalChainingExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalChainingExpr`.
  public func createOptionalChainingExpr() -> OptionalChainingExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `OptionalChainingExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ForcedValueExpr: ExprBuildable, ExpressibleAsForcedValueExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodes?
  let exclamationMark: Token
  /// Creates a `ForcedValueExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndExclamationMark: 
  ///   - exclamationMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndExclamationMark: ExpressibleAsUnexpectedNodes? = nil, exclamationMark: Token = Token.`exclamationMark`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndExclamationMark = unexpectedBetweenExpressionAndExclamationMark?.createUnexpectedNodes()
    self.exclamationMark = exclamationMark
    assert(exclamationMark.text == #"!"#)
  }
  /// Builds a `ForcedValueExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ForcedValueExprSyntax`.
  func buildForcedValueExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ForcedValueExprSyntax {
    let result = ForcedValueExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndExclamationMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), exclamationMark: exclamationMark.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildForcedValueExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsForcedValueExpr`.
  public func createForcedValueExpr() -> ForcedValueExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ForcedValueExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PostfixUnaryExpr: ExprBuildable, ExpressibleAsPostfixUnaryExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndOperatorToken: UnexpectedNodes?
  let operatorToken: Token
  /// Creates a `PostfixUnaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndOperatorToken: 
  ///   - operatorToken: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndOperatorToken = unexpectedBetweenExpressionAndOperatorToken?.createUnexpectedNodes()
    self.operatorToken = operatorToken
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression, expression: expression, unexpectedBetweenExpressionAndOperatorToken: unexpectedBetweenExpressionAndOperatorToken, operatorToken: Token.`postfixOperator`(operatorToken))
  }
  /// Builds a `PostfixUnaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PostfixUnaryExprSyntax`.
  func buildPostfixUnaryExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PostfixUnaryExprSyntax {
    let result = PostfixUnaryExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndOperatorToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), operatorToken: operatorToken.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPostfixUnaryExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPostfixUnaryExpr`.
  public func createPostfixUnaryExpr() -> PostfixUnaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PostfixUnaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SpecializeExpr: ExprBuildable, ExpressibleAsSpecializeExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodes?
  let genericArgumentClause: GenericArgumentClause
  /// Creates a `SpecializeExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndGenericArgumentClause = unexpectedBetweenExpressionAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause.createGenericArgumentClause()
  }
  /// Builds a `SpecializeExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SpecializeExprSyntax`.
  func buildSpecializeExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SpecializeExprSyntax {
    let result = SpecializeExprSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndGenericArgumentClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericArgumentClause: genericArgumentClause.buildGenericArgumentClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildSpecializeExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSpecializeExpr`.
  public func createSpecializeExpr() -> SpecializeExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SpecializeExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct StringSegment: SyntaxBuildable, ExpressibleAsStringSegment {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeContent: UnexpectedNodes?
  let content: Token
  /// Creates a `StringSegment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeContent: 
  ///   - content: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContent: ExpressibleAsUnexpectedNodes? = nil, content: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeContent = unexpectedBeforeContent?.createUnexpectedNodes()
    self.content = content
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContent: ExpressibleAsUnexpectedNodes? = nil, content: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeContent: unexpectedBeforeContent, content: Token.`stringSegment`(content))
  }
  /// Builds a `StringSegmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StringSegmentSyntax`.
  func buildStringSegment(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StringSegmentSyntax {
    let result = StringSegmentSyntax(unexpectedBeforeContent?.buildUnexpectedNodes(format: format, leadingTrivia: nil), content: content.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildStringSegment(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsStringSegment`.
  public func createStringSegment() -> StringSegment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StringSegment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ExpressionSegment: SyntaxBuildable, ExpressibleAsExpressionSegment {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBackslash: UnexpectedNodes?
  let backslash: Token
  let unexpectedBetweenBackslashAndDelimiter: UnexpectedNodes?
  let delimiter: Token?
  let unexpectedBetweenDelimiterAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndExpressions: UnexpectedNodes?
  let expressions: TupleExprElementList
  let unexpectedBetweenExpressionsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `ExpressionSegment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndDelimiter: 
  ///   - delimiter: 
  ///   - unexpectedBetweenDelimiterAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndExpressions: 
  ///   - expressions: 
  ///   - unexpectedBetweenExpressionsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndDelimiter: ExpressibleAsUnexpectedNodes? = nil, delimiter: Token? = nil, unexpectedBetweenDelimiterAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpressions: ExpressibleAsUnexpectedNodes? = nil, expressions: ExpressibleAsTupleExprElementList, unexpectedBetweenExpressionsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`stringInterpolationAnchor`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBackslash = unexpectedBeforeBackslash?.createUnexpectedNodes()
    self.backslash = backslash
    assert(backslash.text == #"\"#)
    self.unexpectedBetweenBackslashAndDelimiter = unexpectedBetweenBackslashAndDelimiter?.createUnexpectedNodes()
    self.delimiter = delimiter
    self.unexpectedBetweenDelimiterAndLeftParen = unexpectedBetweenDelimiterAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndExpressions = unexpectedBetweenLeftParenAndExpressions?.createUnexpectedNodes()
    self.expressions = expressions.createTupleExprElementList()
    self.unexpectedBetweenExpressionsAndRightParen = unexpectedBetweenExpressionsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndDelimiter: ExpressibleAsUnexpectedNodes? = nil, delimiter: String?, unexpectedBetweenDelimiterAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpressions: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenExpressionsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`stringInterpolationAnchor`, @TupleExprElementListBuilder expressionsBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBackslash: unexpectedBeforeBackslash, backslash: backslash, unexpectedBetweenBackslashAndDelimiter: unexpectedBetweenBackslashAndDelimiter, delimiter: delimiter.map {
      Token.`rawStringDelimiter`($0)
    }, unexpectedBetweenDelimiterAndLeftParen: unexpectedBetweenDelimiterAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndExpressions: unexpectedBetweenLeftParenAndExpressions, expressions: expressionsBuilder(), unexpectedBetweenExpressionsAndRightParen: unexpectedBetweenExpressionsAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ExpressionSegmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionSegmentSyntax`.
  func buildExpressionSegment(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExpressionSegmentSyntax {
    let result = ExpressionSegmentSyntax(unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format, leadingTrivia: nil), backslash: backslash.buildToken(), unexpectedBetweenBackslashAndDelimiter?.buildUnexpectedNodes(format: format, leadingTrivia: nil), delimiter: delimiter?.buildToken(), unexpectedBetweenDelimiterAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndExpressions?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expressions: expressions.buildTupleExprElementList(format: format, leadingTrivia: nil), unexpectedBetweenExpressionsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildExpressionSegment(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionSegment`.
  public func createExpressionSegment() -> ExpressionSegment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExpressionSegment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct StringLiteralExpr: ExprBuildable, ExpressibleAsStringLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeOpenDelimiter: UnexpectedNodes?
  let openDelimiter: Token?
  let unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodes?
  let openQuote: Token
  let unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodes?
  let segments: StringLiteralSegments
  let unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodes?
  let closeQuote: Token
  let unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodes?
  let closeDelimiter: Token?
  /// Creates a `StringLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOpenDelimiter: 
  ///   - openDelimiter: 
  ///   - unexpectedBetweenOpenDelimiterAndOpenQuote: 
  ///   - openQuote: 
  ///   - unexpectedBetweenOpenQuoteAndSegments: 
  ///   - segments: 
  ///   - unexpectedBetweenSegmentsAndCloseQuote: 
  ///   - closeQuote: 
  ///   - unexpectedBetweenCloseQuoteAndCloseDelimiter: 
  ///   - closeDelimiter: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOpenDelimiter: ExpressibleAsUnexpectedNodes? = nil, openDelimiter: Token? = nil, unexpectedBetweenOpenDelimiterAndOpenQuote: ExpressibleAsUnexpectedNodes? = nil, openQuote: Token, unexpectedBetweenOpenQuoteAndSegments: ExpressibleAsUnexpectedNodes? = nil, segments: ExpressibleAsStringLiteralSegments, unexpectedBetweenSegmentsAndCloseQuote: ExpressibleAsUnexpectedNodes? = nil, closeQuote: Token, unexpectedBetweenCloseQuoteAndCloseDelimiter: ExpressibleAsUnexpectedNodes? = nil, closeDelimiter: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeOpenDelimiter = unexpectedBeforeOpenDelimiter?.createUnexpectedNodes()
    self.openDelimiter = openDelimiter
    self.unexpectedBetweenOpenDelimiterAndOpenQuote = unexpectedBetweenOpenDelimiterAndOpenQuote?.createUnexpectedNodes()
    self.openQuote = openQuote
    assert(openQuote.text == #"""# || openQuote.text == #"""""#)
    self.unexpectedBetweenOpenQuoteAndSegments = unexpectedBetweenOpenQuoteAndSegments?.createUnexpectedNodes()
    self.segments = segments.createStringLiteralSegments()
    self.unexpectedBetweenSegmentsAndCloseQuote = unexpectedBetweenSegmentsAndCloseQuote?.createUnexpectedNodes()
    self.closeQuote = closeQuote
    assert(closeQuote.text == #"""# || closeQuote.text == #"""""#)
    self.unexpectedBetweenCloseQuoteAndCloseDelimiter = unexpectedBetweenCloseQuoteAndCloseDelimiter?.createUnexpectedNodes()
    self.closeDelimiter = closeDelimiter
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOpenDelimiter: ExpressibleAsUnexpectedNodes? = nil, openDelimiter: String?, unexpectedBetweenOpenDelimiterAndOpenQuote: ExpressibleAsUnexpectedNodes? = nil, openQuote: Token, unexpectedBetweenOpenQuoteAndSegments: ExpressibleAsUnexpectedNodes? = nil, segments: ExpressibleAsStringLiteralSegments, unexpectedBetweenSegmentsAndCloseQuote: ExpressibleAsUnexpectedNodes? = nil, closeQuote: Token, unexpectedBetweenCloseQuoteAndCloseDelimiter: ExpressibleAsUnexpectedNodes? = nil, closeDelimiter: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOpenDelimiter: unexpectedBeforeOpenDelimiter, openDelimiter: openDelimiter.map {
      Token.`rawStringDelimiter`($0)
    }, unexpectedBetweenOpenDelimiterAndOpenQuote: unexpectedBetweenOpenDelimiterAndOpenQuote, openQuote: openQuote, unexpectedBetweenOpenQuoteAndSegments: unexpectedBetweenOpenQuoteAndSegments, segments: segments, unexpectedBetweenSegmentsAndCloseQuote: unexpectedBetweenSegmentsAndCloseQuote, closeQuote: closeQuote, unexpectedBetweenCloseQuoteAndCloseDelimiter: unexpectedBetweenCloseQuoteAndCloseDelimiter, closeDelimiter: closeDelimiter.map {
      Token.`rawStringDelimiter`($0)
    })
  }
  /// Builds a `StringLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StringLiteralExprSyntax`.
  func buildStringLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StringLiteralExprSyntax {
    let result = StringLiteralExprSyntax(unexpectedBeforeOpenDelimiter?.buildUnexpectedNodes(format: format, leadingTrivia: nil), openDelimiter: openDelimiter?.buildToken(), unexpectedBetweenOpenDelimiterAndOpenQuote?.buildUnexpectedNodes(format: format, leadingTrivia: nil), openQuote: openQuote.buildToken(), unexpectedBetweenOpenQuoteAndSegments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), segments: segments.buildStringLiteralSegments(format: format, leadingTrivia: nil), unexpectedBetweenSegmentsAndCloseQuote?.buildUnexpectedNodes(format: format, leadingTrivia: nil), closeQuote: closeQuote.buildToken(), unexpectedBetweenCloseQuoteAndCloseDelimiter?.buildUnexpectedNodes(format: format, leadingTrivia: nil), closeDelimiter: closeDelimiter?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildStringLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsStringLiteralExpr`.
  public func createStringLiteralExpr() -> StringLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `StringLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct RegexLiteralExpr: ExprBuildable, ExpressibleAsRegexLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeRegex: UnexpectedNodes?
  let regex: Token
  /// Creates a `RegexLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeRegex: 
  ///   - regex: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRegex: ExpressibleAsUnexpectedNodes? = nil, regex: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeRegex = unexpectedBeforeRegex?.createUnexpectedNodes()
    self.regex = regex
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRegex: ExpressibleAsUnexpectedNodes? = nil, regex: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeRegex: unexpectedBeforeRegex, regex: Token.`regexLiteral`(regex))
  }
  /// Builds a `RegexLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `RegexLiteralExprSyntax`.
  func buildRegexLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> RegexLiteralExprSyntax {
    let result = RegexLiteralExprSyntax(unexpectedBeforeRegex?.buildUnexpectedNodes(format: format, leadingTrivia: nil), regex: regex.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildRegexLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsRegexLiteralExpr`.
  public func createRegexLiteralExpr() -> RegexLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `RegexLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct KeyPathExpr: ExprBuildable, ExpressibleAsKeyPathExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBackslash: UnexpectedNodes?
  let backslash: Token
  let unexpectedBetweenBackslashAndRootExpr: UnexpectedNodes?
  let rootExpr: ExprBuildable?
  let unexpectedBetweenRootExprAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `KeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndRootExpr: 
  ///   - rootExpr: 
  ///   - unexpectedBetweenRootExprAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndRootExpr: ExpressibleAsUnexpectedNodes? = nil, rootExpr: ExpressibleAsExprBuildable? = nil, unexpectedBetweenRootExprAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBackslash = unexpectedBeforeBackslash?.createUnexpectedNodes()
    self.backslash = backslash
    assert(backslash.text == #"\"#)
    self.unexpectedBetweenBackslashAndRootExpr = unexpectedBetweenBackslashAndRootExpr?.createUnexpectedNodes()
    self.rootExpr = rootExpr?.createExprBuildable()
    self.unexpectedBetweenRootExprAndExpression = unexpectedBetweenRootExprAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `KeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathExprSyntax`.
  func buildKeyPathExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> KeyPathExprSyntax {
    let result = KeyPathExprSyntax(unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format, leadingTrivia: nil), backslash: backslash.buildToken(), unexpectedBetweenBackslashAndRootExpr?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rootExpr: rootExpr?.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenRootExprAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildKeyPathExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathExpr`.
  public func createKeyPathExpr() -> KeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `KeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct KeyPathBaseExpr: ExprBuildable, ExpressibleAsKeyPathBaseExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePeriod: UnexpectedNodes?
  let period: Token
  /// Creates a `KeyPathBaseExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePeriod: 
  ///   - period: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePeriod = unexpectedBeforePeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."#)
  }
  /// Builds a `KeyPathBaseExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathBaseExprSyntax`.
  func buildKeyPathBaseExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> KeyPathBaseExprSyntax {
    let result = KeyPathBaseExprSyntax(unexpectedBeforePeriod?.buildUnexpectedNodes(format: format, leadingTrivia: nil), period: period.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildKeyPathBaseExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathBaseExpr`.
  public func createKeyPathBaseExpr() -> KeyPathBaseExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `KeyPathBaseExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ObjcNamePiece: SyntaxBuildable, ExpressibleAsObjcNamePiece {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndDot: UnexpectedNodes?
  let dot: Token?
  /// Creates a `ObjcNamePiece` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDot: 
  ///   - dot: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndDot = unexpectedBetweenNameAndDot?.createUnexpectedNodes()
    self.dot = dot
    assert(dot == nil || dot!.text == #"."#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndDot: unexpectedBetweenNameAndDot, dot: dot)
  }
  /// Builds a `ObjcNamePieceSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcNamePieceSyntax`.
  func buildObjcNamePiece(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ObjcNamePieceSyntax {
    let result = ObjcNamePieceSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndDot?.buildUnexpectedNodes(format: format, leadingTrivia: nil), dot: dot?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildObjcNamePiece(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsObjcNamePiece`.
  public func createObjcNamePiece() -> ObjcNamePiece {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ObjcNamePiece` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ObjcKeyPathExpr: ExprBuildable, ExpressibleAsObjcKeyPathExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeKeyPath: UnexpectedNodes?
  let keyPath: Token
  let unexpectedBetweenKeyPathAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndName: UnexpectedNodes?
  let name: ObjcName
  let unexpectedBetweenNameAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `ObjcKeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeKeyPath: 
  ///   - keyPath: 
  ///   - unexpectedBetweenKeyPathAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeKeyPath: ExpressibleAsUnexpectedNodes? = nil, keyPath: Token = Token.`poundKeyPath`, unexpectedBetweenKeyPathAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsObjcName, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeKeyPath = unexpectedBeforeKeyPath?.createUnexpectedNodes()
    self.keyPath = keyPath
    assert(keyPath.text == #"#keyPath"#)
    self.unexpectedBetweenKeyPathAndLeftParen = unexpectedBetweenKeyPathAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndName = unexpectedBetweenLeftParenAndName?.createUnexpectedNodes()
    self.name = name.createObjcName()
    self.unexpectedBetweenNameAndRightParen = unexpectedBetweenNameAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `ObjcKeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcKeyPathExprSyntax`.
  func buildObjcKeyPathExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ObjcKeyPathExprSyntax {
    let result = ObjcKeyPathExprSyntax(unexpectedBeforeKeyPath?.buildUnexpectedNodes(format: format, leadingTrivia: nil), keyPath: keyPath.buildToken(), unexpectedBetweenKeyPathAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildObjcName(format: format, leadingTrivia: nil), unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildObjcKeyPathExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjcKeyPathExpr`.
  public func createObjcKeyPathExpr() -> ObjcKeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjcKeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ObjcSelectorExpr: ExprBuildable, ExpressibleAsObjcSelectorExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundSelector: UnexpectedNodes?
  let poundSelector: Token
  let unexpectedBetweenPoundSelectorAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndKind: UnexpectedNodes?
  let kind: Token?
  let unexpectedBetweenKindAndColon: UnexpectedNodes?
  let colon: Token?
  let unexpectedBetweenColonAndName: UnexpectedNodes?
  let name: ExprBuildable
  let unexpectedBetweenNameAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `ObjcSelectorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundSelector: 
  ///   - poundSelector: 
  ///   - unexpectedBetweenPoundSelectorAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndKind: 
  ///   - kind: 
  ///   - unexpectedBetweenKindAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundSelector: ExpressibleAsUnexpectedNodes? = nil, poundSelector: Token = Token.`poundSelector`, unexpectedBetweenPoundSelectorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndKind: ExpressibleAsUnexpectedNodes? = nil, kind: Token? = nil, unexpectedBetweenKindAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsExprBuildable, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundSelector = unexpectedBeforePoundSelector?.createUnexpectedNodes()
    self.poundSelector = poundSelector
    assert(poundSelector.text == #"#selector"#)
    self.unexpectedBetweenPoundSelectorAndLeftParen = unexpectedBetweenPoundSelectorAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndKind = unexpectedBetweenLeftParenAndKind?.createUnexpectedNodes()
    self.kind = kind
    assert(kind == nil || kind!.text == #"getter"# || kind!.text == #"setter"#)
    self.unexpectedBetweenKindAndColon = unexpectedBetweenKindAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndName = unexpectedBetweenColonAndName?.createUnexpectedNodes()
    self.name = name.createExprBuildable()
    self.unexpectedBetweenNameAndRightParen = unexpectedBetweenNameAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundSelector: ExpressibleAsUnexpectedNodes? = nil, poundSelector: Token = Token.`poundSelector`, unexpectedBetweenPoundSelectorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndKind: ExpressibleAsUnexpectedNodes? = nil, kind: String?, unexpectedBetweenKindAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsExprBuildable, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePoundSelector: unexpectedBeforePoundSelector, poundSelector: poundSelector, unexpectedBetweenPoundSelectorAndLeftParen: unexpectedBetweenPoundSelectorAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndKind: unexpectedBetweenLeftParenAndKind, kind: kind.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenKindAndColon: unexpectedBetweenKindAndColon, colon: colon, unexpectedBetweenColonAndName: unexpectedBetweenColonAndName, name: name, unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ObjcSelectorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcSelectorExprSyntax`.
  func buildObjcSelectorExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ObjcSelectorExprSyntax {
    let result = ObjcSelectorExprSyntax(unexpectedBeforePoundSelector?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundSelector: poundSelector.buildToken(), unexpectedBetweenPoundSelectorAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndKind?.buildUnexpectedNodes(format: format, leadingTrivia: nil), kind: kind?.buildToken(), unexpectedBetweenKindAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon?.buildToken(), unexpectedBetweenColonAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildObjcSelectorExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjcSelectorExpr`.
  public func createObjcSelectorExpr() -> ObjcSelectorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjcSelectorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PostfixIfConfigExpr: ExprBuildable, ExpressibleAsPostfixIfConfigExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBase: UnexpectedNodes?
  let base: ExprBuildable?
  let unexpectedBetweenBaseAndConfig: UnexpectedNodes?
  let config: IfConfigDecl
  /// Creates a `PostfixIfConfigExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBase: 
  ///   - base: 
  ///   - unexpectedBetweenBaseAndConfig: 
  ///   - config: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBase: ExpressibleAsUnexpectedNodes? = nil, base: ExpressibleAsExprBuildable? = nil, unexpectedBetweenBaseAndConfig: ExpressibleAsUnexpectedNodes? = nil, config: ExpressibleAsIfConfigDecl) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBase = unexpectedBeforeBase?.createUnexpectedNodes()
    self.base = base?.createExprBuildable()
    self.unexpectedBetweenBaseAndConfig = unexpectedBetweenBaseAndConfig?.createUnexpectedNodes()
    self.config = config.createIfConfigDecl()
  }
  /// Builds a `PostfixIfConfigExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PostfixIfConfigExprSyntax`.
  func buildPostfixIfConfigExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PostfixIfConfigExprSyntax {
    let result = PostfixIfConfigExprSyntax(unexpectedBeforeBase?.buildUnexpectedNodes(format: format, leadingTrivia: nil), base: base?.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenBaseAndConfig?.buildUnexpectedNodes(format: format, leadingTrivia: nil), config: config.buildIfConfigDecl(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildPostfixIfConfigExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPostfixIfConfigExpr`.
  public func createPostfixIfConfigExpr() -> PostfixIfConfigExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PostfixIfConfigExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct EditorPlaceholderExpr: ExprBuildable, ExpressibleAsEditorPlaceholderExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIdentifier: UnexpectedNodes?
  let identifier: Token
  /// Creates a `EditorPlaceholderExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier))
  }
  /// Builds a `EditorPlaceholderExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EditorPlaceholderExprSyntax`.
  func buildEditorPlaceholderExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> EditorPlaceholderExprSyntax {
    let result = EditorPlaceholderExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildEditorPlaceholderExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsEditorPlaceholderExpr`.
  public func createEditorPlaceholderExpr() -> EditorPlaceholderExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `EditorPlaceholderExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ObjectLiteralExpr: ExprBuildable, ExpressibleAsObjectLiteralExpr {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
  let arguments: TupleExprElementList
  let unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `ObjectLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    assert(identifier.text == #"#colorLiteral"# || identifier.text == #"#fileLiteral"# || identifier.text == #"#imageLiteral"#)
    self.unexpectedBetweenIdentifierAndLeftParen = unexpectedBetweenIdentifierAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArguments = unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createTupleExprElementList()
    self.unexpectedBetweenArgumentsAndRightParen = unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TupleExprElementListBuilder argumentsBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndLeftParen: unexpectedBetweenIdentifierAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArguments: unexpectedBetweenLeftParenAndArguments, arguments: argumentsBuilder(), unexpectedBetweenArgumentsAndRightParen: unexpectedBetweenArgumentsAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ObjectLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjectLiteralExprSyntax`.
  func buildObjectLiteralExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ObjectLiteralExprSyntax {
    let result = ObjectLiteralExprSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arguments: arguments.buildTupleExprElementList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExprSyntax {
    let result = buildObjectLiteralExpr(format: format, leadingTrivia: additionalLeadingTrivia)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjectLiteralExpr`.
  public func createObjectLiteralExpr() -> ObjectLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjectLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TypeInitializerClause: SyntaxBuildable, ExpressibleAsTypeInitializerClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeEqual: UnexpectedNodes?
  let equal: Token
  let unexpectedBetweenEqualAndValue: UnexpectedNodes?
  let value: TypeBuildable
  /// Creates a `TypeInitializerClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEqual: 
  ///   - equal: 
  ///   - unexpectedBetweenEqualAndValue: 
  ///   - value: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeEqual: ExpressibleAsUnexpectedNodes? = nil, equal: Token = Token.`equal`, unexpectedBetweenEqualAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeEqual = unexpectedBeforeEqual?.createUnexpectedNodes()
    self.equal = equal
    assert(equal.text == #"="#)
    self.unexpectedBetweenEqualAndValue = unexpectedBetweenEqualAndValue?.createUnexpectedNodes()
    self.value = value.createTypeBuildable()
  }
  /// Builds a `TypeInitializerClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeInitializerClauseSyntax`.
  func buildTypeInitializerClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeInitializerClauseSyntax {
    let result = TypeInitializerClauseSyntax(unexpectedBeforeEqual?.buildUnexpectedNodes(format: format, leadingTrivia: nil), equal: equal.buildToken(), unexpectedBetweenEqualAndValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), value: value.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTypeInitializerClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeInitializerClause`.
  public func createTypeInitializerClause() -> TypeInitializerClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeInitializerClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TypealiasDecl: DeclBuildable, ExpressibleAsTypealiasDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodes?
  let typealiasKeyword: Token
  let unexpectedBetweenTypealiasKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodes?
  let initializer: TypeInitializerClause
  let unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  /// Creates a `TypealiasDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndTypealiasKeyword: 
  ///   - typealiasKeyword: 
  ///   - unexpectedBetweenTypealiasKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndGenericWhereClause: 
  ///   - genericWhereClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndTypealiasKeyword: ExpressibleAsUnexpectedNodes? = nil, typealiasKeyword: Token = Token.`typealias`, unexpectedBetweenTypealiasKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndTypealiasKeyword = unexpectedBetweenModifiersAndTypealiasKeyword?.createUnexpectedNodes()
    self.typealiasKeyword = typealiasKeyword
    assert(typealiasKeyword.text == #"typealias"#)
    self.unexpectedBetweenTypealiasKeywordAndIdentifier = unexpectedBetweenTypealiasKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInitializer = unexpectedBetweenGenericParameterClauseAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer.createTypeInitializerClause()
    self.unexpectedBetweenInitializerAndGenericWhereClause = unexpectedBetweenInitializerAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndTypealiasKeyword: ExpressibleAsUnexpectedNodes? = nil, typealiasKeyword: Token = Token.`typealias`, unexpectedBetweenTypealiasKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndTypealiasKeyword: unexpectedBetweenModifiersAndTypealiasKeyword, typealiasKeyword: typealiasKeyword, unexpectedBetweenTypealiasKeywordAndIdentifier: unexpectedBetweenTypealiasKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInitializer: unexpectedBetweenGenericParameterClauseAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause, genericWhereClause: genericWhereClause)
  }
  /// Builds a `TypealiasDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypealiasDeclSyntax`.
  func buildTypealiasDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypealiasDeclSyntax {
    let result = TypealiasDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndTypealiasKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typealiasKeyword: typealiasKeyword.buildToken(), unexpectedBetweenTypealiasKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndInitializer?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initializer: initializer.buildTypeInitializerClause(format: format, leadingTrivia: nil), unexpectedBetweenInitializerAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildTypealiasDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsTypealiasDecl`.
  public func createTypealiasDecl() -> TypealiasDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `TypealiasDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AssociatedtypeDecl: DeclBuildable, ExpressibleAsAssociatedtypeDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndAssociatedtypeKeyword: UnexpectedNodes?
  let associatedtypeKeyword: Token
  let unexpectedBetweenAssociatedtypeKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndInitializer: UnexpectedNodes?
  let initializer: TypeInitializerClause?
  let unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  /// Creates a `AssociatedtypeDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndAssociatedtypeKeyword: 
  ///   - associatedtypeKeyword: 
  ///   - unexpectedBetweenAssociatedtypeKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndGenericWhereClause: 
  ///   - genericWhereClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndAssociatedtypeKeyword: ExpressibleAsUnexpectedNodes? = nil, associatedtypeKeyword: Token = Token.`associatedtype`, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause? = nil, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndAssociatedtypeKeyword = unexpectedBetweenModifiersAndAssociatedtypeKeyword?.createUnexpectedNodes()
    self.associatedtypeKeyword = associatedtypeKeyword
    assert(associatedtypeKeyword.text == #"associatedtype"#)
    self.unexpectedBetweenAssociatedtypeKeywordAndIdentifier = unexpectedBetweenAssociatedtypeKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndInheritanceClause = unexpectedBetweenIdentifierAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndInitializer = unexpectedBetweenInheritanceClauseAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createTypeInitializerClause()
    self.unexpectedBetweenInitializerAndGenericWhereClause = unexpectedBetweenInitializerAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndAssociatedtypeKeyword: ExpressibleAsUnexpectedNodes? = nil, associatedtypeKeyword: Token = Token.`associatedtype`, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause? = nil, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndAssociatedtypeKeyword: unexpectedBetweenModifiersAndAssociatedtypeKeyword, associatedtypeKeyword: associatedtypeKeyword, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: unexpectedBetweenAssociatedtypeKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndInheritanceClause: unexpectedBetweenIdentifierAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndInitializer: unexpectedBetweenInheritanceClauseAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause, genericWhereClause: genericWhereClause)
  }
  /// Builds a `AssociatedtypeDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AssociatedtypeDeclSyntax`.
  func buildAssociatedtypeDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AssociatedtypeDeclSyntax {
    let result = AssociatedtypeDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndAssociatedtypeKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), associatedtypeKeyword: associatedtypeKeyword.buildToken(), unexpectedBetweenAssociatedtypeKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndInitializer?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initializer: initializer?.buildTypeInitializerClause(format: format, leadingTrivia: nil), unexpectedBetweenInitializerAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildAssociatedtypeDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsAssociatedtypeDecl`.
  public func createAssociatedtypeDecl() -> AssociatedtypeDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `AssociatedtypeDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ParameterClause: SyntaxBuildable, ExpressibleAsParameterClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndParameterList: UnexpectedNodes?
  let parameterList: FunctionParameterList
  let unexpectedBetweenParameterListAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `ParameterClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndParameterList: 
  ///   - parameterList: 
  ///   - unexpectedBetweenParameterListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndParameterList: ExpressibleAsUnexpectedNodes? = nil, parameterList: ExpressibleAsFunctionParameterList, unexpectedBetweenParameterListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndParameterList = unexpectedBetweenLeftParenAndParameterList?.createUnexpectedNodes()
    self.parameterList = parameterList.createFunctionParameterList()
    self.unexpectedBetweenParameterListAndRightParen = unexpectedBetweenParameterListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndParameterList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenParameterListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @FunctionParameterListBuilder parameterListBuilder: () -> ExpressibleAsFunctionParameterList =  {
    FunctionParameterList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndParameterList: unexpectedBetweenLeftParenAndParameterList, parameterList: parameterListBuilder(), unexpectedBetweenParameterListAndRightParen: unexpectedBetweenParameterListAndRightParen, rightParen: rightParen)
  }
  /// Builds a `ParameterClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ParameterClauseSyntax`.
  func buildParameterClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ParameterClauseSyntax {
    let result = ParameterClauseSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndParameterList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), parameterList: parameterList.buildFunctionParameterList(format: format, leadingTrivia: nil), unexpectedBetweenParameterListAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildParameterClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsParameterClause`.
  public func createParameterClause() -> ParameterClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ParameterClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ReturnClause: SyntaxBuildable, ExpressibleAsReturnClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeArrow: UnexpectedNodes?
  let arrow: Token
  let unexpectedBetweenArrowAndReturnType: UnexpectedNodes?
  let returnType: TypeBuildable
  /// Creates a `ReturnClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeArrow: 
  ///   - arrow: 
  ///   - unexpectedBetweenArrowAndReturnType: 
  ///   - returnType: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeArrow: ExpressibleAsUnexpectedNodes? = nil, arrow: Token = Token.`arrow`, unexpectedBetweenArrowAndReturnType: ExpressibleAsUnexpectedNodes? = nil, returnType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeArrow = unexpectedBeforeArrow?.createUnexpectedNodes()
    self.arrow = arrow
    assert(arrow.text == #"->"#)
    self.unexpectedBetweenArrowAndReturnType = unexpectedBetweenArrowAndReturnType?.createUnexpectedNodes()
    self.returnType = returnType.createTypeBuildable()
  }
  /// Builds a `ReturnClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ReturnClauseSyntax`.
  func buildReturnClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ReturnClauseSyntax {
    let result = ReturnClauseSyntax(unexpectedBeforeArrow?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arrow: arrow.buildToken(), unexpectedBetweenArrowAndReturnType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), returnType: returnType.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildReturnClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsReturnClause`.
  public func createReturnClause() -> ReturnClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ReturnClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct FunctionSignature: SyntaxBuildable, ExpressibleAsFunctionSignature {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeInput: UnexpectedNodes?
  let input: ParameterClause
  let unexpectedBetweenInputAndAsyncOrReasyncKeyword: UnexpectedNodes?
  let asyncOrReasyncKeyword: Token?
  let unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: UnexpectedNodes?
  let throwsOrRethrowsKeyword: Token?
  let unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: UnexpectedNodes?
  let output: ReturnClause?
  /// Creates a `FunctionSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeInput: 
  ///   - input: 
  ///   - unexpectedBetweenInputAndAsyncOrReasyncKeyword: 
  ///   - asyncOrReasyncKeyword: 
  ///   - unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: 
  ///   - throwsOrRethrowsKeyword: 
  ///   - unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: 
  ///   - output: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsParameterClause, unexpectedBetweenInputAndAsyncOrReasyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncOrReasyncKeyword: Token? = nil, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeInput = unexpectedBeforeInput?.createUnexpectedNodes()
    self.input = input.createParameterClause()
    self.unexpectedBetweenInputAndAsyncOrReasyncKeyword = unexpectedBetweenInputAndAsyncOrReasyncKeyword?.createUnexpectedNodes()
    self.asyncOrReasyncKeyword = asyncOrReasyncKeyword
    assert(asyncOrReasyncKeyword == nil || asyncOrReasyncKeyword!.text == #"async"# || asyncOrReasyncKeyword!.text == #"reasync"#)
    self.unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword = unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword?.createUnexpectedNodes()
    self.throwsOrRethrowsKeyword = throwsOrRethrowsKeyword
    assert(throwsOrRethrowsKeyword == nil || throwsOrRethrowsKeyword!.text == #"throws"# || throwsOrRethrowsKeyword!.text == #"rethrows"#)
    self.unexpectedBetweenThrowsOrRethrowsKeywordAndOutput = unexpectedBetweenThrowsOrRethrowsKeywordAndOutput?.createUnexpectedNodes()
    self.output = output?.createReturnClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsParameterClause, unexpectedBetweenInputAndAsyncOrReasyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncOrReasyncKeyword: String?, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeInput: unexpectedBeforeInput, input: input, unexpectedBetweenInputAndAsyncOrReasyncKeyword: unexpectedBetweenInputAndAsyncOrReasyncKeyword, asyncOrReasyncKeyword: asyncOrReasyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword, throwsOrRethrowsKeyword: throwsOrRethrowsKeyword, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: unexpectedBetweenThrowsOrRethrowsKeywordAndOutput, output: output)
  }
  /// Builds a `FunctionSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionSignatureSyntax`.
  func buildFunctionSignature(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FunctionSignatureSyntax {
    let result = FunctionSignatureSyntax(unexpectedBeforeInput?.buildUnexpectedNodes(format: format, leadingTrivia: nil), input: input.buildParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenInputAndAsyncOrReasyncKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asyncOrReasyncKeyword: asyncOrReasyncKeyword?.buildToken(), unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), throwsOrRethrowsKeyword: throwsOrRethrowsKeyword?.buildToken(), unexpectedBetweenThrowsOrRethrowsKeywordAndOutput?.buildUnexpectedNodes(format: format, leadingTrivia: nil), output: output?.buildReturnClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildFunctionSignature(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionSignature`.
  public func createFunctionSignature() -> FunctionSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IfConfigClause: SyntaxBuildable, ExpressibleAsIfConfigClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundKeyword: UnexpectedNodes?
  let poundKeyword: Token
  let unexpectedBetweenPoundKeywordAndCondition: UnexpectedNodes?
  let condition: ExprBuildable?
  let unexpectedBetweenConditionAndElements: UnexpectedNodes?
  let elements: SyntaxBuildable
  /// Creates a `IfConfigClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundKeyword: 
  ///   - poundKeyword: 
  ///   - unexpectedBetweenPoundKeywordAndCondition: 
  ///   - condition: 
  ///   - unexpectedBetweenConditionAndElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundKeyword: ExpressibleAsUnexpectedNodes? = nil, poundKeyword: Token, unexpectedBetweenPoundKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable? = nil, unexpectedBetweenConditionAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundKeyword = unexpectedBeforePoundKeyword?.createUnexpectedNodes()
    self.poundKeyword = poundKeyword
    assert(poundKeyword.text == #"#if"# || poundKeyword.text == #"#elseif"# || poundKeyword.text == #"#else"#)
    self.unexpectedBetweenPoundKeywordAndCondition = unexpectedBetweenPoundKeywordAndCondition?.createUnexpectedNodes()
    self.condition = condition?.createExprBuildable()
    self.unexpectedBetweenConditionAndElements = unexpectedBetweenConditionAndElements?.createUnexpectedNodes()
    self.elements = elements.createSyntaxBuildable()
  }
  /// Builds a `IfConfigClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfConfigClauseSyntax`.
  func buildIfConfigClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IfConfigClauseSyntax {
    let result = IfConfigClauseSyntax(unexpectedBeforePoundKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundKeyword: poundKeyword.buildToken(), unexpectedBetweenPoundKeywordAndCondition?.buildUnexpectedNodes(format: format, leadingTrivia: nil), condition: condition?.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenConditionAndElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildIfConfigClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsIfConfigClause`.
  public func createIfConfigClause() -> IfConfigClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `IfConfigClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IfConfigDecl: DeclBuildable, ExpressibleAsIfConfigDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeClauses: UnexpectedNodes?
  let clauses: IfConfigClauseList
  let unexpectedBetweenClausesAndPoundEndif: UnexpectedNodes?
  let poundEndif: Token
  /// Creates a `IfConfigDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeClauses: 
  ///   - clauses: 
  ///   - unexpectedBetweenClausesAndPoundEndif: 
  ///   - poundEndif: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeClauses: ExpressibleAsUnexpectedNodes? = nil, clauses: ExpressibleAsIfConfigClauseList, unexpectedBetweenClausesAndPoundEndif: ExpressibleAsUnexpectedNodes? = nil, poundEndif: Token = Token.`poundEndif`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeClauses = unexpectedBeforeClauses?.createUnexpectedNodes()
    self.clauses = clauses.createIfConfigClauseList()
    self.unexpectedBetweenClausesAndPoundEndif = unexpectedBetweenClausesAndPoundEndif?.createUnexpectedNodes()
    self.poundEndif = poundEndif
    assert(poundEndif.text == #"#endif"#)
  }
  /// Builds a `IfConfigDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfConfigDeclSyntax`.
  func buildIfConfigDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IfConfigDeclSyntax {
    let result = IfConfigDeclSyntax(unexpectedBeforeClauses?.buildUnexpectedNodes(format: format, leadingTrivia: nil), clauses: clauses.buildIfConfigClauseList(format: format, leadingTrivia: nil), unexpectedBetweenClausesAndPoundEndif?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundEndif: poundEndif.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildIfConfigDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsIfConfigDecl`.
  public func createIfConfigDecl() -> IfConfigDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `IfConfigDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundErrorDecl: DeclBuildable, ExpressibleAsPoundErrorDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundError: UnexpectedNodes?
  let poundError: Token
  let unexpectedBetweenPoundErrorAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndMessage: UnexpectedNodes?
  let message: StringLiteralExpr
  let unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `PoundErrorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundError: 
  ///   - poundError: 
  ///   - unexpectedBetweenPoundErrorAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndMessage: 
  ///   - message: 
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundError: ExpressibleAsUnexpectedNodes? = nil, poundError: Token = Token.`poundError`, unexpectedBetweenPoundErrorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: ExpressibleAsStringLiteralExpr, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundError = unexpectedBeforePoundError?.createUnexpectedNodes()
    self.poundError = poundError
    assert(poundError.text == #"#error"#)
    self.unexpectedBetweenPoundErrorAndLeftParen = unexpectedBetweenPoundErrorAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndMessage = unexpectedBetweenLeftParenAndMessage?.createUnexpectedNodes()
    self.message = message.createStringLiteralExpr()
    self.unexpectedBetweenMessageAndRightParen = unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `PoundErrorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundErrorDeclSyntax`.
  func buildPoundErrorDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundErrorDeclSyntax {
    let result = PoundErrorDeclSyntax(unexpectedBeforePoundError?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundError: poundError.buildToken(), unexpectedBetweenPoundErrorAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndMessage?.buildUnexpectedNodes(format: format, leadingTrivia: nil), message: message.buildStringLiteralExpr(format: format, leadingTrivia: nil), unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildPoundErrorDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundErrorDecl`.
  public func createPoundErrorDecl() -> PoundErrorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundErrorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundWarningDecl: DeclBuildable, ExpressibleAsPoundWarningDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundWarning: UnexpectedNodes?
  let poundWarning: Token
  let unexpectedBetweenPoundWarningAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndMessage: UnexpectedNodes?
  let message: StringLiteralExpr
  let unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `PoundWarningDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundWarning: 
  ///   - poundWarning: 
  ///   - unexpectedBetweenPoundWarningAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndMessage: 
  ///   - message: 
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundWarning: ExpressibleAsUnexpectedNodes? = nil, poundWarning: Token = Token.`poundWarning`, unexpectedBetweenPoundWarningAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: ExpressibleAsStringLiteralExpr, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundWarning = unexpectedBeforePoundWarning?.createUnexpectedNodes()
    self.poundWarning = poundWarning
    assert(poundWarning.text == #"#warning"#)
    self.unexpectedBetweenPoundWarningAndLeftParen = unexpectedBetweenPoundWarningAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndMessage = unexpectedBetweenLeftParenAndMessage?.createUnexpectedNodes()
    self.message = message.createStringLiteralExpr()
    self.unexpectedBetweenMessageAndRightParen = unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `PoundWarningDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundWarningDeclSyntax`.
  func buildPoundWarningDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundWarningDeclSyntax {
    let result = PoundWarningDeclSyntax(unexpectedBeforePoundWarning?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundWarning: poundWarning.buildToken(), unexpectedBetweenPoundWarningAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndMessage?.buildUnexpectedNodes(format: format, leadingTrivia: nil), message: message.buildStringLiteralExpr(format: format, leadingTrivia: nil), unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildPoundWarningDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundWarningDecl`.
  public func createPoundWarningDecl() -> PoundWarningDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundWarningDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundSourceLocation: DeclBuildable, ExpressibleAsPoundSourceLocation {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundSourceLocation: UnexpectedNodes?
  let poundSourceLocation: Token
  let unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndArgs: UnexpectedNodes?
  let args: PoundSourceLocationArgs?
  let unexpectedBetweenArgsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `PoundSourceLocation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundSourceLocation: 
  ///   - poundSourceLocation: 
  ///   - unexpectedBetweenPoundSourceLocationAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgs: 
  ///   - args: 
  ///   - unexpectedBetweenArgsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundSourceLocation: ExpressibleAsUnexpectedNodes? = nil, poundSourceLocation: Token = Token.`poundSourceLocation`, unexpectedBetweenPoundSourceLocationAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArgs: ExpressibleAsUnexpectedNodes? = nil, args: ExpressibleAsPoundSourceLocationArgs? = nil, unexpectedBetweenArgsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundSourceLocation = unexpectedBeforePoundSourceLocation?.createUnexpectedNodes()
    self.poundSourceLocation = poundSourceLocation
    assert(poundSourceLocation.text == #"#sourceLocation"#)
    self.unexpectedBetweenPoundSourceLocationAndLeftParen = unexpectedBetweenPoundSourceLocationAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgs = unexpectedBetweenLeftParenAndArgs?.createUnexpectedNodes()
    self.args = args?.createPoundSourceLocationArgs()
    self.unexpectedBetweenArgsAndRightParen = unexpectedBetweenArgsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `PoundSourceLocationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundSourceLocationSyntax`.
  func buildPoundSourceLocation(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundSourceLocationSyntax {
    let result = PoundSourceLocationSyntax(unexpectedBeforePoundSourceLocation?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundSourceLocation: poundSourceLocation.buildToken(), unexpectedBetweenPoundSourceLocationAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndArgs?.buildUnexpectedNodes(format: format, leadingTrivia: nil), args: args?.buildPoundSourceLocationArgs(format: format, leadingTrivia: nil), unexpectedBetweenArgsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildPoundSourceLocation(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundSourceLocation`.
  public func createPoundSourceLocation() -> PoundSourceLocation {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundSourceLocation` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundSourceLocationArgs: SyntaxBuildable, ExpressibleAsPoundSourceLocationArgs {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeFileArgLabel: UnexpectedNodes?
  let fileArgLabel: Token
  let unexpectedBetweenFileArgLabelAndFileArgColon: UnexpectedNodes?
  let fileArgColon: Token
  let unexpectedBetweenFileArgColonAndFileName: UnexpectedNodes?
  let fileName: Token
  let unexpectedBetweenFileNameAndComma: UnexpectedNodes?
  let comma: Token
  let unexpectedBetweenCommaAndLineArgLabel: UnexpectedNodes?
  let lineArgLabel: Token
  let unexpectedBetweenLineArgLabelAndLineArgColon: UnexpectedNodes?
  let lineArgColon: Token
  let unexpectedBetweenLineArgColonAndLineNumber: UnexpectedNodes?
  let lineNumber: Token
  /// Creates a `PoundSourceLocationArgs` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFileArgLabel: 
  ///   - fileArgLabel: 
  ///   - unexpectedBetweenFileArgLabelAndFileArgColon: 
  ///   - fileArgColon: 
  ///   - unexpectedBetweenFileArgColonAndFileName: 
  ///   - fileName: 
  ///   - unexpectedBetweenFileNameAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndLineArgLabel: 
  ///   - lineArgLabel: 
  ///   - unexpectedBetweenLineArgLabelAndLineArgColon: 
  ///   - lineArgColon: 
  ///   - unexpectedBetweenLineArgColonAndLineNumber: 
  ///   - lineNumber: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFileArgLabel: ExpressibleAsUnexpectedNodes? = nil, fileArgLabel: Token, unexpectedBetweenFileArgLabelAndFileArgColon: ExpressibleAsUnexpectedNodes? = nil, fileArgColon: Token = Token.`colon`, unexpectedBetweenFileArgColonAndFileName: ExpressibleAsUnexpectedNodes? = nil, fileName: Token, unexpectedBetweenFileNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndLineArgLabel: ExpressibleAsUnexpectedNodes? = nil, lineArgLabel: Token, unexpectedBetweenLineArgLabelAndLineArgColon: ExpressibleAsUnexpectedNodes? = nil, lineArgColon: Token = Token.`colon`, unexpectedBetweenLineArgColonAndLineNumber: ExpressibleAsUnexpectedNodes? = nil, lineNumber: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeFileArgLabel = unexpectedBeforeFileArgLabel?.createUnexpectedNodes()
    self.fileArgLabel = fileArgLabel
    assert(fileArgLabel.text == #"file"#)
    self.unexpectedBetweenFileArgLabelAndFileArgColon = unexpectedBetweenFileArgLabelAndFileArgColon?.createUnexpectedNodes()
    self.fileArgColon = fileArgColon
    assert(fileArgColon.text == #":"#)
    self.unexpectedBetweenFileArgColonAndFileName = unexpectedBetweenFileArgColonAndFileName?.createUnexpectedNodes()
    self.fileName = fileName
    self.unexpectedBetweenFileNameAndComma = unexpectedBetweenFileNameAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma.text == #","#)
    self.unexpectedBetweenCommaAndLineArgLabel = unexpectedBetweenCommaAndLineArgLabel?.createUnexpectedNodes()
    self.lineArgLabel = lineArgLabel
    assert(lineArgLabel.text == #"line"#)
    self.unexpectedBetweenLineArgLabelAndLineArgColon = unexpectedBetweenLineArgLabelAndLineArgColon?.createUnexpectedNodes()
    self.lineArgColon = lineArgColon
    assert(lineArgColon.text == #":"#)
    self.unexpectedBetweenLineArgColonAndLineNumber = unexpectedBetweenLineArgColonAndLineNumber?.createUnexpectedNodes()
    self.lineNumber = lineNumber
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFileArgLabel: ExpressibleAsUnexpectedNodes? = nil, fileArgLabel: String, unexpectedBetweenFileArgLabelAndFileArgColon: ExpressibleAsUnexpectedNodes? = nil, fileArgColon: Token = Token.`colon`, unexpectedBetweenFileArgColonAndFileName: ExpressibleAsUnexpectedNodes? = nil, fileName: String, unexpectedBetweenFileNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndLineArgLabel: ExpressibleAsUnexpectedNodes? = nil, lineArgLabel: String, unexpectedBetweenLineArgLabelAndLineArgColon: ExpressibleAsUnexpectedNodes? = nil, lineArgColon: Token = Token.`colon`, unexpectedBetweenLineArgColonAndLineNumber: ExpressibleAsUnexpectedNodes? = nil, lineNumber: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeFileArgLabel: unexpectedBeforeFileArgLabel, fileArgLabel: Token.`identifier`(fileArgLabel), unexpectedBetweenFileArgLabelAndFileArgColon: unexpectedBetweenFileArgLabelAndFileArgColon, fileArgColon: fileArgColon, unexpectedBetweenFileArgColonAndFileName: unexpectedBetweenFileArgColonAndFileName, fileName: Token.`stringLiteral`(fileName), unexpectedBetweenFileNameAndComma: unexpectedBetweenFileNameAndComma, comma: comma, unexpectedBetweenCommaAndLineArgLabel: unexpectedBetweenCommaAndLineArgLabel, lineArgLabel: Token.`identifier`(lineArgLabel), unexpectedBetweenLineArgLabelAndLineArgColon: unexpectedBetweenLineArgLabelAndLineArgColon, lineArgColon: lineArgColon, unexpectedBetweenLineArgColonAndLineNumber: unexpectedBetweenLineArgColonAndLineNumber, lineNumber: Token.`integerLiteral`(lineNumber))
  }
  /// Builds a `PoundSourceLocationArgsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundSourceLocationArgsSyntax`.
  func buildPoundSourceLocationArgs(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundSourceLocationArgsSyntax {
    let result = PoundSourceLocationArgsSyntax(unexpectedBeforeFileArgLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), fileArgLabel: fileArgLabel.buildToken(), unexpectedBetweenFileArgLabelAndFileArgColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), fileArgColon: fileArgColon.buildToken(), unexpectedBetweenFileArgColonAndFileName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), fileName: fileName.buildToken(), unexpectedBetweenFileNameAndComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), comma: comma.buildToken(), unexpectedBetweenCommaAndLineArgLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), lineArgLabel: lineArgLabel.buildToken(), unexpectedBetweenLineArgLabelAndLineArgColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), lineArgColon: lineArgColon.buildToken(), unexpectedBetweenLineArgColonAndLineNumber?.buildUnexpectedNodes(format: format, leadingTrivia: nil), lineNumber: lineNumber.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPoundSourceLocationArgs(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPoundSourceLocationArgs`.
  public func createPoundSourceLocationArgs() -> PoundSourceLocationArgs {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PoundSourceLocationArgs` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeclModifierDetail: SyntaxBuildable, ExpressibleAsDeclModifierDetail {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndDetail: UnexpectedNodes?
  let detail: Token
  let unexpectedBetweenDetailAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `DeclModifierDetail` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndDetail: 
  ///   - detail: 
  ///   - unexpectedBetweenDetailAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: Token, unexpectedBetweenDetailAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndDetail = unexpectedBetweenLeftParenAndDetail?.createUnexpectedNodes()
    self.detail = detail
    self.unexpectedBetweenDetailAndRightParen = unexpectedBetweenDetailAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: String, unexpectedBetweenDetailAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndDetail: unexpectedBetweenLeftParenAndDetail, detail: Token.`identifier`(detail), unexpectedBetweenDetailAndRightParen: unexpectedBetweenDetailAndRightParen, rightParen: rightParen)
  }
  /// Builds a `DeclModifierDetailSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclModifierDetailSyntax`.
  func buildDeclModifierDetail(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclModifierDetailSyntax {
    let result = DeclModifierDetailSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndDetail?.buildUnexpectedNodes(format: format, leadingTrivia: nil), detail: detail.buildToken(), unexpectedBetweenDetailAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDeclModifierDetail(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclModifierDetail`.
  public func createDeclModifierDetail() -> DeclModifierDetail {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclModifierDetail` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeclModifier: SyntaxBuildable, ExpressibleAsDeclModifier {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndDetail: UnexpectedNodes?
  let detail: DeclModifierDetail?
  /// Creates a `DeclModifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDetail: 
  ///   - detail: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: ExpressibleAsDeclModifierDetail? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    assert(name.text == #"class"# || name.text == #"convenience"# || name.text == #"dynamic"# || name.text == #"final"# || name.text == #"infix"# || name.text == #"lazy"# || name.text == #"optional"# || name.text == #"override"# || name.text == #"postfix"# || name.text == #"prefix"# || name.text == #"required"# || name.text == #"static"# || name.text == #"unowned"# || name.text == #"weak"# || name.text == #"private"# || name.text == #"fileprivate"# || name.text == #"internal"# || name.text == #"public"# || name.text == #"open"# || name.text == #"mutating"# || name.text == #"nonmutating"# || name.text == #"indirect"# || name.text == #"__consuming"# || name.text == #"actor"# || name.text == #"async"# || name.text == #"distributed"# || name.text == #"isolated"# || name.text == #"nonisolated"# || name.text == #"_const"# || name.text == #"_local"#)
    self.unexpectedBetweenNameAndDetail = unexpectedBetweenNameAndDetail?.createUnexpectedNodes()
    self.detail = detail?.createDeclModifierDetail()
  }
  /// Builds a `DeclModifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclModifierSyntax`.
  func buildDeclModifier(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclModifierSyntax {
    let result = DeclModifierSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndDetail?.buildUnexpectedNodes(format: format, leadingTrivia: nil), detail: detail?.buildDeclModifierDetail(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDeclModifier(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclModifier`.
  public func createDeclModifier() -> DeclModifier {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclModifier` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct InheritedType: SyntaxBuildable, ExpressibleAsInheritedType, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeTypeName: UnexpectedNodes?
  let typeName: TypeBuildable
  let unexpectedBetweenTypeNameAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `InheritedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTypeName: 
  ///   - typeName: 
  ///   - unexpectedBetweenTypeNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable, unexpectedBetweenTypeNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeTypeName = unexpectedBeforeTypeName?.createUnexpectedNodes()
    self.typeName = typeName.createTypeBuildable()
    self.unexpectedBetweenTypeNameAndTrailingComma = unexpectedBetweenTypeNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `InheritedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InheritedTypeSyntax`.
  func buildInheritedType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> InheritedTypeSyntax {
    let result = InheritedTypeSyntax(unexpectedBeforeTypeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeName: typeName.buildType(format: format, leadingTrivia: nil), unexpectedBetweenTypeNameAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildInheritedType(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsInheritedType`.
  public func createInheritedType() -> InheritedType {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `InheritedType` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeTypeName: unexpectedBeforeTypeName, typeName: typeName, unexpectedBetweenTypeNameAndTrailingComma: unexpectedBetweenTypeNameAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct TypeInheritanceClause: SyntaxBuildable, ExpressibleAsTypeInheritanceClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndInheritedTypeCollection: UnexpectedNodes?
  let inheritedTypeCollection: InheritedTypeList
  /// Creates a `TypeInheritanceClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndInheritedTypeCollection: 
  ///   - inheritedTypeCollection: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndInheritedTypeCollection: ExpressibleAsUnexpectedNodes? = nil, inheritedTypeCollection: ExpressibleAsInheritedTypeList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeColon = unexpectedBeforeColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndInheritedTypeCollection = unexpectedBetweenColonAndInheritedTypeCollection?.createUnexpectedNodes()
    self.inheritedTypeCollection = inheritedTypeCollection.createInheritedTypeList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndInheritedTypeCollection: ExpressibleAsUnexpectedNodes? = nil, @InheritedTypeListBuilder inheritedTypeCollectionBuilder: () -> ExpressibleAsInheritedTypeList =  {
    InheritedTypeList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeColon: unexpectedBeforeColon, colon: colon, unexpectedBetweenColonAndInheritedTypeCollection: unexpectedBetweenColonAndInheritedTypeCollection, inheritedTypeCollection: inheritedTypeCollectionBuilder())
  }
  /// Builds a `TypeInheritanceClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeInheritanceClauseSyntax`.
  func buildTypeInheritanceClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeInheritanceClauseSyntax {
    let result = TypeInheritanceClauseSyntax(unexpectedBeforeColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndInheritedTypeCollection?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritedTypeCollection: inheritedTypeCollection.buildInheritedTypeList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTypeInheritanceClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeInheritanceClause`.
  public func createTypeInheritanceClause() -> TypeInheritanceClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeInheritanceClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ClassDecl: DeclBuildable, ExpressibleAsClassDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodes?
  let classKeyword: Token
  let unexpectedBetweenClassKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  let members: MemberDeclBlock
  /// Creates a `ClassDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndClassKeyword: 
  ///   - classKeyword: 
  ///   - unexpectedBetweenClassKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`, unexpectedBetweenClassKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndClassKeyword = unexpectedBetweenModifiersAndClassKeyword?.createUnexpectedNodes()
    self.classKeyword = classKeyword
    assert(classKeyword.text == #"class"#)
    self.unexpectedBetweenClassKeywordAndIdentifier = unexpectedBetweenClassKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInheritanceClause = unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`, unexpectedBetweenClassKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndClassKeyword: unexpectedBetweenModifiersAndClassKeyword, classKeyword: classKeyword, unexpectedBetweenClassKeywordAndIdentifier: unexpectedBetweenClassKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ClassDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClassDeclSyntax`.
  func buildClassDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClassDeclSyntax {
    let result = ClassDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndClassKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), classKeyword: classKeyword.buildToken(), unexpectedBetweenClassKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildClassDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsClassDecl`.
  public func createClassDecl() -> ClassDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ClassDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ActorDecl: DeclBuildable, ExpressibleAsActorDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndActorKeyword: UnexpectedNodes?
  let actorKeyword: Token
  let unexpectedBetweenActorKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  let members: MemberDeclBlock
  /// Creates a `ActorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndActorKeyword: 
  ///   - actorKeyword: 
  ///   - unexpectedBetweenActorKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndActorKeyword: ExpressibleAsUnexpectedNodes? = nil, actorKeyword: Token, unexpectedBetweenActorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndActorKeyword = unexpectedBetweenModifiersAndActorKeyword?.createUnexpectedNodes()
    self.actorKeyword = actorKeyword
    assert(actorKeyword.text == #"actor"#)
    self.unexpectedBetweenActorKeywordAndIdentifier = unexpectedBetweenActorKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInheritanceClause = unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndActorKeyword: ExpressibleAsUnexpectedNodes? = nil, actorKeyword: String, unexpectedBetweenActorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndActorKeyword: unexpectedBetweenModifiersAndActorKeyword, actorKeyword: Token.`contextualKeyword`(actorKeyword), unexpectedBetweenActorKeywordAndIdentifier: unexpectedBetweenActorKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ActorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ActorDeclSyntax`.
  func buildActorDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ActorDeclSyntax {
    let result = ActorDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndActorKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), actorKeyword: actorKeyword.buildToken(), unexpectedBetweenActorKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildActorDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsActorDecl`.
  public func createActorDecl() -> ActorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ActorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct StructDecl: DeclBuildable, ExpressibleAsStructDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndStructKeyword: UnexpectedNodes?
  let structKeyword: Token
  let unexpectedBetweenStructKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  let members: MemberDeclBlock
  /// Creates a `StructDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndStructKeyword: 
  ///   - structKeyword: 
  ///   - unexpectedBetweenStructKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndStructKeyword: ExpressibleAsUnexpectedNodes? = nil, structKeyword: Token = Token.`struct`, unexpectedBetweenStructKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndStructKeyword = unexpectedBetweenModifiersAndStructKeyword?.createUnexpectedNodes()
    self.structKeyword = structKeyword
    assert(structKeyword.text == #"struct"#)
    self.unexpectedBetweenStructKeywordAndIdentifier = unexpectedBetweenStructKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndInheritanceClause = unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndStructKeyword: ExpressibleAsUnexpectedNodes? = nil, structKeyword: Token = Token.`struct`, unexpectedBetweenStructKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndStructKeyword: unexpectedBetweenModifiersAndStructKeyword, structKeyword: structKeyword, unexpectedBetweenStructKeywordAndIdentifier: unexpectedBetweenStructKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `StructDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StructDeclSyntax`.
  func buildStructDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StructDeclSyntax {
    let result = StructDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndStructKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), structKeyword: structKeyword.buildToken(), unexpectedBetweenStructKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildStructDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsStructDecl`.
  public func createStructDecl() -> StructDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `StructDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ProtocolDecl: DeclBuildable, ExpressibleAsProtocolDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodes?
  let protocolKeyword: Token
  let unexpectedBetweenProtocolKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: UnexpectedNodes?
  let primaryAssociatedTypeClause: PrimaryAssociatedTypeClause?
  let unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  let members: MemberDeclBlock
  /// Creates a `ProtocolDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndProtocolKeyword: 
  ///   - protocolKeyword: 
  ///   - unexpectedBetweenProtocolKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: 
  ///   - primaryAssociatedTypeClause: 
  ///   - unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndProtocolKeyword: ExpressibleAsUnexpectedNodes? = nil, protocolKeyword: Token = Token.`protocol`, unexpectedBetweenProtocolKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeClause: ExpressibleAsPrimaryAssociatedTypeClause? = nil, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndProtocolKeyword = unexpectedBetweenModifiersAndProtocolKeyword?.createUnexpectedNodes()
    self.protocolKeyword = protocolKeyword
    assert(protocolKeyword.text == #"protocol"#)
    self.unexpectedBetweenProtocolKeywordAndIdentifier = unexpectedBetweenProtocolKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause = unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause?.createUnexpectedNodes()
    self.primaryAssociatedTypeClause = primaryAssociatedTypeClause?.createPrimaryAssociatedTypeClause()
    self.unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause = unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndProtocolKeyword: ExpressibleAsUnexpectedNodes? = nil, protocolKeyword: Token = Token.`protocol`, unexpectedBetweenProtocolKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeClause: ExpressibleAsPrimaryAssociatedTypeClause? = nil, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndProtocolKeyword: unexpectedBetweenModifiersAndProtocolKeyword, protocolKeyword: protocolKeyword, unexpectedBetweenProtocolKeywordAndIdentifier: unexpectedBetweenProtocolKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause, primaryAssociatedTypeClause: primaryAssociatedTypeClause, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ProtocolDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ProtocolDeclSyntax`.
  func buildProtocolDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ProtocolDeclSyntax {
    let result = ProtocolDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndProtocolKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), protocolKeyword: protocolKeyword.buildToken(), unexpectedBetweenProtocolKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), primaryAssociatedTypeClause: primaryAssociatedTypeClause?.buildPrimaryAssociatedTypeClause(format: format, leadingTrivia: nil), unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildProtocolDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsProtocolDecl`.
  public func createProtocolDecl() -> ProtocolDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ProtocolDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ExtensionDecl: DeclBuildable, ExpressibleAsExtensionDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodes?
  let extensionKeyword: Token
  let unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodes?
  let extendedType: TypeBuildable
  let unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  let members: MemberDeclBlock
  /// Creates a `ExtensionDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndExtensionKeyword: 
  ///   - extensionKeyword: 
  ///   - unexpectedBetweenExtensionKeywordAndExtendedType: 
  ///   - extendedType: 
  ///   - unexpectedBetweenExtendedTypeAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndExtensionKeyword: ExpressibleAsUnexpectedNodes? = nil, extensionKeyword: Token = Token.`extension`, unexpectedBetweenExtensionKeywordAndExtendedType: ExpressibleAsUnexpectedNodes? = nil, extendedType: ExpressibleAsTypeBuildable, unexpectedBetweenExtendedTypeAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndExtensionKeyword = unexpectedBetweenModifiersAndExtensionKeyword?.createUnexpectedNodes()
    self.extensionKeyword = extensionKeyword
    assert(extensionKeyword.text == #"extension"#)
    self.unexpectedBetweenExtensionKeywordAndExtendedType = unexpectedBetweenExtensionKeywordAndExtendedType?.createUnexpectedNodes()
    self.extendedType = extendedType.createTypeBuildable()
    self.unexpectedBetweenExtendedTypeAndInheritanceClause = unexpectedBetweenExtendedTypeAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndExtensionKeyword: ExpressibleAsUnexpectedNodes? = nil, extensionKeyword: Token = Token.`extension`, unexpectedBetweenExtensionKeywordAndExtendedType: ExpressibleAsUnexpectedNodes? = nil, extendedType: ExpressibleAsTypeBuildable, unexpectedBetweenExtendedTypeAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndExtensionKeyword: unexpectedBetweenModifiersAndExtensionKeyword, extensionKeyword: extensionKeyword, unexpectedBetweenExtensionKeywordAndExtendedType: unexpectedBetweenExtensionKeywordAndExtendedType, extendedType: extendedType, unexpectedBetweenExtendedTypeAndInheritanceClause: unexpectedBetweenExtendedTypeAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `ExtensionDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExtensionDeclSyntax`.
  func buildExtensionDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExtensionDeclSyntax {
    let result = ExtensionDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndExtensionKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), extensionKeyword: extensionKeyword.buildToken(), unexpectedBetweenExtensionKeywordAndExtendedType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), extendedType: extendedType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenExtendedTypeAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildExtensionDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsExtensionDecl`.
  public func createExtensionDecl() -> ExtensionDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ExtensionDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MemberDeclBlock: SyntaxBuildable, ExpressibleAsMemberDeclBlock {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftBrace: UnexpectedNodes?
  let leftBrace: Token
  let unexpectedBetweenLeftBraceAndMembers: UnexpectedNodes?
  let members: MemberDeclList
  let unexpectedBetweenMembersAndRightBrace: UnexpectedNodes?
  let rightBrace: Token
  /// Creates a `MemberDeclBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndMembers: 
  ///   - members: 
  ///   - unexpectedBetweenMembersAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclList, unexpectedBetweenMembersAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndMembers = unexpectedBetweenLeftBraceAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclList()
    self.unexpectedBetweenMembersAndRightBrace = unexpectedBetweenMembersAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndMembers: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenMembersAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndMembers: unexpectedBetweenLeftBraceAndMembers, members: membersBuilder(), unexpectedBetweenMembersAndRightBrace: unexpectedBetweenMembersAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `MemberDeclBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberDeclBlockSyntax`.
  func buildMemberDeclBlock(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MemberDeclBlockSyntax {
    let result = MemberDeclBlockSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBrace: leftBrace.buildToken(), unexpectedBetweenLeftBraceAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclList(format: format._indented(), leadingTrivia: nil), unexpectedBetweenMembersAndRightBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBrace: rightBrace.buildToken().withLeadingTrivia(.newline + format._makeIndent() + (rightBrace.buildToken().leadingTrivia ?? [])))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildMemberDeclBlock(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMemberDeclBlock`.
  public func createMemberDeclBlock() -> MemberDeclBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MemberDeclBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A member declaration of a type consisting of a declaration and anoptional semicolon;
public struct MemberDeclListItem: SyntaxBuildable, ExpressibleAsMemberDeclListItem {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDecl: UnexpectedNodes?
  let decl: DeclBuildable
  let unexpectedBetweenDeclAndSemicolon: UnexpectedNodes?
  let semicolon: Token?
  /// Creates a `MemberDeclListItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDecl: 
  ///   - decl: The declaration of the type member.
  ///   - unexpectedBetweenDeclAndSemicolon: 
  ///   - semicolon: An optional trailing semicolon.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDecl: ExpressibleAsUnexpectedNodes? = nil, decl: ExpressibleAsDeclBuildable, unexpectedBetweenDeclAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDecl = unexpectedBeforeDecl?.createUnexpectedNodes()
    self.decl = decl.createDeclBuildable()
    self.unexpectedBetweenDeclAndSemicolon = unexpectedBetweenDeclAndSemicolon?.createUnexpectedNodes()
    self.semicolon = semicolon
    assert(semicolon == nil || semicolon!.text == #";"#)
  }
  /// Builds a `MemberDeclListItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberDeclListItemSyntax`.
  func buildMemberDeclListItem(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MemberDeclListItemSyntax {
    let result = MemberDeclListItemSyntax(unexpectedBeforeDecl?.buildUnexpectedNodes(format: format, leadingTrivia: nil), decl: decl.buildDecl(format: format, leadingTrivia: nil), unexpectedBetweenDeclAndSemicolon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), semicolon: semicolon?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildMemberDeclListItem(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMemberDeclListItem`.
  public func createMemberDeclListItem() -> MemberDeclListItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MemberDeclListItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SourceFile: SyntaxBuildable, ExpressibleAsSourceFile {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeStatements: UnexpectedNodes?
  let statements: CodeBlockItemList
  let unexpectedBetweenStatementsAndEOFToken: UnexpectedNodes?
  let eofToken: Token
  /// Creates a `SourceFile` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndEOFToken: 
  ///   - eofToken: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndEOFToken: ExpressibleAsUnexpectedNodes? = nil, eofToken: Token = Token.eof) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeStatements = unexpectedBeforeStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
    self.unexpectedBetweenStatementsAndEOFToken = unexpectedBetweenStatementsAndEOFToken?.createUnexpectedNodes()
    self.eofToken = eofToken
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndEOFToken: ExpressibleAsUnexpectedNodes? = nil, eofToken: Token = Token.eof, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeStatements: unexpectedBeforeStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndEOFToken: unexpectedBetweenStatementsAndEOFToken, eofToken: eofToken)
  }
  /// Builds a `SourceFileSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SourceFileSyntax`.
  func buildSourceFile(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SourceFileSyntax {
    let result = SourceFileSyntax(unexpectedBeforeStatements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), statements: statements.buildCodeBlockItemList(format: format, leadingTrivia: nil), unexpectedBetweenStatementsAndEOFToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), eofToken: eofToken.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildSourceFile(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSourceFile`.
  public func createSourceFile() -> SourceFile {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SourceFile` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct InitializerClause: SyntaxBuildable, ExpressibleAsInitializerClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeEqual: UnexpectedNodes?
  let equal: Token
  let unexpectedBetweenEqualAndValue: UnexpectedNodes?
  let value: ExprBuildable
  /// Creates a `InitializerClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEqual: 
  ///   - equal: 
  ///   - unexpectedBetweenEqualAndValue: 
  ///   - value: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeEqual: ExpressibleAsUnexpectedNodes? = nil, equal: Token = Token.`equal`, unexpectedBetweenEqualAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeEqual = unexpectedBeforeEqual?.createUnexpectedNodes()
    self.equal = equal
    assert(equal.text == #"="#)
    self.unexpectedBetweenEqualAndValue = unexpectedBetweenEqualAndValue?.createUnexpectedNodes()
    self.value = value.createExprBuildable()
  }
  /// Builds a `InitializerClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InitializerClauseSyntax`.
  func buildInitializerClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> InitializerClauseSyntax {
    let result = InitializerClauseSyntax(unexpectedBeforeEqual?.buildUnexpectedNodes(format: format, leadingTrivia: nil), equal: equal.buildToken(), unexpectedBetweenEqualAndValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), value: value.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildInitializerClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsInitializerClause`.
  public func createInitializerClause() -> InitializerClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `InitializerClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct FunctionParameter: SyntaxBuildable, ExpressibleAsFunctionParameter, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndFirstName: UnexpectedNodes?
  let firstName: Token?
  let unexpectedBetweenFirstNameAndSecondName: UnexpectedNodes?
  let secondName: Token?
  let unexpectedBetweenSecondNameAndColon: UnexpectedNodes?
  let colon: Token?
  let unexpectedBetweenColonAndType: UnexpectedNodes?
  let type: TypeBuildable?
  let unexpectedBetweenTypeAndEllipsis: UnexpectedNodes?
  let ellipsis: Token?
  let unexpectedBetweenEllipsisAndDefaultArgument: UnexpectedNodes?
  let defaultArgument: InitializerClause?
  let unexpectedBetweenDefaultArgumentAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `FunctionParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndFirstName: 
  ///   - firstName: 
  ///   - unexpectedBetweenFirstNameAndSecondName: 
  ///   - secondName: 
  ///   - unexpectedBetweenSecondNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndEllipsis: 
  ///   - ellipsis: 
  ///   - unexpectedBetweenEllipsisAndDefaultArgument: 
  ///   - defaultArgument: 
  ///   - unexpectedBetweenDefaultArgumentAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndFirstName: ExpressibleAsUnexpectedNodes? = nil, firstName: Token? = nil, unexpectedBetweenFirstNameAndSecondName: ExpressibleAsUnexpectedNodes? = nil, secondName: Token? = nil, unexpectedBetweenSecondNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token? = nil, unexpectedBetweenEllipsisAndDefaultArgument: ExpressibleAsUnexpectedNodes? = nil, defaultArgument: ExpressibleAsInitializerClause? = nil, unexpectedBetweenDefaultArgumentAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndFirstName = unexpectedBetweenAttributesAndFirstName?.createUnexpectedNodes()
    self.firstName = firstName
    self.unexpectedBetweenFirstNameAndSecondName = unexpectedBetweenFirstNameAndSecondName?.createUnexpectedNodes()
    self.secondName = secondName
    self.unexpectedBetweenSecondNameAndColon = unexpectedBetweenSecondNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndType = unexpectedBetweenColonAndType?.createUnexpectedNodes()
    self.type = type?.createTypeBuildable()
    self.unexpectedBetweenTypeAndEllipsis = unexpectedBetweenTypeAndEllipsis?.createUnexpectedNodes()
    self.ellipsis = ellipsis
    assert(ellipsis == nil || ellipsis!.text == #"..."#)
    self.unexpectedBetweenEllipsisAndDefaultArgument = unexpectedBetweenEllipsisAndDefaultArgument?.createUnexpectedNodes()
    self.defaultArgument = defaultArgument?.createInitializerClause()
    self.unexpectedBetweenDefaultArgumentAndTrailingComma = unexpectedBetweenDefaultArgumentAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `FunctionParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionParameterSyntax`.
  func buildFunctionParameter(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FunctionParameterSyntax {
    let result = FunctionParameterSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndFirstName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), firstName: firstName?.buildToken(), unexpectedBetweenFirstNameAndSecondName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), secondName: secondName?.buildToken(), unexpectedBetweenSecondNameAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon?.buildToken(), unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type?.buildType(format: format, leadingTrivia: nil), unexpectedBetweenTypeAndEllipsis?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ellipsis: ellipsis?.buildToken(), unexpectedBetweenEllipsisAndDefaultArgument?.buildUnexpectedNodes(format: format, leadingTrivia: nil), defaultArgument: defaultArgument?.buildInitializerClause(format: format, leadingTrivia: nil), unexpectedBetweenDefaultArgumentAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildFunctionParameter(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionParameter`.
  public func createFunctionParameter() -> FunctionParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndFirstName: unexpectedBetweenAttributesAndFirstName, firstName: firstName, unexpectedBetweenFirstNameAndSecondName: unexpectedBetweenFirstNameAndSecondName, secondName: secondName, unexpectedBetweenSecondNameAndColon: unexpectedBetweenSecondNameAndColon, colon: colon, unexpectedBetweenColonAndType: unexpectedBetweenColonAndType, type: type, unexpectedBetweenTypeAndEllipsis: unexpectedBetweenTypeAndEllipsis, ellipsis: ellipsis, unexpectedBetweenEllipsisAndDefaultArgument: unexpectedBetweenEllipsisAndDefaultArgument, defaultArgument: defaultArgument, unexpectedBetweenDefaultArgumentAndTrailingComma: unexpectedBetweenDefaultArgumentAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct FunctionDecl: DeclBuildable, ExpressibleAsFunctionDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodes?
  let funcKeyword: Token
  let unexpectedBetweenFuncKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodes?
  let signature: FunctionSignature
  let unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodes?
  let body: CodeBlock?
  /// Creates a `FunctionDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndFuncKeyword: 
  ///   - funcKeyword: 
  ///   - unexpectedBetweenFuncKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFuncKeyword: ExpressibleAsUnexpectedNodes? = nil, funcKeyword: Token = Token.`func`, unexpectedBetweenFuncKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndFuncKeyword = unexpectedBetweenModifiersAndFuncKeyword?.createUnexpectedNodes()
    self.funcKeyword = funcKeyword
    assert(funcKeyword.text == #"func"#)
    self.unexpectedBetweenFuncKeywordAndIdentifier = unexpectedBetweenFuncKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameterClause = unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndSignature = unexpectedBetweenGenericParameterClauseAndSignature?.createUnexpectedNodes()
    self.signature = signature.createFunctionSignature()
    self.unexpectedBetweenSignatureAndGenericWhereClause = unexpectedBetweenSignatureAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndBody = unexpectedBetweenGenericWhereClauseAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFuncKeyword: ExpressibleAsUnexpectedNodes? = nil, funcKeyword: Token = Token.`func`, unexpectedBetweenFuncKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndFuncKeyword: unexpectedBetweenModifiersAndFuncKeyword, funcKeyword: funcKeyword, unexpectedBetweenFuncKeywordAndIdentifier: unexpectedBetweenFuncKeywordAndIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature, signature: signature, unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody, body: bodyBuilder())
  }
  /// Builds a `FunctionDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionDeclSyntax`.
  func buildFunctionDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FunctionDeclSyntax {
    let result = FunctionDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndFuncKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), funcKeyword: funcKeyword.buildToken(), unexpectedBetweenFuncKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndSignature?.buildUnexpectedNodes(format: format, leadingTrivia: nil), signature: signature.buildFunctionSignature(format: format, leadingTrivia: nil), unexpectedBetweenSignatureAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body?.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildFunctionDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionDecl`.
  public func createFunctionDecl() -> FunctionDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `FunctionDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct InitializerDecl: DeclBuildable, ExpressibleAsInitializerDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodes?
  let initKeyword: Token
  let unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodes?
  let optionalMark: Token?
  let unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodes?
  let signature: FunctionSignature
  let unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodes?
  let body: CodeBlock?
  /// Creates a `InitializerDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndInitKeyword: 
  ///   - initKeyword: 
  ///   - unexpectedBetweenInitKeywordAndOptionalMark: 
  ///   - optionalMark: 
  ///   - unexpectedBetweenOptionalMarkAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndInitKeyword: ExpressibleAsUnexpectedNodes? = nil, initKeyword: Token = Token.`init`, unexpectedBetweenInitKeywordAndOptionalMark: ExpressibleAsUnexpectedNodes? = nil, optionalMark: Token? = nil, unexpectedBetweenOptionalMarkAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndInitKeyword = unexpectedBetweenModifiersAndInitKeyword?.createUnexpectedNodes()
    self.initKeyword = initKeyword
    assert(initKeyword.text == #"init"#)
    self.unexpectedBetweenInitKeywordAndOptionalMark = unexpectedBetweenInitKeywordAndOptionalMark?.createUnexpectedNodes()
    self.optionalMark = optionalMark
    assert(optionalMark == nil || optionalMark!.text == #"?"# || optionalMark!.text == #"?"# || optionalMark!.text == #"!"#)
    self.unexpectedBetweenOptionalMarkAndGenericParameterClause = unexpectedBetweenOptionalMarkAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndSignature = unexpectedBetweenGenericParameterClauseAndSignature?.createUnexpectedNodes()
    self.signature = signature.createFunctionSignature()
    self.unexpectedBetweenSignatureAndGenericWhereClause = unexpectedBetweenSignatureAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndBody = unexpectedBetweenGenericWhereClauseAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndInitKeyword: ExpressibleAsUnexpectedNodes? = nil, initKeyword: Token = Token.`init`, unexpectedBetweenInitKeywordAndOptionalMark: ExpressibleAsUnexpectedNodes? = nil, optionalMark: Token? = nil, unexpectedBetweenOptionalMarkAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndInitKeyword: unexpectedBetweenModifiersAndInitKeyword, initKeyword: initKeyword, unexpectedBetweenInitKeywordAndOptionalMark: unexpectedBetweenInitKeywordAndOptionalMark, optionalMark: optionalMark, unexpectedBetweenOptionalMarkAndGenericParameterClause: unexpectedBetweenOptionalMarkAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature, signature: signature, unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody, body: bodyBuilder())
  }
  /// Builds a `InitializerDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InitializerDeclSyntax`.
  func buildInitializerDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> InitializerDeclSyntax {
    let result = InitializerDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndInitKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initKeyword: initKeyword.buildToken(), unexpectedBetweenInitKeywordAndOptionalMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), optionalMark: optionalMark?.buildToken(), unexpectedBetweenOptionalMarkAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndSignature?.buildUnexpectedNodes(format: format, leadingTrivia: nil), signature: signature.buildFunctionSignature(format: format, leadingTrivia: nil), unexpectedBetweenSignatureAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body?.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildInitializerDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsInitializerDecl`.
  public func createInitializerDecl() -> InitializerDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `InitializerDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeinitializerDecl: DeclBuildable, ExpressibleAsDeinitializerDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodes?
  let deinitKeyword: Token
  let unexpectedBetweenDeinitKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock?
  /// Creates a `DeinitializerDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndDeinitKeyword: 
  ///   - deinitKeyword: 
  ///   - unexpectedBetweenDeinitKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndDeinitKeyword: ExpressibleAsUnexpectedNodes? = nil, deinitKeyword: Token = Token.`deinit`, unexpectedBetweenDeinitKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndDeinitKeyword = unexpectedBetweenModifiersAndDeinitKeyword?.createUnexpectedNodes()
    self.deinitKeyword = deinitKeyword
    assert(deinitKeyword.text == #"deinit"#)
    self.unexpectedBetweenDeinitKeywordAndBody = unexpectedBetweenDeinitKeywordAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndDeinitKeyword: ExpressibleAsUnexpectedNodes? = nil, deinitKeyword: Token = Token.`deinit`, unexpectedBetweenDeinitKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndDeinitKeyword: unexpectedBetweenModifiersAndDeinitKeyword, deinitKeyword: deinitKeyword, unexpectedBetweenDeinitKeywordAndBody: unexpectedBetweenDeinitKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `DeinitializerDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeinitializerDeclSyntax`.
  func buildDeinitializerDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeinitializerDeclSyntax {
    let result = DeinitializerDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndDeinitKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), deinitKeyword: deinitKeyword.buildToken(), unexpectedBetweenDeinitKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body?.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildDeinitializerDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeinitializerDecl`.
  public func createDeinitializerDecl() -> DeinitializerDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `DeinitializerDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SubscriptDecl: DeclBuildable, ExpressibleAsSubscriptDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndSubscriptKeyword: UnexpectedNodes?
  let subscriptKeyword: Token
  let unexpectedBetweenSubscriptKeywordAndGenericParameterClause: UnexpectedNodes?
  let genericParameterClause: GenericParameterClause?
  let unexpectedBetweenGenericParameterClauseAndIndices: UnexpectedNodes?
  let indices: ParameterClause
  let unexpectedBetweenIndicesAndResult: UnexpectedNodes?
  let result: ReturnClause
  let unexpectedBetweenResultAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndAccessor: UnexpectedNodes?
  let accessor: SyntaxBuildable?
  /// Creates a `SubscriptDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndSubscriptKeyword: 
  ///   - subscriptKeyword: 
  ///   - unexpectedBetweenSubscriptKeywordAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndIndices: 
  ///   - indices: 
  ///   - unexpectedBetweenIndicesAndResult: 
  ///   - result: 
  ///   - unexpectedBetweenResultAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndAccessor: 
  ///   - accessor: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndSubscriptKeyword: ExpressibleAsUnexpectedNodes? = nil, subscriptKeyword: Token = Token.`subscript`, unexpectedBetweenSubscriptKeywordAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndIndices: ExpressibleAsUnexpectedNodes? = nil, indices: ExpressibleAsParameterClause, unexpectedBetweenIndicesAndResult: ExpressibleAsUnexpectedNodes? = nil, result: ExpressibleAsReturnClause, unexpectedBetweenResultAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndAccessor: ExpressibleAsUnexpectedNodes? = nil, accessor: ExpressibleAsSyntaxBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndSubscriptKeyword = unexpectedBetweenModifiersAndSubscriptKeyword?.createUnexpectedNodes()
    self.subscriptKeyword = subscriptKeyword
    assert(subscriptKeyword.text == #"subscript"#)
    self.unexpectedBetweenSubscriptKeywordAndGenericParameterClause = unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.createUnexpectedNodes()
    self.genericParameterClause = genericParameterClause?.createGenericParameterClause()
    self.unexpectedBetweenGenericParameterClauseAndIndices = unexpectedBetweenGenericParameterClauseAndIndices?.createUnexpectedNodes()
    self.indices = indices.createParameterClause()
    self.unexpectedBetweenIndicesAndResult = unexpectedBetweenIndicesAndResult?.createUnexpectedNodes()
    self.result = result.createReturnClause()
    self.unexpectedBetweenResultAndGenericWhereClause = unexpectedBetweenResultAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndAccessor = unexpectedBetweenGenericWhereClauseAndAccessor?.createUnexpectedNodes()
    self.accessor = accessor?.createSyntaxBuildable()
  }
  /// Builds a `SubscriptDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SubscriptDeclSyntax`.
  func buildSubscriptDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SubscriptDeclSyntax {
    let result = SubscriptDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndSubscriptKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), subscriptKeyword: subscriptKeyword.buildToken(), unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterClause: genericParameterClause?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterClauseAndIndices?.buildUnexpectedNodes(format: format, leadingTrivia: nil), indices: indices.buildParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenIndicesAndResult?.buildUnexpectedNodes(format: format, leadingTrivia: nil), result: result.buildReturnClause(format: format, leadingTrivia: nil), unexpectedBetweenResultAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndAccessor?.buildUnexpectedNodes(format: format, leadingTrivia: nil), accessor: accessor?.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildSubscriptDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsSubscriptDecl`.
  public func createSubscriptDecl() -> SubscriptDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `SubscriptDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AccessLevelModifier: SyntaxBuildable, ExpressibleAsAccessLevelModifier {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndModifier: UnexpectedNodes?
  let modifier: DeclModifierDetail?
  /// Creates a `AccessLevelModifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndModifier: 
  ///   - modifier: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifierDetail? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndModifier = unexpectedBetweenNameAndModifier?.createUnexpectedNodes()
    self.modifier = modifier?.createDeclModifierDetail()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifierDetail? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndModifier: unexpectedBetweenNameAndModifier, modifier: modifier)
  }
  /// Builds a `AccessLevelModifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessLevelModifierSyntax`.
  func buildAccessLevelModifier(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AccessLevelModifierSyntax {
    let result = AccessLevelModifierSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndModifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifier: modifier?.buildDeclModifierDetail(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAccessLevelModifier(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessLevelModifier`.
  public func createAccessLevelModifier() -> AccessLevelModifier {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessLevelModifier` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AccessPathComponent: SyntaxBuildable, ExpressibleAsAccessPathComponent {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndTrailingDot: UnexpectedNodes?
  let trailingDot: Token?
  /// Creates a `AccessPathComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingDot: 
  ///   - trailingDot: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingDot: ExpressibleAsUnexpectedNodes? = nil, trailingDot: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingDot = unexpectedBetweenNameAndTrailingDot?.createUnexpectedNodes()
    self.trailingDot = trailingDot
    assert(trailingDot == nil || trailingDot!.text == #"."#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingDot: ExpressibleAsUnexpectedNodes? = nil, trailingDot: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingDot: unexpectedBetweenNameAndTrailingDot, trailingDot: trailingDot)
  }
  /// Builds a `AccessPathComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessPathComponentSyntax`.
  func buildAccessPathComponent(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AccessPathComponentSyntax {
    let result = AccessPathComponentSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndTrailingDot?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingDot: trailingDot?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAccessPathComponent(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessPathComponent`.
  public func createAccessPathComponent() -> AccessPathComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessPathComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ImportDecl: DeclBuildable, ExpressibleAsImportDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndImportTok: UnexpectedNodes?
  let importTok: Token
  let unexpectedBetweenImportTokAndImportKind: UnexpectedNodes?
  let importKind: Token?
  let unexpectedBetweenImportKindAndPath: UnexpectedNodes?
  let path: AccessPath
  /// Creates a `ImportDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndImportTok: 
  ///   - importTok: 
  ///   - unexpectedBetweenImportTokAndImportKind: 
  ///   - importKind: 
  ///   - unexpectedBetweenImportKindAndPath: 
  ///   - path: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndImportTok: ExpressibleAsUnexpectedNodes? = nil, importTok: Token = Token.`import`, unexpectedBetweenImportTokAndImportKind: ExpressibleAsUnexpectedNodes? = nil, importKind: Token? = nil, unexpectedBetweenImportKindAndPath: ExpressibleAsUnexpectedNodes? = nil, path: ExpressibleAsAccessPath) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndImportTok = unexpectedBetweenModifiersAndImportTok?.createUnexpectedNodes()
    self.importTok = importTok
    assert(importTok.text == #"import"#)
    self.unexpectedBetweenImportTokAndImportKind = unexpectedBetweenImportTokAndImportKind?.createUnexpectedNodes()
    self.importKind = importKind
    assert(importKind == nil || importKind!.text == #"typealias"# || importKind!.text == #"struct"# || importKind!.text == #"class"# || importKind!.text == #"enum"# || importKind!.text == #"protocol"# || importKind!.text == #"var"# || importKind!.text == #"let"# || importKind!.text == #"func"#)
    self.unexpectedBetweenImportKindAndPath = unexpectedBetweenImportKindAndPath?.createUnexpectedNodes()
    self.path = path.createAccessPath()
  }
  /// Builds a `ImportDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImportDeclSyntax`.
  func buildImportDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ImportDeclSyntax {
    let result = ImportDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndImportTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), importTok: importTok.buildToken(), unexpectedBetweenImportTokAndImportKind?.buildUnexpectedNodes(format: format, leadingTrivia: nil), importKind: importKind?.buildToken(), unexpectedBetweenImportKindAndPath?.buildUnexpectedNodes(format: format, leadingTrivia: nil), path: path.buildAccessPath(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildImportDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsImportDecl`.
  public func createImportDecl() -> ImportDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ImportDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AccessorParameter: SyntaxBuildable, ExpressibleAsAccessorParameter {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `AccessorParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndName = unexpectedBetweenLeftParenAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndRightParen = unexpectedBetweenNameAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndName: unexpectedBetweenLeftParenAndName, name: Token.`identifier`(name), unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen, rightParen: rightParen)
  }
  /// Builds a `AccessorParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorParameterSyntax`.
  func buildAccessorParameter(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AccessorParameterSyntax {
    let result = AccessorParameterSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAccessorParameter(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorParameter`.
  public func createAccessorParameter() -> AccessorParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessorParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AccessorDecl: DeclBuildable, ExpressibleAsAccessorDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifier: UnexpectedNodes?
  let modifier: DeclModifier?
  let unexpectedBetweenModifierAndAccessorKind: UnexpectedNodes?
  let accessorKind: Token
  let unexpectedBetweenAccessorKindAndParameter: UnexpectedNodes?
  let parameter: AccessorParameter?
  let unexpectedBetweenParameterAndAsyncKeyword: UnexpectedNodes?
  let asyncKeyword: Token?
  let unexpectedBetweenAsyncKeywordAndThrowsKeyword: UnexpectedNodes?
  let throwsKeyword: Token?
  let unexpectedBetweenThrowsKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock?
  /// Creates a `AccessorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifier: 
  ///   - modifier: 
  ///   - unexpectedBetweenModifierAndAccessorKind: 
  ///   - accessorKind: 
  ///   - unexpectedBetweenAccessorKindAndParameter: 
  ///   - parameter: 
  ///   - unexpectedBetweenParameterAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsKeyword: 
  ///   - throwsKeyword: 
  ///   - unexpectedBetweenThrowsKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifier? = nil, unexpectedBetweenModifierAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token, unexpectedBetweenAccessorKindAndParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsAccessorParameter? = nil, unexpectedBetweenParameterAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsKeyword: Token? = nil, unexpectedBetweenThrowsKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifier = unexpectedBetweenAttributesAndModifier?.createUnexpectedNodes()
    self.modifier = modifier?.createDeclModifier()
    self.unexpectedBetweenModifierAndAccessorKind = unexpectedBetweenModifierAndAccessorKind?.createUnexpectedNodes()
    self.accessorKind = accessorKind
    assert(accessorKind.text == #"get"# || accessorKind.text == #"set"# || accessorKind.text == #"didSet"# || accessorKind.text == #"willSet"# || accessorKind.text == #"unsafeAddress"# || accessorKind.text == #"addressWithOwner"# || accessorKind.text == #"addressWithNativeOwner"# || accessorKind.text == #"unsafeMutableAddress"# || accessorKind.text == #"mutableAddressWithOwner"# || accessorKind.text == #"mutableAddressWithNativeOwner"# || accessorKind.text == #"_read"# || accessorKind.text == #"_modify"#)
    self.unexpectedBetweenAccessorKindAndParameter = unexpectedBetweenAccessorKindAndParameter?.createUnexpectedNodes()
    self.parameter = parameter?.createAccessorParameter()
    self.unexpectedBetweenParameterAndAsyncKeyword = unexpectedBetweenParameterAndAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsKeyword = unexpectedBetweenAsyncKeywordAndThrowsKeyword?.createUnexpectedNodes()
    self.throwsKeyword = throwsKeyword
    assert(throwsKeyword == nil || throwsKeyword!.text == #"throws"# || throwsKeyword!.text == #"rethrows"#)
    self.unexpectedBetweenThrowsKeywordAndBody = unexpectedBetweenThrowsKeywordAndBody?.createUnexpectedNodes()
    self.body = body?.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifier? = nil, unexpectedBetweenModifierAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token, unexpectedBetweenAccessorKindAndParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsAccessorParameter? = nil, unexpectedBetweenParameterAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsKeyword: Token? = nil, unexpectedBetweenThrowsKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifier: unexpectedBetweenAttributesAndModifier, modifier: modifier, unexpectedBetweenModifierAndAccessorKind: unexpectedBetweenModifierAndAccessorKind, accessorKind: accessorKind, unexpectedBetweenAccessorKindAndParameter: unexpectedBetweenAccessorKindAndParameter, parameter: parameter, unexpectedBetweenParameterAndAsyncKeyword: unexpectedBetweenParameterAndAsyncKeyword, asyncKeyword: asyncKeyword.map {
      Token.`contextualKeyword`($0)
    }, unexpectedBetweenAsyncKeywordAndThrowsKeyword: unexpectedBetweenAsyncKeywordAndThrowsKeyword, throwsKeyword: throwsKeyword, unexpectedBetweenThrowsKeywordAndBody: unexpectedBetweenThrowsKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `AccessorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorDeclSyntax`.
  func buildAccessorDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AccessorDeclSyntax {
    let result = AccessorDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifier: modifier?.buildDeclModifier(format: format, leadingTrivia: nil), unexpectedBetweenModifierAndAccessorKind?.buildUnexpectedNodes(format: format, leadingTrivia: nil), accessorKind: accessorKind.buildToken(), unexpectedBetweenAccessorKindAndParameter?.buildUnexpectedNodes(format: format, leadingTrivia: nil), parameter: parameter?.buildAccessorParameter(format: format, leadingTrivia: nil), unexpectedBetweenParameterAndAsyncKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asyncKeyword: asyncKeyword?.buildToken(), unexpectedBetweenAsyncKeywordAndThrowsKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), throwsKeyword: throwsKeyword?.buildToken(), unexpectedBetweenThrowsKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body?.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildAccessorDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorDecl`.
  public func createAccessorDecl() -> AccessorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `AccessorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AccessorBlock: SyntaxBuildable, ExpressibleAsAccessorBlock {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftBrace: UnexpectedNodes?
  let leftBrace: Token
  let unexpectedBetweenLeftBraceAndAccessors: UnexpectedNodes?
  let accessors: AccessorList
  let unexpectedBetweenAccessorsAndRightBrace: UnexpectedNodes?
  let rightBrace: Token
  /// Creates a `AccessorBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndAccessors: 
  ///   - accessors: 
  ///   - unexpectedBetweenAccessorsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndAccessors: ExpressibleAsUnexpectedNodes? = nil, accessors: ExpressibleAsAccessorList, unexpectedBetweenAccessorsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftBrace = unexpectedBeforeLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndAccessors = unexpectedBetweenLeftBraceAndAccessors?.createUnexpectedNodes()
    self.accessors = accessors.createAccessorList()
    self.unexpectedBetweenAccessorsAndRightBrace = unexpectedBetweenAccessorsAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// Builds a `AccessorBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorBlockSyntax`.
  func buildAccessorBlock(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AccessorBlockSyntax {
    let result = AccessorBlockSyntax(unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBrace: leftBrace.buildToken(), unexpectedBetweenLeftBraceAndAccessors?.buildUnexpectedNodes(format: format, leadingTrivia: nil), accessors: accessors.buildAccessorList(format: format, leadingTrivia: nil), unexpectedBetweenAccessorsAndRightBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBrace: rightBrace.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAccessorBlock(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorBlock`.
  public func createAccessorBlock() -> AccessorBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessorBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PatternBinding: SyntaxBuildable, ExpressibleAsPatternBinding, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  let typeAnnotation: TypeAnnotation?
  let unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
  let initializer: InitializerClause?
  let unexpectedBetweenInitializerAndAccessor: UnexpectedNodes?
  let accessor: SyntaxBuildable?
  let unexpectedBetweenAccessorAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `PatternBinding` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndAccessor: 
  ///   - accessor: 
  ///   - unexpectedBetweenAccessorAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil, unexpectedBetweenInitializerAndAccessor: ExpressibleAsUnexpectedNodes? = nil, accessor: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenAccessorAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInitializer = unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createInitializerClause()
    self.unexpectedBetweenInitializerAndAccessor = unexpectedBetweenInitializerAndAccessor?.createUnexpectedNodes()
    self.accessor = accessor?.createSyntaxBuildable()
    self.unexpectedBetweenAccessorAndTrailingComma = unexpectedBetweenAccessorAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `PatternBindingSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PatternBindingSyntax`.
  func buildPatternBinding(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternBindingSyntax {
    let result = PatternBindingSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format, leadingTrivia: nil), unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initializer: initializer?.buildInitializerClause(format: format, leadingTrivia: nil), unexpectedBetweenInitializerAndAccessor?.buildUnexpectedNodes(format: format, leadingTrivia: nil), accessor: accessor?.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenAccessorAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPatternBinding(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPatternBinding`.
  public func createPatternBinding() -> PatternBinding {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBinding` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforePattern: unexpectedBeforePattern, pattern: pattern, unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation, typeAnnotation: typeAnnotation, unexpectedBetweenTypeAnnotationAndInitializer: unexpectedBetweenTypeAnnotationAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndAccessor: unexpectedBetweenInitializerAndAccessor, accessor: accessor, unexpectedBetweenAccessorAndTrailingComma: unexpectedBetweenAccessorAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct VariableDecl: DeclBuildable, ExpressibleAsVariableDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndLetOrVarKeyword: UnexpectedNodes?
  let letOrVarKeyword: Token
  let unexpectedBetweenLetOrVarKeywordAndBindings: UnexpectedNodes?
  let bindings: PatternBindingList
  /// Creates a `VariableDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndBindings: 
  ///   - bindings: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndBindings: ExpressibleAsUnexpectedNodes? = nil, bindings: ExpressibleAsPatternBindingList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndLetOrVarKeyword = unexpectedBetweenModifiersAndLetOrVarKeyword?.createUnexpectedNodes()
    self.letOrVarKeyword = letOrVarKeyword
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.unexpectedBetweenLetOrVarKeywordAndBindings = unexpectedBetweenLetOrVarKeywordAndBindings?.createUnexpectedNodes()
    self.bindings = bindings.createPatternBindingList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndBindings: ExpressibleAsUnexpectedNodes? = nil, @PatternBindingListBuilder bindingsBuilder: () -> ExpressibleAsPatternBindingList =  {
    PatternBindingList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndLetOrVarKeyword: unexpectedBetweenModifiersAndLetOrVarKeyword, letOrVarKeyword: letOrVarKeyword, unexpectedBetweenLetOrVarKeywordAndBindings: unexpectedBetweenLetOrVarKeywordAndBindings, bindings: bindingsBuilder())
  }
  /// Builds a `VariableDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `VariableDeclSyntax`.
  func buildVariableDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> VariableDeclSyntax {
    let result = VariableDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndLetOrVarKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), letOrVarKeyword: letOrVarKeyword.buildToken(), unexpectedBetweenLetOrVarKeywordAndBindings?.buildUnexpectedNodes(format: format, leadingTrivia: nil), bindings: bindings.buildPatternBindingList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildVariableDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsVariableDecl`.
  public func createVariableDecl() -> VariableDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `VariableDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// An element of an enum case, containing the name of the case and,optionally, either associated values or an assignment to a raw value.
public struct EnumCaseElement: SyntaxBuildable, ExpressibleAsEnumCaseElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndAssociatedValue: UnexpectedNodes?
  let associatedValue: ParameterClause?
  let unexpectedBetweenAssociatedValueAndRawValue: UnexpectedNodes?
  let rawValue: InitializerClause?
  let unexpectedBetweenRawValueAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `EnumCaseElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: The name of this case.
  ///   - unexpectedBetweenIdentifierAndAssociatedValue: 
  ///   - associatedValue: The set of associated values of the case.
  ///   - unexpectedBetweenAssociatedValueAndRawValue: 
  ///   - rawValue: The raw value of this enum element, if present.
  ///   - unexpectedBetweenRawValueAndTrailingComma: 
  ///   - trailingComma: The trailing comma of this element, if the case hasmultiple elements.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndAssociatedValue: ExpressibleAsUnexpectedNodes? = nil, associatedValue: ExpressibleAsParameterClause? = nil, unexpectedBetweenAssociatedValueAndRawValue: ExpressibleAsUnexpectedNodes? = nil, rawValue: ExpressibleAsInitializerClause? = nil, unexpectedBetweenRawValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndAssociatedValue = unexpectedBetweenIdentifierAndAssociatedValue?.createUnexpectedNodes()
    self.associatedValue = associatedValue?.createParameterClause()
    self.unexpectedBetweenAssociatedValueAndRawValue = unexpectedBetweenAssociatedValueAndRawValue?.createUnexpectedNodes()
    self.rawValue = rawValue?.createInitializerClause()
    self.unexpectedBetweenRawValueAndTrailingComma = unexpectedBetweenRawValueAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndAssociatedValue: ExpressibleAsUnexpectedNodes? = nil, associatedValue: ExpressibleAsParameterClause? = nil, unexpectedBetweenAssociatedValueAndRawValue: ExpressibleAsUnexpectedNodes? = nil, rawValue: ExpressibleAsInitializerClause? = nil, unexpectedBetweenRawValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndAssociatedValue: unexpectedBetweenIdentifierAndAssociatedValue, associatedValue: associatedValue, unexpectedBetweenAssociatedValueAndRawValue: unexpectedBetweenAssociatedValueAndRawValue, rawValue: rawValue, unexpectedBetweenRawValueAndTrailingComma: unexpectedBetweenRawValueAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `EnumCaseElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCaseElementSyntax`.
  func buildEnumCaseElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> EnumCaseElementSyntax {
    let result = EnumCaseElementSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndAssociatedValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), associatedValue: associatedValue?.buildParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenAssociatedValueAndRawValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rawValue: rawValue?.buildInitializerClause(format: format, leadingTrivia: nil), unexpectedBetweenRawValueAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildEnumCaseElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCaseElement`.
  public func createEnumCaseElement() -> EnumCaseElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `EnumCaseElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndAssociatedValue: unexpectedBetweenIdentifierAndAssociatedValue, associatedValue: associatedValue, unexpectedBetweenAssociatedValueAndRawValue: unexpectedBetweenAssociatedValueAndRawValue, rawValue: rawValue, unexpectedBetweenRawValueAndTrailingComma: unexpectedBetweenRawValueAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
/// A `case` declaration of a Swift `enum`. It can have 1 or more`EnumCaseElement`s inside, each declaring a different case of theenum.
public struct EnumCaseDecl: DeclBuildable, ExpressibleAsEnumCaseDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodes?
  let caseKeyword: Token
  let unexpectedBetweenCaseKeywordAndElements: UnexpectedNodes?
  let elements: EnumCaseElementList
  /// Creates a `EnumCaseDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the case declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the case declaration.
  ///   - unexpectedBetweenModifiersAndCaseKeyword: 
  ///   - caseKeyword: The `case` keyword for this case.
  ///   - unexpectedBetweenCaseKeywordAndElements: 
  ///   - elements: The elements this case declares.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsEnumCaseElementList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndCaseKeyword = unexpectedBetweenModifiersAndCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndElements = unexpectedBetweenCaseKeywordAndElements?.createUnexpectedNodes()
    self.elements = elements.createEnumCaseElementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndElements: ExpressibleAsUnexpectedNodes? = nil, @EnumCaseElementListBuilder elementsBuilder: () -> ExpressibleAsEnumCaseElementList =  {
    EnumCaseElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndCaseKeyword: unexpectedBetweenModifiersAndCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndElements: unexpectedBetweenCaseKeywordAndElements, elements: elementsBuilder())
  }
  /// Builds a `EnumCaseDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCaseDeclSyntax`.
  func buildEnumCaseDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> EnumCaseDeclSyntax {
    let result = EnumCaseDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndCaseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), caseKeyword: caseKeyword.buildToken(), unexpectedBetweenCaseKeywordAndElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildEnumCaseElementList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildEnumCaseDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCaseDecl`.
  public func createEnumCaseDecl() -> EnumCaseDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `EnumCaseDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A Swift `enum` declaration.
public struct EnumDecl: DeclBuildable, ExpressibleAsEnumDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodes?
  let enumKeyword: Token
  let unexpectedBetweenEnumKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndGenericParameters: UnexpectedNodes?
  let genericParameters: GenericParameterClause?
  let unexpectedBetweenGenericParametersAndInheritanceClause: UnexpectedNodes?
  let inheritanceClause: TypeInheritanceClause?
  let unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
  let genericWhereClause: GenericWhereClause?
  let unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
  let members: MemberDeclBlock
  /// Creates a `EnumDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the enum declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the enum declaration.
  ///   - unexpectedBetweenModifiersAndEnumKeyword: 
  ///   - enumKeyword: The `enum` keyword for this declaration.
  ///   - unexpectedBetweenEnumKeywordAndIdentifier: 
  ///   - identifier: The name of this enum.
  ///   - unexpectedBetweenIdentifierAndGenericParameters: 
  ///   - genericParameters: The generic parameters, if any, for this enum.
  ///   - unexpectedBetweenGenericParametersAndInheritanceClause: 
  ///   - inheritanceClause: The inheritance clause describing conformances or rawvalues for this enum.
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters ofthis enum.
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: The cases and other members of this enum.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndEnumKeyword: ExpressibleAsUnexpectedNodes? = nil, enumKeyword: Token = Token.`enum`, unexpectedBetweenEnumKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParametersAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndEnumKeyword = unexpectedBetweenModifiersAndEnumKeyword?.createUnexpectedNodes()
    self.enumKeyword = enumKeyword
    assert(enumKeyword.text == #"enum"#)
    self.unexpectedBetweenEnumKeywordAndIdentifier = unexpectedBetweenEnumKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndGenericParameters = unexpectedBetweenIdentifierAndGenericParameters?.createUnexpectedNodes()
    self.genericParameters = genericParameters?.createGenericParameterClause()
    self.unexpectedBetweenGenericParametersAndInheritanceClause = unexpectedBetweenGenericParametersAndInheritanceClause?.createUnexpectedNodes()
    self.inheritanceClause = inheritanceClause?.createTypeInheritanceClause()
    self.unexpectedBetweenInheritanceClauseAndGenericWhereClause = unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes()
    self.genericWhereClause = genericWhereClause?.createGenericWhereClause()
    self.unexpectedBetweenGenericWhereClauseAndMembers = unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes()
    self.members = members.createMemberDeclBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndEnumKeyword: ExpressibleAsUnexpectedNodes? = nil, enumKeyword: Token = Token.`enum`, unexpectedBetweenEnumKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParametersAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndEnumKeyword: unexpectedBetweenModifiersAndEnumKeyword, enumKeyword: enumKeyword, unexpectedBetweenEnumKeywordAndIdentifier: unexpectedBetweenEnumKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameters: unexpectedBetweenIdentifierAndGenericParameters, genericParameters: genericParameters, unexpectedBetweenGenericParametersAndInheritanceClause: unexpectedBetweenGenericParametersAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  /// Builds a `EnumDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumDeclSyntax`.
  func buildEnumDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> EnumDeclSyntax {
    let result = EnumDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndEnumKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), enumKeyword: enumKeyword.buildToken(), unexpectedBetweenEnumKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndGenericParameters?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameters: genericParameters?.buildGenericParameterClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericParametersAndInheritanceClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritanceClause: inheritanceClause?.buildTypeInheritanceClause(format: format, leadingTrivia: nil), unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericWhereClause: genericWhereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), members: members.buildMemberDeclBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildEnumDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumDecl`.
  public func createEnumDecl() -> EnumDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `EnumDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A Swift `operator` declaration.
public struct OperatorDecl: DeclBuildable, ExpressibleAsOperatorDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndOperatorKeyword: UnexpectedNodes?
  let operatorKeyword: Token
  let unexpectedBetweenOperatorKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: UnexpectedNodes?
  let operatorPrecedenceAndTypes: OperatorPrecedenceAndTypes?
  /// Creates a `OperatorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the 'operator' declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the 'operator'declaration.
  ///   - unexpectedBetweenModifiersAndOperatorKeyword: 
  ///   - operatorKeyword: 
  ///   - unexpectedBetweenOperatorKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: 
  ///   - operatorPrecedenceAndTypes: Optionally specify a precedence group and designated types.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndOperatorKeyword: ExpressibleAsUnexpectedNodes? = nil, operatorKeyword: Token = Token.`operator`, unexpectedBetweenOperatorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: ExpressibleAsUnexpectedNodes? = nil, operatorPrecedenceAndTypes: ExpressibleAsOperatorPrecedenceAndTypes? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndOperatorKeyword = unexpectedBetweenModifiersAndOperatorKeyword?.createUnexpectedNodes()
    self.operatorKeyword = operatorKeyword
    assert(operatorKeyword.text == #"operator"#)
    self.unexpectedBetweenOperatorKeywordAndIdentifier = unexpectedBetweenOperatorKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes = unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes?.createUnexpectedNodes()
    self.operatorPrecedenceAndTypes = operatorPrecedenceAndTypes?.createOperatorPrecedenceAndTypes()
  }
  /// Builds a `OperatorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OperatorDeclSyntax`.
  func buildOperatorDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> OperatorDeclSyntax {
    let result = OperatorDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndOperatorKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), operatorKeyword: operatorKeyword.buildToken(), unexpectedBetweenOperatorKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), operatorPrecedenceAndTypes: operatorPrecedenceAndTypes?.buildOperatorPrecedenceAndTypes(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildOperatorDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsOperatorDecl`.
  public func createOperatorDecl() -> OperatorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `OperatorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A clause to specify precedence group in infix operator declarations, and designated types in any operator declaration.
public struct OperatorPrecedenceAndTypes: SyntaxBuildable, ExpressibleAsOperatorPrecedenceAndTypes {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndPrecedenceGroupAndDesignatedTypes: UnexpectedNodes?
  let precedenceGroupAndDesignatedTypes: IdentifierList
  /// Creates a `OperatorPrecedenceAndTypes` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndPrecedenceGroupAndDesignatedTypes: 
  ///   - precedenceGroupAndDesignatedTypes: The precedence group and designated types for this operator
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndPrecedenceGroupAndDesignatedTypes: ExpressibleAsUnexpectedNodes? = nil, precedenceGroupAndDesignatedTypes: ExpressibleAsIdentifierList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeColon = unexpectedBeforeColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndPrecedenceGroupAndDesignatedTypes = unexpectedBetweenColonAndPrecedenceGroupAndDesignatedTypes?.createUnexpectedNodes()
    self.precedenceGroupAndDesignatedTypes = precedenceGroupAndDesignatedTypes.createIdentifierList()
  }
  /// Builds a `OperatorPrecedenceAndTypesSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OperatorPrecedenceAndTypesSyntax`.
  func buildOperatorPrecedenceAndTypes(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> OperatorPrecedenceAndTypesSyntax {
    let result = OperatorPrecedenceAndTypesSyntax(unexpectedBeforeColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndPrecedenceGroupAndDesignatedTypes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), precedenceGroupAndDesignatedTypes: precedenceGroupAndDesignatedTypes.buildIdentifierList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildOperatorPrecedenceAndTypes(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOperatorPrecedenceAndTypes`.
  public func createOperatorPrecedenceAndTypes() -> OperatorPrecedenceAndTypes {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OperatorPrecedenceAndTypes` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A Swift `precedencegroup` declaration.
public struct PrecedenceGroupDecl: DeclBuildable, ExpressibleAsPrecedenceGroupDecl {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
  let modifiers: ModifierList?
  let unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodes?
  let precedencegroupKeyword: Token
  let unexpectedBetweenPrecedencegroupKeywordAndIdentifier: UnexpectedNodes?
  let identifier: Token
  let unexpectedBetweenIdentifierAndLeftBrace: UnexpectedNodes?
  let leftBrace: Token
  let unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodes?
  let groupAttributes: PrecedenceGroupAttributeList
  let unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodes?
  let rightBrace: Token
  /// Creates a `PrecedenceGroupDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the 'precedencegroup' declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the 'precedencegroup'declaration.
  ///   - unexpectedBetweenModifiersAndPrecedencegroupKeyword: 
  ///   - precedencegroupKeyword: 
  ///   - unexpectedBetweenPrecedencegroupKeywordAndIdentifier: 
  ///   - identifier: The name of this precedence group.
  ///   - unexpectedBetweenIdentifierAndLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndGroupAttributes: 
  ///   - groupAttributes: The characteristics of this precedence group.
  ///   - unexpectedBetweenGroupAttributesAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndPrecedencegroupKeyword: ExpressibleAsUnexpectedNodes? = nil, precedencegroupKeyword: Token = Token.`precedencegroup`, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndGroupAttributes: ExpressibleAsUnexpectedNodes? = nil, groupAttributes: ExpressibleAsPrecedenceGroupAttributeList, unexpectedBetweenGroupAttributesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndModifiers = unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes()
    self.modifiers = modifiers?.createModifierList()
    self.unexpectedBetweenModifiersAndPrecedencegroupKeyword = unexpectedBetweenModifiersAndPrecedencegroupKeyword?.createUnexpectedNodes()
    self.precedencegroupKeyword = precedencegroupKeyword
    assert(precedencegroupKeyword.text == #"precedencegroup"#)
    self.unexpectedBetweenPrecedencegroupKeywordAndIdentifier = unexpectedBetweenPrecedencegroupKeywordAndIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
    self.unexpectedBetweenIdentifierAndLeftBrace = unexpectedBetweenIdentifierAndLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndGroupAttributes = unexpectedBetweenLeftBraceAndGroupAttributes?.createUnexpectedNodes()
    self.groupAttributes = groupAttributes.createPrecedenceGroupAttributeList()
    self.unexpectedBetweenGroupAttributesAndRightBrace = unexpectedBetweenGroupAttributesAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndPrecedencegroupKeyword: ExpressibleAsUnexpectedNodes? = nil, precedencegroupKeyword: Token = Token.`precedencegroup`, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndGroupAttributes: ExpressibleAsUnexpectedNodes? = nil, groupAttributes: ExpressibleAsPrecedenceGroupAttributeList, unexpectedBetweenGroupAttributesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndPrecedencegroupKeyword: unexpectedBetweenModifiersAndPrecedencegroupKeyword, precedencegroupKeyword: precedencegroupKeyword, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: unexpectedBetweenPrecedencegroupKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndLeftBrace: unexpectedBetweenIdentifierAndLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndGroupAttributes: unexpectedBetweenLeftBraceAndGroupAttributes, groupAttributes: groupAttributes, unexpectedBetweenGroupAttributesAndRightBrace: unexpectedBetweenGroupAttributesAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `PrecedenceGroupDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupDeclSyntax`.
  func buildPrecedenceGroupDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrecedenceGroupDeclSyntax {
    let result = PrecedenceGroupDeclSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format, leadingTrivia: nil), modifiers: modifiers?.buildModifierList(format: format, leadingTrivia: nil), unexpectedBetweenModifiersAndPrecedencegroupKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), precedencegroupKeyword: precedencegroupKeyword.buildToken(), unexpectedBetweenPrecedencegroupKeywordAndIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken(), unexpectedBetweenIdentifierAndLeftBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBrace: leftBrace.buildToken(), unexpectedBetweenLeftBraceAndGroupAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), groupAttributes: groupAttributes.buildPrecedenceGroupAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenGroupAttributesAndRightBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBrace: rightBrace.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclSyntax {
    let result = buildPrecedenceGroupDecl(format: format, leadingTrivia: additionalLeadingTrivia)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupDecl`.
  public func createPrecedenceGroupDecl() -> PrecedenceGroupDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PrecedenceGroupDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// Specify the new precedence group's relation to existing precedencegroups.
public struct PrecedenceGroupRelation: SyntaxBuildable, ExpressibleAsPrecedenceGroupRelation {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeHigherThanOrLowerThan: UnexpectedNodes?
  let higherThanOrLowerThan: Token
  let unexpectedBetweenHigherThanOrLowerThanAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndOtherNames: UnexpectedNodes?
  let otherNames: PrecedenceGroupNameList
  /// Creates a `PrecedenceGroupRelation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeHigherThanOrLowerThan: 
  ///   - higherThanOrLowerThan: The relation to specified other precedence groups.
  ///   - unexpectedBetweenHigherThanOrLowerThanAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndOtherNames: 
  ///   - otherNames: The name of other precedence group to which this precedencegroup relates.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeHigherThanOrLowerThan: ExpressibleAsUnexpectedNodes? = nil, higherThanOrLowerThan: Token, unexpectedBetweenHigherThanOrLowerThanAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOtherNames: ExpressibleAsUnexpectedNodes? = nil, otherNames: ExpressibleAsPrecedenceGroupNameList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeHigherThanOrLowerThan = unexpectedBeforeHigherThanOrLowerThan?.createUnexpectedNodes()
    self.higherThanOrLowerThan = higherThanOrLowerThan
    assert(higherThanOrLowerThan.text == #"higherThan"# || higherThanOrLowerThan.text == #"lowerThan"#)
    self.unexpectedBetweenHigherThanOrLowerThanAndColon = unexpectedBetweenHigherThanOrLowerThanAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndOtherNames = unexpectedBetweenColonAndOtherNames?.createUnexpectedNodes()
    self.otherNames = otherNames.createPrecedenceGroupNameList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeHigherThanOrLowerThan: ExpressibleAsUnexpectedNodes? = nil, higherThanOrLowerThan: String, unexpectedBetweenHigherThanOrLowerThanAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOtherNames: ExpressibleAsUnexpectedNodes? = nil, otherNames: ExpressibleAsPrecedenceGroupNameList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeHigherThanOrLowerThan: unexpectedBeforeHigherThanOrLowerThan, higherThanOrLowerThan: Token.`identifier`(higherThanOrLowerThan), unexpectedBetweenHigherThanOrLowerThanAndColon: unexpectedBetweenHigherThanOrLowerThanAndColon, colon: colon, unexpectedBetweenColonAndOtherNames: unexpectedBetweenColonAndOtherNames, otherNames: otherNames)
  }
  /// Builds a `PrecedenceGroupRelationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupRelationSyntax`.
  func buildPrecedenceGroupRelation(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrecedenceGroupRelationSyntax {
    let result = PrecedenceGroupRelationSyntax(unexpectedBeforeHigherThanOrLowerThan?.buildUnexpectedNodes(format: format, leadingTrivia: nil), higherThanOrLowerThan: higherThanOrLowerThan.buildToken(), unexpectedBetweenHigherThanOrLowerThanAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndOtherNames?.buildUnexpectedNodes(format: format, leadingTrivia: nil), otherNames: otherNames.buildPrecedenceGroupNameList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPrecedenceGroupRelation(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupRelation`.
  public func createPrecedenceGroupRelation() -> PrecedenceGroupRelation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupRelation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PrecedenceGroupNameElement: SyntaxBuildable, ExpressibleAsPrecedenceGroupNameElement {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `PrecedenceGroupNameElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingComma = unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `PrecedenceGroupNameElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupNameElementSyntax`.
  func buildPrecedenceGroupNameElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrecedenceGroupNameElementSyntax {
    let result = PrecedenceGroupNameElementSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPrecedenceGroupNameElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupNameElement`.
  public func createPrecedenceGroupNameElement() -> PrecedenceGroupNameElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupNameElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// Specifies the precedence of an operator when used in an operationthat includes optional chaining.
public struct PrecedenceGroupAssignment: SyntaxBuildable, ExpressibleAsPrecedenceGroupAssignment {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAssignmentKeyword: UnexpectedNodes?
  let assignmentKeyword: Token
  let unexpectedBetweenAssignmentKeywordAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndFlag: UnexpectedNodes?
  let flag: Token
  /// Creates a `PrecedenceGroupAssignment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssignmentKeyword: 
  ///   - assignmentKeyword: 
  ///   - unexpectedBetweenAssignmentKeywordAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndFlag: 
  ///   - flag: When true, an operator in the corresponding precedence groupuses the same grouping rules during optional chaining as theassignment operators from the standard library. Otherwise,operators in the precedence group follows the same optionalchaining rules as operators that don't perform assignment.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssignmentKeyword: ExpressibleAsUnexpectedNodes? = nil, assignmentKeyword: Token, unexpectedBetweenAssignmentKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndFlag: ExpressibleAsUnexpectedNodes? = nil, flag: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAssignmentKeyword = unexpectedBeforeAssignmentKeyword?.createUnexpectedNodes()
    self.assignmentKeyword = assignmentKeyword
    assert(assignmentKeyword.text == #"assignment"#)
    self.unexpectedBetweenAssignmentKeywordAndColon = unexpectedBetweenAssignmentKeywordAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndFlag = unexpectedBetweenColonAndFlag?.createUnexpectedNodes()
    self.flag = flag
    assert(flag.text == #"true"# || flag.text == #"false"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssignmentKeyword: ExpressibleAsUnexpectedNodes? = nil, assignmentKeyword: String, unexpectedBetweenAssignmentKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndFlag: ExpressibleAsUnexpectedNodes? = nil, flag: Token) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAssignmentKeyword: unexpectedBeforeAssignmentKeyword, assignmentKeyword: Token.`identifier`(assignmentKeyword), unexpectedBetweenAssignmentKeywordAndColon: unexpectedBetweenAssignmentKeywordAndColon, colon: colon, unexpectedBetweenColonAndFlag: unexpectedBetweenColonAndFlag, flag: flag)
  }
  /// Builds a `PrecedenceGroupAssignmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupAssignmentSyntax`.
  func buildPrecedenceGroupAssignment(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrecedenceGroupAssignmentSyntax {
    let result = PrecedenceGroupAssignmentSyntax(unexpectedBeforeAssignmentKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), assignmentKeyword: assignmentKeyword.buildToken(), unexpectedBetweenAssignmentKeywordAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndFlag?.buildUnexpectedNodes(format: format, leadingTrivia: nil), flag: flag.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPrecedenceGroupAssignment(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAssignment`.
  public func createPrecedenceGroupAssignment() -> PrecedenceGroupAssignment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupAssignment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// Specifies how a sequence of operators with the same precedence levelare grouped together in the absence of grouping parentheses.
public struct PrecedenceGroupAssociativity: SyntaxBuildable, ExpressibleAsPrecedenceGroupAssociativity {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAssociativityKeyword: UnexpectedNodes?
  let associativityKeyword: Token
  let unexpectedBetweenAssociativityKeywordAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndValue: UnexpectedNodes?
  let value: Token
  /// Creates a `PrecedenceGroupAssociativity` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssociativityKeyword: 
  ///   - associativityKeyword: 
  ///   - unexpectedBetweenAssociativityKeywordAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: Operators that are `left`-associative group left-to-right.Operators that are `right`-associative group right-to-left.Operators that are specified with an associativity of `none`don't associate at all
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssociativityKeyword: ExpressibleAsUnexpectedNodes? = nil, associativityKeyword: Token, unexpectedBetweenAssociativityKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAssociativityKeyword = unexpectedBeforeAssociativityKeyword?.createUnexpectedNodes()
    self.associativityKeyword = associativityKeyword
    assert(associativityKeyword.text == #"associativity"#)
    self.unexpectedBetweenAssociativityKeywordAndColon = unexpectedBetweenAssociativityKeywordAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValue = unexpectedBetweenColonAndValue?.createUnexpectedNodes()
    self.value = value
    assert(value.text == #"left"# || value.text == #"right"# || value.text == #"none"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssociativityKeyword: ExpressibleAsUnexpectedNodes? = nil, associativityKeyword: String, unexpectedBetweenAssociativityKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAssociativityKeyword: unexpectedBeforeAssociativityKeyword, associativityKeyword: Token.`identifier`(associativityKeyword), unexpectedBetweenAssociativityKeywordAndColon: unexpectedBetweenAssociativityKeywordAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: Token.`identifier`(value))
  }
  /// Builds a `PrecedenceGroupAssociativitySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupAssociativitySyntax`.
  func buildPrecedenceGroupAssociativity(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrecedenceGroupAssociativitySyntax {
    let result = PrecedenceGroupAssociativitySyntax(unexpectedBeforeAssociativityKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), associativityKeyword: associativityKeyword.buildToken(), unexpectedBetweenAssociativityKeywordAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), value: value.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPrecedenceGroupAssociativity(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAssociativity`.
  public func createPrecedenceGroupAssociativity() -> PrecedenceGroupAssociativity {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupAssociativity` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A custom `@` attribute.
public struct CustomAttribute: SyntaxBuildable, ExpressibleAsCustomAttribute {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAtSignToken: UnexpectedNodes?
  let atSignToken: Token
  let unexpectedBetweenAtSignTokenAndAttributeName: UnexpectedNodes?
  let attributeName: TypeBuildable
  let unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodes?
  let leftParen: Token?
  let unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodes?
  let argumentList: TupleExprElementList?
  let unexpectedBetweenArgumentListAndRightParen: UnexpectedNodes?
  let rightParen: Token?
  /// Creates a `CustomAttribute` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAtSignToken: 
  ///   - atSignToken: The `@` sign.
  ///   - unexpectedBetweenAtSignTokenAndAttributeName: 
  ///   - attributeName: The name of the attribute.
  ///   - unexpectedBetweenAttributeNameAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: ExpressibleAsTypeBuildable, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAtSignToken = unexpectedBeforeAtSignToken?.createUnexpectedNodes()
    self.atSignToken = atSignToken
    assert(atSignToken.text == #"@"#)
    self.unexpectedBetweenAtSignTokenAndAttributeName = unexpectedBetweenAtSignTokenAndAttributeName?.createUnexpectedNodes()
    self.attributeName = attributeName.createTypeBuildable()
    self.unexpectedBetweenAttributeNameAndLeftParen = unexpectedBetweenAttributeNameAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgumentList = unexpectedBetweenLeftParenAndArgumentList?.createUnexpectedNodes()
    self.argumentList = argumentList?.createTupleExprElementList()
    self.unexpectedBetweenArgumentListAndRightParen = unexpectedBetweenArgumentListAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: ExpressibleAsTypeBuildable, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAtSignToken: unexpectedBeforeAtSignToken, atSignToken: atSignToken, unexpectedBetweenAtSignTokenAndAttributeName: unexpectedBetweenAtSignTokenAndAttributeName, attributeName: attributeName, unexpectedBetweenAttributeNameAndLeftParen: unexpectedBetweenAttributeNameAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen, rightParen: rightParen)
  }
  /// Builds a `CustomAttributeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CustomAttributeSyntax`.
  func buildCustomAttribute(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CustomAttributeSyntax {
    let result = CustomAttributeSyntax(unexpectedBeforeAtSignToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), atSignToken: atSignToken.buildToken(), unexpectedBetweenAtSignTokenAndAttributeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributeName: attributeName.buildType(format: format, leadingTrivia: nil), unexpectedBetweenAttributeNameAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen?.buildToken(), unexpectedBetweenLeftParenAndArgumentList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), argumentList: argumentList?.buildTupleExprElementList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentListAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCustomAttribute(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCustomAttribute`.
  public func createCustomAttribute() -> CustomAttribute {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CustomAttribute` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// An `@` attribute.
public struct Attribute: SyntaxBuildable, ExpressibleAsAttribute {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAtSignToken: UnexpectedNodes?
  let atSignToken: Token
  let unexpectedBetweenAtSignTokenAndAttributeName: UnexpectedNodes?
  let attributeName: Token
  let unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodes?
  let leftParen: Token?
  let unexpectedBetweenLeftParenAndArgument: UnexpectedNodes?
  let argument: SyntaxBuildable?
  let unexpectedBetweenArgumentAndRightParen: UnexpectedNodes?
  let rightParen: Token?
  let unexpectedBetweenRightParenAndTokenList: UnexpectedNodes?
  let tokenList: TokenList?
  /// Creates a `Attribute` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAtSignToken: 
  ///   - atSignToken: The `@` sign.
  ///   - unexpectedBetweenAtSignTokenAndAttributeName: 
  ///   - attributeName: The name of the attribute.
  ///   - unexpectedBetweenAttributeNameAndLeftParen: 
  ///   - leftParen: If the attribute takes arguments, the opening parenthesis.
  ///   - unexpectedBetweenLeftParenAndArgument: 
  ///   - argument: The arguments of the attribute. In case the attributetakes multiple arguments, they are gather in theappropriate takes first.
  ///   - unexpectedBetweenArgumentAndRightParen: 
  ///   - rightParen: If the attribute takes arguments, the closing parenthesis.
  ///   - unexpectedBetweenRightParenAndTokenList: 
  ///   - tokenList: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: Token, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgument: ExpressibleAsUnexpectedNodes? = nil, argument: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenArgumentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTokenList: ExpressibleAsUnexpectedNodes? = nil, tokenList: ExpressibleAsTokenList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAtSignToken = unexpectedBeforeAtSignToken?.createUnexpectedNodes()
    self.atSignToken = atSignToken
    assert(atSignToken.text == #"@"#)
    self.unexpectedBetweenAtSignTokenAndAttributeName = unexpectedBetweenAtSignTokenAndAttributeName?.createUnexpectedNodes()
    self.attributeName = attributeName
    self.unexpectedBetweenAttributeNameAndLeftParen = unexpectedBetweenAttributeNameAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndArgument = unexpectedBetweenLeftParenAndArgument?.createUnexpectedNodes()
    self.argument = argument?.createSyntaxBuildable()
    self.unexpectedBetweenArgumentAndRightParen = unexpectedBetweenArgumentAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.unexpectedBetweenRightParenAndTokenList = unexpectedBetweenRightParenAndTokenList?.createUnexpectedNodes()
    self.tokenList = tokenList?.createTokenList()
  }
  /// Builds a `AttributeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AttributeSyntax`.
  func buildAttribute(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AttributeSyntax {
    let result = AttributeSyntax(unexpectedBeforeAtSignToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), atSignToken: atSignToken.buildToken(), unexpectedBetweenAtSignTokenAndAttributeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributeName: attributeName.buildToken(), unexpectedBetweenAttributeNameAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen?.buildToken(), unexpectedBetweenLeftParenAndArgument?.buildUnexpectedNodes(format: format, leadingTrivia: nil), argument: argument?.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenArgumentAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen?.buildToken(), unexpectedBetweenRightParenAndTokenList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), tokenList: tokenList?.buildTokenList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAttribute(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAttribute`.
  public func createAttribute() -> Attribute {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `Attribute` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// The availability argument for the _specialize attribute
public struct AvailabilityEntry: SyntaxBuildable, ExpressibleAsAvailabilityEntry {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabel: UnexpectedNodes?
  let label: Token
  let unexpectedBetweenLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndAvailabilityList: UnexpectedNodes?
  let availabilityList: AvailabilitySpecList
  let unexpectedBetweenAvailabilityListAndSemicolon: UnexpectedNodes?
  let semicolon: Token
  /// Creates a `AvailabilityEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndAvailabilityList: 
  ///   - availabilityList: 
  ///   - unexpectedBetweenAvailabilityListAndSemicolon: 
  ///   - semicolon: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndAvailabilityList: ExpressibleAsUnexpectedNodes? = nil, availabilityList: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilityListAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token = Token.`semicolon`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndAvailabilityList = unexpectedBetweenColonAndAvailabilityList?.createUnexpectedNodes()
    self.availabilityList = availabilityList.createAvailabilitySpecList()
    self.unexpectedBetweenAvailabilityListAndSemicolon = unexpectedBetweenAvailabilityListAndSemicolon?.createUnexpectedNodes()
    self.semicolon = semicolon
    assert(semicolon.text == #";"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndAvailabilityList: ExpressibleAsUnexpectedNodes? = nil, availabilityList: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilityListAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token = Token.`semicolon`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndAvailabilityList: unexpectedBetweenColonAndAvailabilityList, availabilityList: availabilityList, unexpectedBetweenAvailabilityListAndSemicolon: unexpectedBetweenAvailabilityListAndSemicolon, semicolon: semicolon)
  }
  /// Builds a `AvailabilityEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityEntrySyntax`.
  func buildAvailabilityEntry(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AvailabilityEntrySyntax {
    let result = AvailabilityEntrySyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label.buildToken(), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndAvailabilityList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), availabilityList: availabilityList.buildAvailabilitySpecList(format: format, leadingTrivia: nil), unexpectedBetweenAvailabilityListAndSemicolon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), semicolon: semicolon.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAvailabilityEntry(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityEntry`.
  public func createAvailabilityEntry() -> AvailabilityEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A labeled argument for the `@_specialize` attribute like`exported: true`
public struct LabeledSpecializeEntry: SyntaxBuildable, ExpressibleAsLabeledSpecializeEntry, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabel: UnexpectedNodes?
  let label: Token
  let unexpectedBetweenLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndValue: UnexpectedNodes?
  let value: Token
  let unexpectedBetweenValueAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `LabeledSpecializeEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: The value for this argument
  ///   - unexpectedBetweenValueAndTrailingComma: 
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token, unexpectedBetweenValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValue = unexpectedBetweenColonAndValue?.createUnexpectedNodes()
    self.value = value
    self.unexpectedBetweenValueAndTrailingComma = unexpectedBetweenValueAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token, unexpectedBetweenValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value, unexpectedBetweenValueAndTrailingComma: unexpectedBetweenValueAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `LabeledSpecializeEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LabeledSpecializeEntrySyntax`.
  func buildLabeledSpecializeEntry(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> LabeledSpecializeEntrySyntax {
    let result = LabeledSpecializeEntrySyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label.buildToken(), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), value: value.buildToken(), unexpectedBetweenValueAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildLabeledSpecializeEntry(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsLabeledSpecializeEntry`.
  public func createLabeledSpecializeEntry() -> LabeledSpecializeEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `LabeledSpecializeEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeLabel: unexpectedBeforeLabel, label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value, unexpectedBetweenValueAndTrailingComma: unexpectedBetweenValueAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
/// A labeled argument for the `@_specialize` attribute with a functiondecl value like`target: myFunc(_:)`
public struct TargetFunctionEntry: SyntaxBuildable, ExpressibleAsTargetFunctionEntry, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabel: UnexpectedNodes?
  let label: Token
  let unexpectedBetweenLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndDeclname: UnexpectedNodes?
  let declname: DeclName
  let unexpectedBetweenDeclnameAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `TargetFunctionEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndDeclname: 
  ///   - declname: The value for this argument
  ///   - unexpectedBetweenDeclnameAndTrailingComma: 
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndDeclname: ExpressibleAsUnexpectedNodes? = nil, declname: ExpressibleAsDeclName, unexpectedBetweenDeclnameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndDeclname = unexpectedBetweenColonAndDeclname?.createUnexpectedNodes()
    self.declname = declname.createDeclName()
    self.unexpectedBetweenDeclnameAndTrailingComma = unexpectedBetweenDeclnameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndDeclname: ExpressibleAsUnexpectedNodes? = nil, declname: ExpressibleAsDeclName, unexpectedBetweenDeclnameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndDeclname: unexpectedBetweenColonAndDeclname, declname: declname, unexpectedBetweenDeclnameAndTrailingComma: unexpectedBetweenDeclnameAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `TargetFunctionEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TargetFunctionEntrySyntax`.
  func buildTargetFunctionEntry(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TargetFunctionEntrySyntax {
    let result = TargetFunctionEntrySyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label.buildToken(), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndDeclname?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declname: declname.buildDeclName(format: format, leadingTrivia: nil), unexpectedBetweenDeclnameAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTargetFunctionEntry(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTargetFunctionEntry`.
  public func createTargetFunctionEntry() -> TargetFunctionEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TargetFunctionEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeLabel: unexpectedBeforeLabel, label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndDeclname: unexpectedBetweenColonAndDeclname, declname: declname, unexpectedBetweenDeclnameAndTrailingComma: unexpectedBetweenDeclnameAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
/// The argument for the `@_dynamic_replacement` or `@_private`attribute of the form `for: "function()"` or `sourceFile:"Src.swift"`
public struct NamedAttributeStringArgument: SyntaxBuildable, ExpressibleAsNamedAttributeStringArgument {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeNameTok: UnexpectedNodes?
  let nameTok: Token
  let unexpectedBetweenNameTokAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndStringOrDeclname: UnexpectedNodes?
  let stringOrDeclname: SyntaxBuildable
  /// Creates a `NamedAttributeStringArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeNameTok: 
  ///   - nameTok: The label of the argument
  ///   - unexpectedBetweenNameTokAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndStringOrDeclname: 
  ///   - stringOrDeclname: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeNameTok: ExpressibleAsUnexpectedNodes? = nil, nameTok: Token, unexpectedBetweenNameTokAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndStringOrDeclname: ExpressibleAsUnexpectedNodes? = nil, stringOrDeclname: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeNameTok = unexpectedBeforeNameTok?.createUnexpectedNodes()
    self.nameTok = nameTok
    self.unexpectedBetweenNameTokAndColon = unexpectedBetweenNameTokAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndStringOrDeclname = unexpectedBetweenColonAndStringOrDeclname?.createUnexpectedNodes()
    self.stringOrDeclname = stringOrDeclname.createSyntaxBuildable()
  }
  /// Builds a `NamedAttributeStringArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NamedAttributeStringArgumentSyntax`.
  func buildNamedAttributeStringArgument(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> NamedAttributeStringArgumentSyntax {
    let result = NamedAttributeStringArgumentSyntax(unexpectedBeforeNameTok?.buildUnexpectedNodes(format: format, leadingTrivia: nil), nameTok: nameTok.buildToken(), unexpectedBetweenNameTokAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndStringOrDeclname?.buildUnexpectedNodes(format: format, leadingTrivia: nil), stringOrDeclname: stringOrDeclname.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildNamedAttributeStringArgument(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsNamedAttributeStringArgument`.
  public func createNamedAttributeStringArgument() -> NamedAttributeStringArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `NamedAttributeStringArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeclName: SyntaxBuildable, ExpressibleAsDeclName {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDeclBaseName: UnexpectedNodes?
  let declBaseName: SyntaxBuildable
  let unexpectedBetweenDeclBaseNameAndDeclNameArguments: UnexpectedNodes?
  let declNameArguments: DeclNameArguments?
  /// Creates a `DeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeclBaseName: 
  ///   - declBaseName: The base name of the protocol's requirement.
  ///   - unexpectedBetweenDeclBaseNameAndDeclNameArguments: 
  ///   - declNameArguments: The argument labels of the protocol's requirement if itis a function requirement.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDeclBaseName: ExpressibleAsUnexpectedNodes? = nil, declBaseName: ExpressibleAsSyntaxBuildable, unexpectedBetweenDeclBaseNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDeclBaseName = unexpectedBeforeDeclBaseName?.createUnexpectedNodes()
    self.declBaseName = declBaseName.createSyntaxBuildable()
    self.unexpectedBetweenDeclBaseNameAndDeclNameArguments = unexpectedBetweenDeclBaseNameAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `DeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameSyntax`.
  func buildDeclName(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclNameSyntax {
    let result = DeclNameSyntax(unexpectedBeforeDeclBaseName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declBaseName: declBaseName.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenDeclBaseNameAndDeclNameArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDeclName(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclName`.
  public func createDeclName() -> DeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// The arguments for the `@_implements` attribute of the form`Type, methodName(arg1Label:arg2Label:)`
public struct ImplementsAttributeArguments: SyntaxBuildable, ExpressibleAsImplementsAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeType: UnexpectedNodes?
  let type: SimpleTypeIdentifier
  let unexpectedBetweenTypeAndComma: UnexpectedNodes?
  let comma: Token
  let unexpectedBetweenCommaAndDeclBaseName: UnexpectedNodes?
  let declBaseName: SyntaxBuildable
  let unexpectedBetweenDeclBaseNameAndDeclNameArguments: UnexpectedNodes?
  let declNameArguments: DeclNameArguments?
  /// Creates a `ImplementsAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: The type for which the method with this attributeimplements a requirement.
  ///   - unexpectedBetweenTypeAndComma: 
  ///   - comma: The comma separating the type and method name
  ///   - unexpectedBetweenCommaAndDeclBaseName: 
  ///   - declBaseName: The base name of the protocol's requirement.
  ///   - unexpectedBetweenDeclBaseNameAndDeclNameArguments: 
  ///   - declNameArguments: The argument labels of the protocol's requirement if itis a function requirement.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsSimpleTypeIdentifier, unexpectedBetweenTypeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndDeclBaseName: ExpressibleAsUnexpectedNodes? = nil, declBaseName: ExpressibleAsSyntaxBuildable, unexpectedBetweenDeclBaseNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type.createSimpleTypeIdentifier()
    self.unexpectedBetweenTypeAndComma = unexpectedBetweenTypeAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma.text == #","#)
    self.unexpectedBetweenCommaAndDeclBaseName = unexpectedBetweenCommaAndDeclBaseName?.createUnexpectedNodes()
    self.declBaseName = declBaseName.createSyntaxBuildable()
    self.unexpectedBetweenDeclBaseNameAndDeclNameArguments = unexpectedBetweenDeclBaseNameAndDeclNameArguments?.createUnexpectedNodes()
    self.declNameArguments = declNameArguments?.createDeclNameArguments()
  }
  /// Builds a `ImplementsAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImplementsAttributeArgumentsSyntax`.
  func buildImplementsAttributeArguments(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ImplementsAttributeArgumentsSyntax {
    let result = ImplementsAttributeArgumentsSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildSimpleTypeIdentifier(format: format, leadingTrivia: nil), unexpectedBetweenTypeAndComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), comma: comma.buildToken(), unexpectedBetweenCommaAndDeclBaseName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declBaseName: declBaseName.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenDeclBaseNameAndDeclNameArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declNameArguments: declNameArguments?.buildDeclNameArguments(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildImplementsAttributeArguments(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsImplementsAttributeArguments`.
  public func createImplementsAttributeArguments() -> ImplementsAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ImplementsAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A piece of an Objective-C selector. Either consisting of just anidentifier for a nullary selector, an identifier and a colon for alabeled argument or just a colon for an unlabeled argument
public struct ObjCSelectorPiece: SyntaxBuildable, ExpressibleAsObjCSelectorPiece {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token?
  let unexpectedBetweenNameAndColon: UnexpectedNodes?
  let colon: Token?
  /// Creates a `ObjCSelectorPiece` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndColon = unexpectedBetweenNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String?, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: name.map {
      Token.`identifier`($0)
    }, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon)
  }
  /// Builds a `ObjCSelectorPieceSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjCSelectorPieceSyntax`.
  func buildObjCSelectorPiece(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ObjCSelectorPieceSyntax {
    let result = ObjCSelectorPieceSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name?.buildToken(), unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildObjCSelectorPiece(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsObjCSelectorPiece`.
  public func createObjCSelectorPiece() -> ObjCSelectorPiece {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ObjCSelectorPiece` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// The arguments for the `@differentiable` attribute: an optionaldifferentiability kind, an optional differentiability parameter clause,and an optional 'where' clause.
public struct DifferentiableAttributeArguments: SyntaxBuildable, ExpressibleAsDifferentiableAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDiffKind: UnexpectedNodes?
  let diffKind: Token?
  let unexpectedBetweenDiffKindAndDiffKindComma: UnexpectedNodes?
  let diffKindComma: Token?
  let unexpectedBetweenDiffKindCommaAndDiffParams: UnexpectedNodes?
  let diffParams: DifferentiabilityParamsClause?
  let unexpectedBetweenDiffParamsAndDiffParamsComma: UnexpectedNodes?
  let diffParamsComma: Token?
  let unexpectedBetweenDiffParamsCommaAndWhereClause: UnexpectedNodes?
  let whereClause: GenericWhereClause?
  /// Creates a `DifferentiableAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDiffKind: 
  ///   - diffKind: 
  ///   - unexpectedBetweenDiffKindAndDiffKindComma: 
  ///   - diffKindComma: The comma following the differentiability kind, if it exists.
  ///   - unexpectedBetweenDiffKindCommaAndDiffParams: 
  ///   - diffParams: 
  ///   - unexpectedBetweenDiffParamsAndDiffParamsComma: 
  ///   - diffParamsComma: The comma following the differentiability parameters clause,if it exists.
  ///   - unexpectedBetweenDiffParamsCommaAndWhereClause: 
  ///   - whereClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDiffKind: ExpressibleAsUnexpectedNodes? = nil, diffKind: Token? = nil, unexpectedBetweenDiffKindAndDiffKindComma: ExpressibleAsUnexpectedNodes? = nil, diffKindComma: Token? = nil, unexpectedBetweenDiffKindCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil, unexpectedBetweenDiffParamsAndDiffParamsComma: ExpressibleAsUnexpectedNodes? = nil, diffParamsComma: Token? = nil, unexpectedBetweenDiffParamsCommaAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDiffKind = unexpectedBeforeDiffKind?.createUnexpectedNodes()
    self.diffKind = diffKind
    assert(diffKind == nil || diffKind!.text == #"forward"# || diffKind!.text == #"reverse"# || diffKind!.text == #"linear"#)
    self.unexpectedBetweenDiffKindAndDiffKindComma = unexpectedBetweenDiffKindAndDiffKindComma?.createUnexpectedNodes()
    self.diffKindComma = diffKindComma
    assert(diffKindComma == nil || diffKindComma!.text == #","#)
    self.unexpectedBetweenDiffKindCommaAndDiffParams = unexpectedBetweenDiffKindCommaAndDiffParams?.createUnexpectedNodes()
    self.diffParams = diffParams?.createDifferentiabilityParamsClause()
    self.unexpectedBetweenDiffParamsAndDiffParamsComma = unexpectedBetweenDiffParamsAndDiffParamsComma?.createUnexpectedNodes()
    self.diffParamsComma = diffParamsComma
    assert(diffParamsComma == nil || diffParamsComma!.text == #","#)
    self.unexpectedBetweenDiffParamsCommaAndWhereClause = unexpectedBetweenDiffParamsCommaAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createGenericWhereClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDiffKind: ExpressibleAsUnexpectedNodes? = nil, diffKind: String?, unexpectedBetweenDiffKindAndDiffKindComma: ExpressibleAsUnexpectedNodes? = nil, diffKindComma: Token? = nil, unexpectedBetweenDiffKindCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil, unexpectedBetweenDiffParamsAndDiffParamsComma: ExpressibleAsUnexpectedNodes? = nil, diffParamsComma: Token? = nil, unexpectedBetweenDiffParamsCommaAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDiffKind: unexpectedBeforeDiffKind, diffKind: diffKind.map {
      Token.`identifier`($0)
    }, unexpectedBetweenDiffKindAndDiffKindComma: unexpectedBetweenDiffKindAndDiffKindComma, diffKindComma: diffKindComma, unexpectedBetweenDiffKindCommaAndDiffParams: unexpectedBetweenDiffKindCommaAndDiffParams, diffParams: diffParams, unexpectedBetweenDiffParamsAndDiffParamsComma: unexpectedBetweenDiffParamsAndDiffParamsComma, diffParamsComma: diffParamsComma, unexpectedBetweenDiffParamsCommaAndWhereClause: unexpectedBetweenDiffParamsCommaAndWhereClause, whereClause: whereClause)
  }
  /// Builds a `DifferentiableAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiableAttributeArgumentsSyntax`.
  func buildDifferentiableAttributeArguments(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DifferentiableAttributeArgumentsSyntax {
    let result = DifferentiableAttributeArgumentsSyntax(unexpectedBeforeDiffKind?.buildUnexpectedNodes(format: format, leadingTrivia: nil), diffKind: diffKind?.buildToken(), unexpectedBetweenDiffKindAndDiffKindComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), diffKindComma: diffKindComma?.buildToken(), unexpectedBetweenDiffKindCommaAndDiffParams?.buildUnexpectedNodes(format: format, leadingTrivia: nil), diffParams: diffParams?.buildDifferentiabilityParamsClause(format: format, leadingTrivia: nil), unexpectedBetweenDiffParamsAndDiffParamsComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), diffParamsComma: diffParamsComma?.buildToken(), unexpectedBetweenDiffParamsCommaAndWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whereClause: whereClause?.buildGenericWhereClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDifferentiableAttributeArguments(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiableAttributeArguments`.
  public func createDifferentiableAttributeArguments() -> DifferentiableAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiableAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A clause containing differentiability parameters.
public struct DifferentiabilityParamsClause: SyntaxBuildable, ExpressibleAsDifferentiabilityParamsClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWrtLabel: UnexpectedNodes?
  let wrtLabel: Token
  let unexpectedBetweenWrtLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndParameters: UnexpectedNodes?
  let parameters: SyntaxBuildable
  /// Creates a `DifferentiabilityParamsClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrtLabel: 
  ///   - wrtLabel: The "wrt" label.
  ///   - unexpectedBetweenWrtLabelAndColon: 
  ///   - colon: The colon separating "wrt" and the parameter list.
  ///   - unexpectedBetweenColonAndParameters: 
  ///   - parameters: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWrtLabel: ExpressibleAsUnexpectedNodes? = nil, wrtLabel: Token, unexpectedBetweenWrtLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndParameters: ExpressibleAsUnexpectedNodes? = nil, parameters: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWrtLabel = unexpectedBeforeWrtLabel?.createUnexpectedNodes()
    self.wrtLabel = wrtLabel
    assert(wrtLabel.text == #"wrt"#)
    self.unexpectedBetweenWrtLabelAndColon = unexpectedBetweenWrtLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndParameters = unexpectedBetweenColonAndParameters?.createUnexpectedNodes()
    self.parameters = parameters.createSyntaxBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWrtLabel: ExpressibleAsUnexpectedNodes? = nil, wrtLabel: String, unexpectedBetweenWrtLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndParameters: ExpressibleAsUnexpectedNodes? = nil, parameters: ExpressibleAsSyntaxBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWrtLabel: unexpectedBeforeWrtLabel, wrtLabel: Token.`identifier`(wrtLabel), unexpectedBetweenWrtLabelAndColon: unexpectedBetweenWrtLabelAndColon, colon: colon, unexpectedBetweenColonAndParameters: unexpectedBetweenColonAndParameters, parameters: parameters)
  }
  /// Builds a `DifferentiabilityParamsClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamsClauseSyntax`.
  func buildDifferentiabilityParamsClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DifferentiabilityParamsClauseSyntax {
    let result = DifferentiabilityParamsClauseSyntax(unexpectedBeforeWrtLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), wrtLabel: wrtLabel.buildToken(), unexpectedBetweenWrtLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndParameters?.buildUnexpectedNodes(format: format, leadingTrivia: nil), parameters: parameters.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDifferentiabilityParamsClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParamsClause`.
  public func createDifferentiabilityParamsClause() -> DifferentiabilityParamsClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParamsClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// The differentiability parameters.
public struct DifferentiabilityParams: SyntaxBuildable, ExpressibleAsDifferentiabilityParams {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndDiffParams: UnexpectedNodes?
  let diffParams: DifferentiabilityParamList
  let unexpectedBetweenDiffParamsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `DifferentiabilityParams` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndDiffParams: 
  ///   - diffParams: The parameters for differentiation.
  ///   - unexpectedBetweenDiffParamsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamList, unexpectedBetweenDiffParamsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndDiffParams = unexpectedBetweenLeftParenAndDiffParams?.createUnexpectedNodes()
    self.diffParams = diffParams.createDifferentiabilityParamList()
    self.unexpectedBetweenDiffParamsAndRightParen = unexpectedBetweenDiffParamsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `DifferentiabilityParamsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamsSyntax`.
  func buildDifferentiabilityParams(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DifferentiabilityParamsSyntax {
    let result = DifferentiabilityParamsSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndDiffParams?.buildUnexpectedNodes(format: format, leadingTrivia: nil), diffParams: diffParams.buildDifferentiabilityParamList(format: format, leadingTrivia: nil), unexpectedBetweenDiffParamsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDifferentiabilityParams(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParams`.
  public func createDifferentiabilityParams() -> DifferentiabilityParams {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParams` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A differentiability parameter: either the "self" identifier, a functionparameter name, or a function parameter index.
public struct DifferentiabilityParam: SyntaxBuildable, ExpressibleAsDifferentiabilityParam, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeParameter: UnexpectedNodes?
  let parameter: SyntaxBuildable
  let unexpectedBetweenParameterAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `DifferentiabilityParam` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeParameter: 
  ///   - parameter: 
  ///   - unexpectedBetweenParameterAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsSyntaxBuildable, unexpectedBetweenParameterAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeParameter = unexpectedBeforeParameter?.createUnexpectedNodes()
    self.parameter = parameter.createSyntaxBuildable()
    self.unexpectedBetweenParameterAndTrailingComma = unexpectedBetweenParameterAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `DifferentiabilityParamSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamSyntax`.
  func buildDifferentiabilityParam(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DifferentiabilityParamSyntax {
    let result = DifferentiabilityParamSyntax(unexpectedBeforeParameter?.buildUnexpectedNodes(format: format, leadingTrivia: nil), parameter: parameter.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenParameterAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDifferentiabilityParam(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParam`.
  public func createDifferentiabilityParam() -> DifferentiabilityParam {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParam` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeParameter: unexpectedBeforeParameter, parameter: parameter, unexpectedBetweenParameterAndTrailingComma: unexpectedBetweenParameterAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
/// The arguments for the '@derivative(of:)' and '@transpose(of:)'attributes: the 'of:' label, the original declaration name, and anoptional differentiability parameter list.
public struct DerivativeRegistrationAttributeArguments: SyntaxBuildable, ExpressibleAsDerivativeRegistrationAttributeArguments {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeOfLabel: UnexpectedNodes?
  let ofLabel: Token
  let unexpectedBetweenOfLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndOriginalDeclName: UnexpectedNodes?
  let originalDeclName: QualifiedDeclName
  let unexpectedBetweenOriginalDeclNameAndPeriod: UnexpectedNodes?
  let period: Token?
  let unexpectedBetweenPeriodAndAccessorKind: UnexpectedNodes?
  let accessorKind: Token?
  let unexpectedBetweenAccessorKindAndComma: UnexpectedNodes?
  let comma: Token?
  let unexpectedBetweenCommaAndDiffParams: UnexpectedNodes?
  let diffParams: DifferentiabilityParamsClause?
  /// Creates a `DerivativeRegistrationAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOfLabel: 
  ///   - ofLabel: The "of" label.
  ///   - unexpectedBetweenOfLabelAndColon: 
  ///   - colon: The colon separating the "of" label and the originaldeclaration name.
  ///   - unexpectedBetweenColonAndOriginalDeclName: 
  ///   - originalDeclName: The referenced original declaration name.
  ///   - unexpectedBetweenOriginalDeclNameAndPeriod: 
  ///   - period: The period separating the original declaration name and theaccessor name.
  ///   - unexpectedBetweenPeriodAndAccessorKind: 
  ///   - accessorKind: The accessor name.
  ///   - unexpectedBetweenAccessorKindAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndDiffParams: 
  ///   - diffParams: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOfLabel: ExpressibleAsUnexpectedNodes? = nil, ofLabel: Token, unexpectedBetweenOfLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOriginalDeclName: ExpressibleAsUnexpectedNodes? = nil, originalDeclName: ExpressibleAsQualifiedDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token? = nil, unexpectedBetweenAccessorKindAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeOfLabel = unexpectedBeforeOfLabel?.createUnexpectedNodes()
    self.ofLabel = ofLabel
    assert(ofLabel.text == #"of"#)
    self.unexpectedBetweenOfLabelAndColon = unexpectedBetweenOfLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndOriginalDeclName = unexpectedBetweenColonAndOriginalDeclName?.createUnexpectedNodes()
    self.originalDeclName = originalDeclName.createQualifiedDeclName()
    self.unexpectedBetweenOriginalDeclNameAndPeriod = unexpectedBetweenOriginalDeclNameAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period == nil || period!.text == #"."#)
    self.unexpectedBetweenPeriodAndAccessorKind = unexpectedBetweenPeriodAndAccessorKind?.createUnexpectedNodes()
    self.accessorKind = accessorKind
    assert(accessorKind == nil || accessorKind!.text == #"get"# || accessorKind!.text == #"set"#)
    self.unexpectedBetweenAccessorKindAndComma = unexpectedBetweenAccessorKindAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndDiffParams = unexpectedBetweenCommaAndDiffParams?.createUnexpectedNodes()
    self.diffParams = diffParams?.createDifferentiabilityParamsClause()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOfLabel: ExpressibleAsUnexpectedNodes? = nil, ofLabel: String, unexpectedBetweenOfLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOriginalDeclName: ExpressibleAsUnexpectedNodes? = nil, originalDeclName: ExpressibleAsQualifiedDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: String?, unexpectedBetweenAccessorKindAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOfLabel: unexpectedBeforeOfLabel, ofLabel: Token.`identifier`(ofLabel), unexpectedBetweenOfLabelAndColon: unexpectedBetweenOfLabelAndColon, colon: colon, unexpectedBetweenColonAndOriginalDeclName: unexpectedBetweenColonAndOriginalDeclName, originalDeclName: originalDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: unexpectedBetweenOriginalDeclNameAndPeriod, period: period, unexpectedBetweenPeriodAndAccessorKind: unexpectedBetweenPeriodAndAccessorKind, accessorKind: accessorKind.map {
      Token.`identifier`($0)
    }, unexpectedBetweenAccessorKindAndComma: unexpectedBetweenAccessorKindAndComma, comma: comma, unexpectedBetweenCommaAndDiffParams: unexpectedBetweenCommaAndDiffParams, diffParams: diffParams)
  }
  /// Builds a `DerivativeRegistrationAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DerivativeRegistrationAttributeArgumentsSyntax`.
  func buildDerivativeRegistrationAttributeArguments(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DerivativeRegistrationAttributeArgumentsSyntax {
    let result = DerivativeRegistrationAttributeArgumentsSyntax(unexpectedBeforeOfLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ofLabel: ofLabel.buildToken(), unexpectedBetweenOfLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndOriginalDeclName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), originalDeclName: originalDeclName.buildQualifiedDeclName(format: format, leadingTrivia: nil), unexpectedBetweenOriginalDeclNameAndPeriod?.buildUnexpectedNodes(format: format, leadingTrivia: nil), period: period?.buildToken(), unexpectedBetweenPeriodAndAccessorKind?.buildUnexpectedNodes(format: format, leadingTrivia: nil), accessorKind: accessorKind?.buildToken(), unexpectedBetweenAccessorKindAndComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), comma: comma?.buildToken(), unexpectedBetweenCommaAndDiffParams?.buildUnexpectedNodes(format: format, leadingTrivia: nil), diffParams: diffParams?.buildDifferentiabilityParamsClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildDerivativeRegistrationAttributeArguments(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDerivativeRegistrationAttributeArguments`.
  public func createDerivativeRegistrationAttributeArguments() -> DerivativeRegistrationAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DerivativeRegistrationAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// An optionally qualified function declaration name (e.g. `+(_:_:)`,`A.B.C.foo(_:_:)`).
public struct QualifiedDeclName: SyntaxBuildable, ExpressibleAsQualifiedDeclName {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBaseType: UnexpectedNodes?
  let baseType: TypeBuildable?
  let unexpectedBetweenBaseTypeAndDot: UnexpectedNodes?
  let dot: Token?
  let unexpectedBetweenDotAndName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndArguments: UnexpectedNodes?
  let arguments: DeclNameArguments?
  /// Creates a `QualifiedDeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: The base type of the qualified name, optionally specified.
  ///   - unexpectedBetweenBaseTypeAndDot: 
  ///   - dot: 
  ///   - unexpectedBetweenDotAndName: 
  ///   - name: The base name of the referenced function.
  ///   - unexpectedBetweenNameAndArguments: 
  ///   - arguments: The argument labels of the referenced function, optionallyspecified.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenBaseTypeAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil, unexpectedBetweenDotAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBaseType = unexpectedBeforeBaseType?.createUnexpectedNodes()
    self.baseType = baseType?.createTypeBuildable()
    self.unexpectedBetweenBaseTypeAndDot = unexpectedBetweenBaseTypeAndDot?.createUnexpectedNodes()
    self.dot = dot
    assert(dot == nil || dot!.text == #"."# || dot!.text == #"."#)
    self.unexpectedBetweenDotAndName = unexpectedBetweenDotAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndArguments = unexpectedBetweenNameAndArguments?.createUnexpectedNodes()
    self.arguments = arguments?.createDeclNameArguments()
  }
  /// Builds a `QualifiedDeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `QualifiedDeclNameSyntax`.
  func buildQualifiedDeclName(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> QualifiedDeclNameSyntax {
    let result = QualifiedDeclNameSyntax(unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), baseType: baseType?.buildType(format: format, leadingTrivia: nil), unexpectedBetweenBaseTypeAndDot?.buildUnexpectedNodes(format: format, leadingTrivia: nil), dot: dot?.buildToken(), unexpectedBetweenDotAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arguments: arguments?.buildDeclNameArguments(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildQualifiedDeclName(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsQualifiedDeclName`.
  public func createQualifiedDeclName() -> QualifiedDeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `QualifiedDeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A function declaration name (e.g. `foo(_:_:)`).
public struct FunctionDeclName: SyntaxBuildable, ExpressibleAsFunctionDeclName {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: SyntaxBuildable
  let unexpectedBetweenNameAndArguments: UnexpectedNodes?
  let arguments: DeclNameArguments?
  /// Creates a `FunctionDeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: The base name of the referenced function.
  ///   - unexpectedBetweenNameAndArguments: 
  ///   - arguments: The argument labels of the referenced function, optionallyspecified.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsSyntaxBuildable, unexpectedBetweenNameAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArguments? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name.createSyntaxBuildable()
    self.unexpectedBetweenNameAndArguments = unexpectedBetweenNameAndArguments?.createUnexpectedNodes()
    self.arguments = arguments?.createDeclNameArguments()
  }
  /// Builds a `FunctionDeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionDeclNameSyntax`.
  func buildFunctionDeclName(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FunctionDeclNameSyntax {
    let result = FunctionDeclNameSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenNameAndArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arguments: arguments?.buildDeclNameArguments(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildFunctionDeclName(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionDeclName`.
  public func createFunctionDeclName() -> FunctionDeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionDeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A collection of arguments for the `@_backDeploy` attribute
public struct BackDeployAttributeSpecList: SyntaxBuildable, ExpressibleAsBackDeployAttributeSpecList {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBeforeLabel: UnexpectedNodes?
  let beforeLabel: Token
  let unexpectedBetweenBeforeLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndVersionList: UnexpectedNodes?
  let versionList: BackDeployVersionList
  /// Creates a `BackDeployAttributeSpecList` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBeforeLabel: 
  ///   - beforeLabel: The "before" label.
  ///   - unexpectedBetweenBeforeLabelAndColon: 
  ///   - colon: The colon separating "before" and the parameter list.
  ///   - unexpectedBetweenColonAndVersionList: 
  ///   - versionList: The list of OS versions in which the declaration became ABIstable.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, beforeLabel: Token, unexpectedBetweenBeforeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndVersionList: ExpressibleAsUnexpectedNodes? = nil, versionList: ExpressibleAsBackDeployVersionList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBeforeLabel = unexpectedBeforeBeforeLabel?.createUnexpectedNodes()
    self.beforeLabel = beforeLabel
    assert(beforeLabel.text == #"before"#)
    self.unexpectedBetweenBeforeLabelAndColon = unexpectedBetweenBeforeLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndVersionList = unexpectedBetweenColonAndVersionList?.createUnexpectedNodes()
    self.versionList = versionList.createBackDeployVersionList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, beforeLabel: String, unexpectedBetweenBeforeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndVersionList: ExpressibleAsUnexpectedNodes? = nil, versionList: ExpressibleAsBackDeployVersionList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBeforeLabel: unexpectedBeforeBeforeLabel, beforeLabel: Token.`identifier`(beforeLabel), unexpectedBetweenBeforeLabelAndColon: unexpectedBetweenBeforeLabelAndColon, colon: colon, unexpectedBetweenColonAndVersionList: unexpectedBetweenColonAndVersionList, versionList: versionList)
  }
  /// Builds a `BackDeployAttributeSpecListSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BackDeployAttributeSpecListSyntax`.
  func buildBackDeployAttributeSpecList(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> BackDeployAttributeSpecListSyntax {
    let result = BackDeployAttributeSpecListSyntax(unexpectedBeforeBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), beforeLabel: beforeLabel.buildToken(), unexpectedBetweenBeforeLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndVersionList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), versionList: versionList.buildBackDeployVersionList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildBackDeployAttributeSpecList(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsBackDeployAttributeSpecList`.
  public func createBackDeployAttributeSpecList() -> BackDeployAttributeSpecList {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `BackDeployAttributeSpecList` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A single platform/version pair in a `@_backDeploy` attribute,e.g. `iOS 10.1`.
public struct BackDeployVersionArgument: SyntaxBuildable, ExpressibleAsBackDeployVersionArgument {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAvailabilityVersionRestriction: UnexpectedNodes?
  let availabilityVersionRestriction: AvailabilityVersionRestriction
  let unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `BackDeployVersionArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAvailabilityVersionRestriction: 
  ///   - availabilityVersionRestriction: 
  ///   - unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: 
  ///   - trailingComma: A trailing comma if the argument is followed by anotherargument
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAvailabilityVersionRestriction: ExpressibleAsUnexpectedNodes? = nil, availabilityVersionRestriction: ExpressibleAsAvailabilityVersionRestriction, unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAvailabilityVersionRestriction = unexpectedBeforeAvailabilityVersionRestriction?.createUnexpectedNodes()
    self.availabilityVersionRestriction = availabilityVersionRestriction.createAvailabilityVersionRestriction()
    self.unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma = unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `BackDeployVersionArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BackDeployVersionArgumentSyntax`.
  func buildBackDeployVersionArgument(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> BackDeployVersionArgumentSyntax {
    let result = BackDeployVersionArgumentSyntax(unexpectedBeforeAvailabilityVersionRestriction?.buildUnexpectedNodes(format: format, leadingTrivia: nil), availabilityVersionRestriction: availabilityVersionRestriction.buildAvailabilityVersionRestriction(format: format, leadingTrivia: nil), unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildBackDeployVersionArgument(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsBackDeployVersionArgument`.
  public func createBackDeployVersionArgument() -> BackDeployVersionArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `BackDeployVersionArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct LabeledStmt: StmtBuildable, ExpressibleAsLabeledStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabelName: UnexpectedNodes?
  let labelName: Token
  let unexpectedBetweenLabelNameAndLabelColon: UnexpectedNodes?
  let labelColon: Token
  let unexpectedBetweenLabelColonAndStatement: UnexpectedNodes?
  let statement: StmtBuildable
  /// Creates a `LabeledStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabelName: 
  ///   - labelName: 
  ///   - unexpectedBetweenLabelNameAndLabelColon: 
  ///   - labelColon: 
  ///   - unexpectedBetweenLabelColonAndStatement: 
  ///   - statement: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: Token, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token = Token.`colon`, unexpectedBetweenLabelColonAndStatement: ExpressibleAsUnexpectedNodes? = nil, statement: ExpressibleAsStmtBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabelName = unexpectedBeforeLabelName?.createUnexpectedNodes()
    self.labelName = labelName
    self.unexpectedBetweenLabelNameAndLabelColon = unexpectedBetweenLabelNameAndLabelColon?.createUnexpectedNodes()
    self.labelColon = labelColon
    assert(labelColon.text == #":"#)
    self.unexpectedBetweenLabelColonAndStatement = unexpectedBetweenLabelColonAndStatement?.createUnexpectedNodes()
    self.statement = statement.createStmtBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: String, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token = Token.`colon`, unexpectedBetweenLabelColonAndStatement: ExpressibleAsUnexpectedNodes? = nil, statement: ExpressibleAsStmtBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: Token.`identifier`(labelName), unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndStatement: unexpectedBetweenLabelColonAndStatement, statement: statement)
  }
  /// Builds a `LabeledStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LabeledStmtSyntax`.
  func buildLabeledStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> LabeledStmtSyntax {
    let result = LabeledStmtSyntax(unexpectedBeforeLabelName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), labelName: labelName.buildToken(), unexpectedBetweenLabelNameAndLabelColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), labelColon: labelColon.buildToken(), unexpectedBetweenLabelColonAndStatement?.buildUnexpectedNodes(format: format, leadingTrivia: nil), statement: statement.buildStmt(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildLabeledStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsLabeledStmt`.
  public func createLabeledStmt() -> LabeledStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `LabeledStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ContinueStmt: StmtBuildable, ExpressibleAsContinueStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeContinueKeyword: UnexpectedNodes?
  let continueKeyword: Token
  let unexpectedBetweenContinueKeywordAndLabel: UnexpectedNodes?
  let label: Token?
  /// Creates a `ContinueStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeContinueKeyword: 
  ///   - continueKeyword: 
  ///   - unexpectedBetweenContinueKeywordAndLabel: 
  ///   - label: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContinueKeyword: ExpressibleAsUnexpectedNodes? = nil, continueKeyword: Token = Token.`continue`, unexpectedBetweenContinueKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeContinueKeyword = unexpectedBeforeContinueKeyword?.createUnexpectedNodes()
    self.continueKeyword = continueKeyword
    assert(continueKeyword.text == #"continue"#)
    self.unexpectedBetweenContinueKeywordAndLabel = unexpectedBetweenContinueKeywordAndLabel?.createUnexpectedNodes()
    self.label = label
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContinueKeyword: ExpressibleAsUnexpectedNodes? = nil, continueKeyword: Token = Token.`continue`, unexpectedBetweenContinueKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeContinueKeyword: unexpectedBeforeContinueKeyword, continueKeyword: continueKeyword, unexpectedBetweenContinueKeywordAndLabel: unexpectedBetweenContinueKeywordAndLabel, label: label.map {
      Token.`identifier`($0)
    })
  }
  /// Builds a `ContinueStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ContinueStmtSyntax`.
  func buildContinueStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ContinueStmtSyntax {
    let result = ContinueStmtSyntax(unexpectedBeforeContinueKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), continueKeyword: continueKeyword.buildToken(), unexpectedBetweenContinueKeywordAndLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildContinueStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsContinueStmt`.
  public func createContinueStmt() -> ContinueStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ContinueStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct WhileStmt: StmtBuildable, ExpressibleAsWhileStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWhileKeyword: UnexpectedNodes?
  let whileKeyword: Token
  let unexpectedBetweenWhileKeywordAndConditions: UnexpectedNodes?
  let conditions: ConditionElementList
  let unexpectedBetweenConditionsAndBody: UnexpectedNodes?
  let body: CodeBlock
  /// Creates a `WhileStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhileKeyword: 
  ///   - whileKeyword: 
  ///   - unexpectedBetweenWhileKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWhileKeyword = unexpectedBeforeWhileKeyword?.createUnexpectedNodes()
    self.whileKeyword = whileKeyword
    assert(whileKeyword.text == #"while"#)
    self.unexpectedBetweenWhileKeywordAndConditions = unexpectedBetweenWhileKeywordAndConditions?.createUnexpectedNodes()
    self.conditions = conditions.createConditionElementList()
    self.unexpectedBetweenConditionsAndBody = unexpectedBetweenConditionsAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWhileKeyword: unexpectedBeforeWhileKeyword, whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndConditions: unexpectedBetweenWhileKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody, body: bodyBuilder())
  }
  /// Builds a `WhileStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WhileStmtSyntax`.
  func buildWhileStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> WhileStmtSyntax {
    let result = WhileStmtSyntax(unexpectedBeforeWhileKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whileKeyword: whileKeyword.buildToken(), unexpectedBetweenWhileKeywordAndConditions?.buildUnexpectedNodes(format: format, leadingTrivia: nil), conditions: conditions.buildConditionElementList(format: format, leadingTrivia: nil), unexpectedBetweenConditionsAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildWhileStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsWhileStmt`.
  public func createWhileStmt() -> WhileStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `WhileStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeferStmt: StmtBuildable, ExpressibleAsDeferStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDeferKeyword: UnexpectedNodes?
  let deferKeyword: Token
  let unexpectedBetweenDeferKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock
  /// Creates a `DeferStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeferKeyword: 
  ///   - deferKeyword: 
  ///   - unexpectedBetweenDeferKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDeferKeyword: ExpressibleAsUnexpectedNodes? = nil, deferKeyword: Token = Token.`defer`, unexpectedBetweenDeferKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDeferKeyword = unexpectedBeforeDeferKeyword?.createUnexpectedNodes()
    self.deferKeyword = deferKeyword
    assert(deferKeyword.text == #"defer"#)
    self.unexpectedBetweenDeferKeywordAndBody = unexpectedBetweenDeferKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDeferKeyword: ExpressibleAsUnexpectedNodes? = nil, deferKeyword: Token = Token.`defer`, unexpectedBetweenDeferKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDeferKeyword: unexpectedBeforeDeferKeyword, deferKeyword: deferKeyword, unexpectedBetweenDeferKeywordAndBody: unexpectedBetweenDeferKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `DeferStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeferStmtSyntax`.
  func buildDeferStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeferStmtSyntax {
    let result = DeferStmtSyntax(unexpectedBeforeDeferKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), deferKeyword: deferKeyword.buildToken(), unexpectedBetweenDeferKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildDeferStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeferStmt`.
  public func createDeferStmt() -> DeferStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DeferStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ExpressionStmt: StmtBuildable, ExpressibleAsExpressionStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `ExpressionStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `ExpressionStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionStmtSyntax`.
  func buildExpressionStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExpressionStmtSyntax {
    let result = ExpressionStmtSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildExpressionStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionStmt`.
  public func createExpressionStmt() -> ExpressionStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ExpressionStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct RepeatWhileStmt: StmtBuildable, ExpressibleAsRepeatWhileStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeRepeatKeyword: UnexpectedNodes?
  let repeatKeyword: Token
  let unexpectedBetweenRepeatKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock
  let unexpectedBetweenBodyAndWhileKeyword: UnexpectedNodes?
  let whileKeyword: Token
  let unexpectedBetweenWhileKeywordAndCondition: UnexpectedNodes?
  let condition: ExprBuildable
  /// Creates a `RepeatWhileStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeRepeatKeyword: 
  ///   - repeatKeyword: 
  ///   - unexpectedBetweenRepeatKeywordAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndWhileKeyword: 
  ///   - whileKeyword: 
  ///   - unexpectedBetweenWhileKeywordAndCondition: 
  ///   - condition: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRepeatKeyword: ExpressibleAsUnexpectedNodes? = nil, repeatKeyword: Token = Token.`repeat`, unexpectedBetweenRepeatKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeRepeatKeyword = unexpectedBeforeRepeatKeyword?.createUnexpectedNodes()
    self.repeatKeyword = repeatKeyword
    assert(repeatKeyword.text == #"repeat"#)
    self.unexpectedBetweenRepeatKeywordAndBody = unexpectedBetweenRepeatKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
    self.unexpectedBetweenBodyAndWhileKeyword = unexpectedBetweenBodyAndWhileKeyword?.createUnexpectedNodes()
    self.whileKeyword = whileKeyword
    assert(whileKeyword.text == #"while"#)
    self.unexpectedBetweenWhileKeywordAndCondition = unexpectedBetweenWhileKeywordAndCondition?.createUnexpectedNodes()
    self.condition = condition.createExprBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRepeatKeyword: ExpressibleAsUnexpectedNodes? = nil, repeatKeyword: Token = Token.`repeat`, unexpectedBetweenRepeatKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeRepeatKeyword: unexpectedBeforeRepeatKeyword, repeatKeyword: repeatKeyword, unexpectedBetweenRepeatKeywordAndBody: unexpectedBetweenRepeatKeywordAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndWhileKeyword: unexpectedBetweenBodyAndWhileKeyword, whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndCondition: unexpectedBetweenWhileKeywordAndCondition, condition: condition)
  }
  /// Builds a `RepeatWhileStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `RepeatWhileStmtSyntax`.
  func buildRepeatWhileStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> RepeatWhileStmtSyntax {
    let result = RepeatWhileStmtSyntax(unexpectedBeforeRepeatKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), repeatKeyword: repeatKeyword.buildToken(), unexpectedBetweenRepeatKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil), unexpectedBetweenBodyAndWhileKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whileKeyword: whileKeyword.buildToken(), unexpectedBetweenWhileKeywordAndCondition?.buildUnexpectedNodes(format: format, leadingTrivia: nil), condition: condition.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildRepeatWhileStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsRepeatWhileStmt`.
  public func createRepeatWhileStmt() -> RepeatWhileStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `RepeatWhileStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct GuardStmt: StmtBuildable, ExpressibleAsGuardStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeGuardKeyword: UnexpectedNodes?
  let guardKeyword: Token
  let unexpectedBetweenGuardKeywordAndConditions: UnexpectedNodes?
  let conditions: ConditionElementList
  let unexpectedBetweenConditionsAndElseKeyword: UnexpectedNodes?
  let elseKeyword: Token
  let unexpectedBetweenElseKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock
  /// Creates a `GuardStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeGuardKeyword: 
  ///   - guardKeyword: 
  ///   - unexpectedBetweenGuardKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeGuardKeyword: ExpressibleAsUnexpectedNodes? = nil, guardKeyword: Token = Token.`guard`, unexpectedBetweenGuardKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeGuardKeyword = unexpectedBeforeGuardKeyword?.createUnexpectedNodes()
    self.guardKeyword = guardKeyword
    assert(guardKeyword.text == #"guard"#)
    self.unexpectedBetweenGuardKeywordAndConditions = unexpectedBetweenGuardKeywordAndConditions?.createUnexpectedNodes()
    self.conditions = conditions.createConditionElementList()
    self.unexpectedBetweenConditionsAndElseKeyword = unexpectedBetweenConditionsAndElseKeyword?.createUnexpectedNodes()
    self.elseKeyword = elseKeyword
    assert(elseKeyword.text == #"else"#)
    self.unexpectedBetweenElseKeywordAndBody = unexpectedBetweenElseKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeGuardKeyword: ExpressibleAsUnexpectedNodes? = nil, guardKeyword: Token = Token.`guard`, unexpectedBetweenGuardKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeGuardKeyword: unexpectedBeforeGuardKeyword, guardKeyword: guardKeyword, unexpectedBetweenGuardKeywordAndConditions: unexpectedBetweenGuardKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndElseKeyword: unexpectedBetweenConditionsAndElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `GuardStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GuardStmtSyntax`.
  func buildGuardStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GuardStmtSyntax {
    let result = GuardStmtSyntax(unexpectedBeforeGuardKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), guardKeyword: guardKeyword.buildToken(), unexpectedBetweenGuardKeywordAndConditions?.buildUnexpectedNodes(format: format, leadingTrivia: nil), conditions: conditions.buildConditionElementList(format: format, leadingTrivia: nil), unexpectedBetweenConditionsAndElseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elseKeyword: elseKeyword.buildToken(), unexpectedBetweenElseKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildGuardStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsGuardStmt`.
  public func createGuardStmt() -> GuardStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `GuardStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct WhereClause: SyntaxBuildable, ExpressibleAsWhereClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWhereKeyword: UnexpectedNodes?
  let whereKeyword: Token
  let unexpectedBetweenWhereKeywordAndGuardResult: UnexpectedNodes?
  let guardResult: ExprBuildable
  /// Creates a `WhereClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhereKeyword: 
  ///   - whereKeyword: 
  ///   - unexpectedBetweenWhereKeywordAndGuardResult: 
  ///   - guardResult: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndGuardResult: ExpressibleAsUnexpectedNodes? = nil, guardResult: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWhereKeyword = unexpectedBeforeWhereKeyword?.createUnexpectedNodes()
    self.whereKeyword = whereKeyword
    assert(whereKeyword.text == #"where"#)
    self.unexpectedBetweenWhereKeywordAndGuardResult = unexpectedBetweenWhereKeywordAndGuardResult?.createUnexpectedNodes()
    self.guardResult = guardResult.createExprBuildable()
  }
  /// Builds a `WhereClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WhereClauseSyntax`.
  func buildWhereClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> WhereClauseSyntax {
    let result = WhereClauseSyntax(unexpectedBeforeWhereKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whereKeyword: whereKeyword.buildToken(), unexpectedBetweenWhereKeywordAndGuardResult?.buildUnexpectedNodes(format: format, leadingTrivia: nil), guardResult: guardResult.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildWhereClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsWhereClause`.
  public func createWhereClause() -> WhereClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `WhereClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ForInStmt: StmtBuildable, ExpressibleAsForInStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeForKeyword: UnexpectedNodes?
  let forKeyword: Token
  let unexpectedBetweenForKeywordAndTryKeyword: UnexpectedNodes?
  let tryKeyword: Token?
  let unexpectedBetweenTryKeywordAndAwaitKeyword: UnexpectedNodes?
  let awaitKeyword: Token?
  let unexpectedBetweenAwaitKeywordAndCaseKeyword: UnexpectedNodes?
  let caseKeyword: Token?
  let unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  let typeAnnotation: TypeAnnotation?
  let unexpectedBetweenTypeAnnotationAndInKeyword: UnexpectedNodes?
  let inKeyword: Token
  let unexpectedBetweenInKeywordAndSequenceExpr: UnexpectedNodes?
  let sequenceExpr: ExprBuildable
  let unexpectedBetweenSequenceExprAndWhereClause: UnexpectedNodes?
  let whereClause: WhereClause?
  let unexpectedBetweenWhereClauseAndBody: UnexpectedNodes?
  let body: CodeBlock
  /// Creates a `ForInStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeForKeyword: 
  ///   - forKeyword: 
  ///   - unexpectedBetweenForKeywordAndTryKeyword: 
  ///   - tryKeyword: 
  ///   - unexpectedBetweenTryKeywordAndAwaitKeyword: 
  ///   - awaitKeyword: 
  ///   - unexpectedBetweenAwaitKeywordAndCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInKeyword: 
  ///   - inKeyword: 
  ///   - unexpectedBetweenInKeywordAndSequenceExpr: 
  ///   - sequenceExpr: 
  ///   - unexpectedBetweenSequenceExprAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeForKeyword: ExpressibleAsUnexpectedNodes? = nil, forKeyword: Token = Token.`for`, unexpectedBetweenForKeywordAndTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token? = nil, unexpectedBetweenTryKeywordAndAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: Token? = nil, unexpectedBetweenAwaitKeywordAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token? = nil, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInKeyword: ExpressibleAsUnexpectedNodes? = nil, inKeyword: Token = Token.`in`, unexpectedBetweenInKeywordAndSequenceExpr: ExpressibleAsUnexpectedNodes? = nil, sequenceExpr: ExpressibleAsExprBuildable, unexpectedBetweenSequenceExprAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeForKeyword = unexpectedBeforeForKeyword?.createUnexpectedNodes()
    self.forKeyword = forKeyword
    assert(forKeyword.text == #"for"#)
    self.unexpectedBetweenForKeywordAndTryKeyword = unexpectedBetweenForKeywordAndTryKeyword?.createUnexpectedNodes()
    self.tryKeyword = tryKeyword
    assert(tryKeyword == nil || tryKeyword!.text == #"try"#)
    self.unexpectedBetweenTryKeywordAndAwaitKeyword = unexpectedBetweenTryKeywordAndAwaitKeyword?.createUnexpectedNodes()
    self.awaitKeyword = awaitKeyword
    assert(awaitKeyword == nil || awaitKeyword!.text == #"await"#)
    self.unexpectedBetweenAwaitKeywordAndCaseKeyword = unexpectedBetweenAwaitKeywordAndCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword == nil || caseKeyword!.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndPattern = unexpectedBetweenCaseKeywordAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInKeyword = unexpectedBetweenTypeAnnotationAndInKeyword?.createUnexpectedNodes()
    self.inKeyword = inKeyword
    assert(inKeyword.text == #"in"#)
    self.unexpectedBetweenInKeywordAndSequenceExpr = unexpectedBetweenInKeywordAndSequenceExpr?.createUnexpectedNodes()
    self.sequenceExpr = sequenceExpr.createExprBuildable()
    self.unexpectedBetweenSequenceExprAndWhereClause = unexpectedBetweenSequenceExprAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createWhereClause()
    self.unexpectedBetweenWhereClauseAndBody = unexpectedBetweenWhereClauseAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeForKeyword: ExpressibleAsUnexpectedNodes? = nil, forKeyword: Token = Token.`for`, unexpectedBetweenForKeywordAndTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token? = nil, unexpectedBetweenTryKeywordAndAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: String?, unexpectedBetweenAwaitKeywordAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token? = nil, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInKeyword: ExpressibleAsUnexpectedNodes? = nil, inKeyword: Token = Token.`in`, unexpectedBetweenInKeywordAndSequenceExpr: ExpressibleAsUnexpectedNodes? = nil, sequenceExpr: ExpressibleAsExprBuildable, unexpectedBetweenSequenceExprAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeForKeyword: unexpectedBeforeForKeyword, forKeyword: forKeyword, unexpectedBetweenForKeywordAndTryKeyword: unexpectedBetweenForKeywordAndTryKeyword, tryKeyword: tryKeyword, unexpectedBetweenTryKeywordAndAwaitKeyword: unexpectedBetweenTryKeywordAndAwaitKeyword, awaitKeyword: awaitKeyword.map {
      Token.`identifier`($0)
    }, unexpectedBetweenAwaitKeywordAndCaseKeyword: unexpectedBetweenAwaitKeywordAndCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndPattern: unexpectedBetweenCaseKeywordAndPattern, pattern: pattern, unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation, typeAnnotation: typeAnnotation, unexpectedBetweenTypeAnnotationAndInKeyword: unexpectedBetweenTypeAnnotationAndInKeyword, inKeyword: inKeyword, unexpectedBetweenInKeywordAndSequenceExpr: unexpectedBetweenInKeywordAndSequenceExpr, sequenceExpr: sequenceExpr, unexpectedBetweenSequenceExprAndWhereClause: unexpectedBetweenSequenceExprAndWhereClause, whereClause: whereClause, unexpectedBetweenWhereClauseAndBody: unexpectedBetweenWhereClauseAndBody, body: bodyBuilder())
  }
  /// Builds a `ForInStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ForInStmtSyntax`.
  func buildForInStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ForInStmtSyntax {
    let result = ForInStmtSyntax(unexpectedBeforeForKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), forKeyword: forKeyword.buildToken(), unexpectedBetweenForKeywordAndTryKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), tryKeyword: tryKeyword?.buildToken(), unexpectedBetweenTryKeywordAndAwaitKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), awaitKeyword: awaitKeyword?.buildToken(), unexpectedBetweenAwaitKeywordAndCaseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), caseKeyword: caseKeyword?.buildToken(), unexpectedBetweenCaseKeywordAndPattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format, leadingTrivia: nil), unexpectedBetweenTypeAnnotationAndInKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inKeyword: inKeyword.buildToken(), unexpectedBetweenInKeywordAndSequenceExpr?.buildUnexpectedNodes(format: format, leadingTrivia: nil), sequenceExpr: sequenceExpr.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenSequenceExprAndWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whereClause: whereClause?.buildWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenWhereClauseAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildForInStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsForInStmt`.
  public func createForInStmt() -> ForInStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ForInStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SwitchStmt: StmtBuildable, ExpressibleAsSwitchStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeSwitchKeyword: UnexpectedNodes?
  let switchKeyword: Token
  let unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  let unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodes?
  let leftBrace: Token
  let unexpectedBetweenLeftBraceAndCases: UnexpectedNodes?
  let cases: SwitchCaseList
  let unexpectedBetweenCasesAndRightBrace: UnexpectedNodes?
  let rightBrace: Token
  /// Creates a `SwitchStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSwitchKeyword: 
  ///   - switchKeyword: 
  ///   - unexpectedBetweenSwitchKeywordAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndCases: 
  ///   - cases: 
  ///   - unexpectedBetweenCasesAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSwitchKeyword: ExpressibleAsUnexpectedNodes? = nil, switchKeyword: Token = Token.`switch`, unexpectedBetweenSwitchKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndCases: ExpressibleAsUnexpectedNodes? = nil, cases: ExpressibleAsSwitchCaseList, unexpectedBetweenCasesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeSwitchKeyword = unexpectedBeforeSwitchKeyword?.createUnexpectedNodes()
    self.switchKeyword = switchKeyword
    assert(switchKeyword.text == #"switch"#)
    self.unexpectedBetweenSwitchKeywordAndExpression = unexpectedBetweenSwitchKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
    self.unexpectedBetweenExpressionAndLeftBrace = unexpectedBetweenExpressionAndLeftBrace?.createUnexpectedNodes()
    self.leftBrace = leftBrace
    assert(leftBrace.text == #"{"#)
    self.unexpectedBetweenLeftBraceAndCases = unexpectedBetweenLeftBraceAndCases?.createUnexpectedNodes()
    self.cases = cases.createSwitchCaseList()
    self.unexpectedBetweenCasesAndRightBrace = unexpectedBetweenCasesAndRightBrace?.createUnexpectedNodes()
    self.rightBrace = rightBrace
    assert(rightBrace.text == #"}"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSwitchKeyword: ExpressibleAsUnexpectedNodes? = nil, switchKeyword: Token = Token.`switch`, unexpectedBetweenSwitchKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndCases: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenCasesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @SwitchCaseListBuilder casesBuilder: () -> ExpressibleAsSwitchCaseList =  {
    SwitchCaseList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSwitchKeyword: unexpectedBeforeSwitchKeyword, switchKeyword: switchKeyword, unexpectedBetweenSwitchKeywordAndExpression: unexpectedBetweenSwitchKeywordAndExpression, expression: expression, unexpectedBetweenExpressionAndLeftBrace: unexpectedBetweenExpressionAndLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndCases: unexpectedBetweenLeftBraceAndCases, cases: casesBuilder(), unexpectedBetweenCasesAndRightBrace: unexpectedBetweenCasesAndRightBrace, rightBrace: rightBrace)
  }
  /// Builds a `SwitchStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchStmtSyntax`.
  func buildSwitchStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SwitchStmtSyntax {
    let result = SwitchStmtSyntax(unexpectedBeforeSwitchKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), switchKeyword: switchKeyword.buildToken(), unexpectedBetweenSwitchKeywordAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenExpressionAndLeftBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftBrace: leftBrace.buildToken(), unexpectedBetweenLeftBraceAndCases?.buildUnexpectedNodes(format: format, leadingTrivia: nil), cases: cases.buildSwitchCaseList(format: format, leadingTrivia: nil), unexpectedBetweenCasesAndRightBrace?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightBrace: rightBrace.buildToken().withLeadingTrivia(.newline + format._makeIndent() + (rightBrace.buildToken().leadingTrivia ?? [])))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildSwitchStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchStmt`.
  public func createSwitchStmt() -> SwitchStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `SwitchStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DoStmt: StmtBuildable, ExpressibleAsDoStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDoKeyword: UnexpectedNodes?
  let doKeyword: Token
  let unexpectedBetweenDoKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock
  let unexpectedBetweenBodyAndCatchClauses: UnexpectedNodes?
  let catchClauses: CatchClauseList?
  /// Creates a `DoStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDoKeyword: 
  ///   - doKeyword: 
  ///   - unexpectedBetweenDoKeywordAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndCatchClauses: 
  ///   - catchClauses: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDoKeyword: ExpressibleAsUnexpectedNodes? = nil, doKeyword: Token = Token.`do`, unexpectedBetweenDoKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndCatchClauses: ExpressibleAsUnexpectedNodes? = nil, catchClauses: ExpressibleAsCatchClauseList? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDoKeyword = unexpectedBeforeDoKeyword?.createUnexpectedNodes()
    self.doKeyword = doKeyword
    assert(doKeyword.text == #"do"#)
    self.unexpectedBetweenDoKeywordAndBody = unexpectedBetweenDoKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
    self.unexpectedBetweenBodyAndCatchClauses = unexpectedBetweenBodyAndCatchClauses?.createUnexpectedNodes()
    self.catchClauses = catchClauses?.createCatchClauseList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDoKeyword: ExpressibleAsUnexpectedNodes? = nil, doKeyword: Token = Token.`do`, unexpectedBetweenDoKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndCatchClauses: ExpressibleAsUnexpectedNodes? = nil, catchClauses: ExpressibleAsCatchClauseList? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDoKeyword: unexpectedBeforeDoKeyword, doKeyword: doKeyword, unexpectedBetweenDoKeywordAndBody: unexpectedBetweenDoKeywordAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndCatchClauses: unexpectedBetweenBodyAndCatchClauses, catchClauses: catchClauses)
  }
  /// Builds a `DoStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DoStmtSyntax`.
  func buildDoStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DoStmtSyntax {
    let result = DoStmtSyntax(unexpectedBeforeDoKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), doKeyword: doKeyword.buildToken(), unexpectedBetweenDoKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil), unexpectedBetweenBodyAndCatchClauses?.buildUnexpectedNodes(format: format, leadingTrivia: nil), catchClauses: catchClauses?.buildCatchClauseList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildDoStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDoStmt`.
  public func createDoStmt() -> DoStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DoStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ReturnStmt: StmtBuildable, ExpressibleAsReturnStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeReturnKeyword: UnexpectedNodes?
  let returnKeyword: Token
  let unexpectedBetweenReturnKeywordAndExpression: UnexpectedNodes?
  let expression: ExprBuildable?
  /// Creates a `ReturnStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeReturnKeyword: 
  ///   - returnKeyword: 
  ///   - unexpectedBetweenReturnKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeReturnKeyword: ExpressibleAsUnexpectedNodes? = nil, returnKeyword: Token = Token.`return`, unexpectedBetweenReturnKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeReturnKeyword = unexpectedBeforeReturnKeyword?.createUnexpectedNodes()
    self.returnKeyword = returnKeyword
    assert(returnKeyword.text == #"return"#)
    self.unexpectedBetweenReturnKeywordAndExpression = unexpectedBetweenReturnKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression?.createExprBuildable()
  }
  /// Builds a `ReturnStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ReturnStmtSyntax`.
  func buildReturnStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ReturnStmtSyntax {
    let result = ReturnStmtSyntax(unexpectedBeforeReturnKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), returnKeyword: returnKeyword.buildToken(), unexpectedBetweenReturnKeywordAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression?.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildReturnStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsReturnStmt`.
  public func createReturnStmt() -> ReturnStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ReturnStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct YieldStmt: StmtBuildable, ExpressibleAsYieldStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeYieldKeyword: UnexpectedNodes?
  let yieldKeyword: Token
  let unexpectedBetweenYieldKeywordAndYields: UnexpectedNodes?
  let yields: SyntaxBuildable
  /// Creates a `YieldStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeYieldKeyword: 
  ///   - yieldKeyword: 
  ///   - unexpectedBetweenYieldKeywordAndYields: 
  ///   - yields: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeYieldKeyword: ExpressibleAsUnexpectedNodes? = nil, yieldKeyword: Token = Token.`yield`, unexpectedBetweenYieldKeywordAndYields: ExpressibleAsUnexpectedNodes? = nil, yields: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeYieldKeyword = unexpectedBeforeYieldKeyword?.createUnexpectedNodes()
    self.yieldKeyword = yieldKeyword
    assert(yieldKeyword.text == #"yield"#)
    self.unexpectedBetweenYieldKeywordAndYields = unexpectedBetweenYieldKeywordAndYields?.createUnexpectedNodes()
    self.yields = yields.createSyntaxBuildable()
  }
  /// Builds a `YieldStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldStmtSyntax`.
  func buildYieldStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> YieldStmtSyntax {
    let result = YieldStmtSyntax(unexpectedBeforeYieldKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), yieldKeyword: yieldKeyword.buildToken(), unexpectedBetweenYieldKeywordAndYields?.buildUnexpectedNodes(format: format, leadingTrivia: nil), yields: yields.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildYieldStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsYieldStmt`.
  public func createYieldStmt() -> YieldStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `YieldStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct YieldList: SyntaxBuildable, ExpressibleAsYieldList {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndElementList: UnexpectedNodes?
  let elementList: ExprList
  let unexpectedBetweenElementListAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  let unexpectedBetweenTrailingCommaAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `YieldList` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElementList: 
  ///   - elementList: 
  ///   - unexpectedBetweenElementListAndTrailingComma: 
  ///   - trailingComma: 
  ///   - unexpectedBetweenTrailingCommaAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, elementList: ExpressibleAsExprList, unexpectedBetweenElementListAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil, unexpectedBetweenTrailingCommaAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElementList = unexpectedBetweenLeftParenAndElementList?.createUnexpectedNodes()
    self.elementList = elementList.createExprList()
    self.unexpectedBetweenElementListAndTrailingComma = unexpectedBetweenElementListAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.unexpectedBetweenTrailingCommaAndRightParen = unexpectedBetweenTrailingCommaAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementListAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil, unexpectedBetweenTrailingCommaAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @ExprListBuilder elementListBuilder: () -> ExpressibleAsExprList =  {
    ExprList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList, elementList: elementListBuilder(), unexpectedBetweenElementListAndTrailingComma: unexpectedBetweenElementListAndTrailingComma, trailingComma: trailingComma, unexpectedBetweenTrailingCommaAndRightParen: unexpectedBetweenTrailingCommaAndRightParen, rightParen: rightParen)
  }
  /// Builds a `YieldListSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldListSyntax`.
  func buildYieldList(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> YieldListSyntax {
    let result = YieldListSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndElementList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elementList: elementList.buildExprList(format: format, leadingTrivia: nil), unexpectedBetweenElementListAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken(), unexpectedBetweenTrailingCommaAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildYieldList(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsYieldList`.
  public func createYieldList() -> YieldList {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `YieldList` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct FallthroughStmt: StmtBuildable, ExpressibleAsFallthroughStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeFallthroughKeyword: UnexpectedNodes?
  let fallthroughKeyword: Token
  /// Creates a `FallthroughStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFallthroughKeyword: 
  ///   - fallthroughKeyword: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFallthroughKeyword: ExpressibleAsUnexpectedNodes? = nil, fallthroughKeyword: Token = Token.`fallthrough`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeFallthroughKeyword = unexpectedBeforeFallthroughKeyword?.createUnexpectedNodes()
    self.fallthroughKeyword = fallthroughKeyword
    assert(fallthroughKeyword.text == #"fallthrough"#)
  }
  /// Builds a `FallthroughStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FallthroughStmtSyntax`.
  func buildFallthroughStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FallthroughStmtSyntax {
    let result = FallthroughStmtSyntax(unexpectedBeforeFallthroughKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), fallthroughKeyword: fallthroughKeyword.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildFallthroughStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsFallthroughStmt`.
  public func createFallthroughStmt() -> FallthroughStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `FallthroughStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct BreakStmt: StmtBuildable, ExpressibleAsBreakStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBreakKeyword: UnexpectedNodes?
  let breakKeyword: Token
  let unexpectedBetweenBreakKeywordAndLabel: UnexpectedNodes?
  let label: Token?
  /// Creates a `BreakStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBreakKeyword: 
  ///   - breakKeyword: 
  ///   - unexpectedBetweenBreakKeywordAndLabel: 
  ///   - label: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBreakKeyword: ExpressibleAsUnexpectedNodes? = nil, breakKeyword: Token = Token.`break`, unexpectedBetweenBreakKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBreakKeyword = unexpectedBeforeBreakKeyword?.createUnexpectedNodes()
    self.breakKeyword = breakKeyword
    assert(breakKeyword.text == #"break"#)
    self.unexpectedBetweenBreakKeywordAndLabel = unexpectedBetweenBreakKeywordAndLabel?.createUnexpectedNodes()
    self.label = label
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBreakKeyword: ExpressibleAsUnexpectedNodes? = nil, breakKeyword: Token = Token.`break`, unexpectedBetweenBreakKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBreakKeyword: unexpectedBeforeBreakKeyword, breakKeyword: breakKeyword, unexpectedBetweenBreakKeywordAndLabel: unexpectedBetweenBreakKeywordAndLabel, label: label.map {
      Token.`identifier`($0)
    })
  }
  /// Builds a `BreakStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BreakStmtSyntax`.
  func buildBreakStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> BreakStmtSyntax {
    let result = BreakStmtSyntax(unexpectedBeforeBreakKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), breakKeyword: breakKeyword.buildToken(), unexpectedBetweenBreakKeywordAndLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildBreakStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsBreakStmt`.
  public func createBreakStmt() -> BreakStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `BreakStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ConditionElement: SyntaxBuildable, ExpressibleAsConditionElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeCondition: UnexpectedNodes?
  let condition: SyntaxBuildable
  let unexpectedBetweenConditionAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `ConditionElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCondition: 
  ///   - condition: 
  ///   - unexpectedBetweenConditionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsSyntaxBuildable, unexpectedBetweenConditionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeCondition = unexpectedBeforeCondition?.createUnexpectedNodes()
    self.condition = condition.createSyntaxBuildable()
    self.unexpectedBetweenConditionAndTrailingComma = unexpectedBetweenConditionAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `ConditionElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConditionElementSyntax`.
  func buildConditionElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ConditionElementSyntax {
    let result = ConditionElementSyntax(unexpectedBeforeCondition?.buildUnexpectedNodes(format: format, leadingTrivia: nil), condition: condition.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenConditionAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildConditionElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConditionElement`.
  public func createConditionElement() -> ConditionElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConditionElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeCondition: unexpectedBeforeCondition, condition: condition, unexpectedBetweenConditionAndTrailingComma: unexpectedBetweenConditionAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct AvailabilityCondition: SyntaxBuildable, ExpressibleAsAvailabilityCondition {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundAvailableKeyword: UnexpectedNodes?
  let poundAvailableKeyword: Token
  let unexpectedBetweenPoundAvailableKeywordAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndAvailabilitySpec: UnexpectedNodes?
  let availabilitySpec: AvailabilitySpecList
  let unexpectedBetweenAvailabilitySpecAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `AvailabilityCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundAvailableKeyword: 
  ///   - poundAvailableKeyword: 
  ///   - unexpectedBetweenPoundAvailableKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndAvailabilitySpec: 
  ///   - availabilitySpec: 
  ///   - unexpectedBetweenAvailabilitySpecAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundAvailableKeyword: ExpressibleAsUnexpectedNodes? = nil, poundAvailableKeyword: Token = Token.`poundAvailable`, unexpectedBetweenPoundAvailableKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndAvailabilitySpec: ExpressibleAsUnexpectedNodes? = nil, availabilitySpec: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilitySpecAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundAvailableKeyword = unexpectedBeforePoundAvailableKeyword?.createUnexpectedNodes()
    self.poundAvailableKeyword = poundAvailableKeyword
    assert(poundAvailableKeyword.text == #"#available"#)
    self.unexpectedBetweenPoundAvailableKeywordAndLeftParen = unexpectedBetweenPoundAvailableKeywordAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndAvailabilitySpec = unexpectedBetweenLeftParenAndAvailabilitySpec?.createUnexpectedNodes()
    self.availabilitySpec = availabilitySpec.createAvailabilitySpecList()
    self.unexpectedBetweenAvailabilitySpecAndRightParen = unexpectedBetweenAvailabilitySpecAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `AvailabilityConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityConditionSyntax`.
  func buildAvailabilityCondition(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AvailabilityConditionSyntax {
    let result = AvailabilityConditionSyntax(unexpectedBeforePoundAvailableKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundAvailableKeyword: poundAvailableKeyword.buildToken(), unexpectedBetweenPoundAvailableKeywordAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndAvailabilitySpec?.buildUnexpectedNodes(format: format, leadingTrivia: nil), availabilitySpec: availabilitySpec.buildAvailabilitySpecList(format: format, leadingTrivia: nil), unexpectedBetweenAvailabilitySpecAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAvailabilityCondition(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityCondition`.
  public func createAvailabilityCondition() -> AvailabilityCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MatchingPatternCondition: SyntaxBuildable, ExpressibleAsMatchingPatternCondition {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeCaseKeyword: UnexpectedNodes?
  let caseKeyword: Token
  let unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  let typeAnnotation: TypeAnnotation?
  let unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
  let initializer: InitializerClause
  /// Creates a `MatchingPatternCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeCaseKeyword = unexpectedBeforeCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndPattern = unexpectedBetweenCaseKeywordAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInitializer = unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer.createInitializerClause()
  }
  /// Builds a `MatchingPatternConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MatchingPatternConditionSyntax`.
  func buildMatchingPatternCondition(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MatchingPatternConditionSyntax {
    let result = MatchingPatternConditionSyntax(unexpectedBeforeCaseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), caseKeyword: caseKeyword.buildToken(), unexpectedBetweenCaseKeywordAndPattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format, leadingTrivia: nil), unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initializer: initializer.buildInitializerClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildMatchingPatternCondition(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMatchingPatternCondition`.
  public func createMatchingPatternCondition() -> MatchingPatternCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MatchingPatternCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct OptionalBindingCondition: SyntaxBuildable, ExpressibleAsOptionalBindingCondition {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLetOrVarKeyword: UnexpectedNodes?
  let letOrVarKeyword: Token
  let unexpectedBetweenLetOrVarKeywordAndPattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
  let typeAnnotation: TypeAnnotation?
  let unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
  let initializer: InitializerClause?
  /// Creates a `OptionalBindingCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLetOrVarKeyword = unexpectedBeforeLetOrVarKeyword?.createUnexpectedNodes()
    self.letOrVarKeyword = letOrVarKeyword
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.unexpectedBetweenLetOrVarKeywordAndPattern = unexpectedBetweenLetOrVarKeywordAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTypeAnnotation = unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
    self.unexpectedBetweenTypeAnnotationAndInitializer = unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createInitializerClause()
  }
  /// Builds a `OptionalBindingConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalBindingConditionSyntax`.
  func buildOptionalBindingCondition(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> OptionalBindingConditionSyntax {
    let result = OptionalBindingConditionSyntax(unexpectedBeforeLetOrVarKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), letOrVarKeyword: letOrVarKeyword.buildToken(), unexpectedBetweenLetOrVarKeywordAndPattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format, leadingTrivia: nil), unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initializer: initializer?.buildInitializerClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildOptionalBindingCondition(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalBindingCondition`.
  public func createOptionalBindingCondition() -> OptionalBindingCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OptionalBindingCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct UnavailabilityCondition: SyntaxBuildable, ExpressibleAsUnavailabilityCondition {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundUnavailableKeyword: UnexpectedNodes?
  let poundUnavailableKeyword: Token
  let unexpectedBetweenPoundUnavailableKeywordAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndAvailabilitySpec: UnexpectedNodes?
  let availabilitySpec: AvailabilitySpecList
  let unexpectedBetweenAvailabilitySpecAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `UnavailabilityCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundUnavailableKeyword: 
  ///   - poundUnavailableKeyword: 
  ///   - unexpectedBetweenPoundUnavailableKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndAvailabilitySpec: 
  ///   - availabilitySpec: 
  ///   - unexpectedBetweenAvailabilitySpecAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundUnavailableKeyword: ExpressibleAsUnexpectedNodes? = nil, poundUnavailableKeyword: Token = Token.`poundUnavailable`, unexpectedBetweenPoundUnavailableKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndAvailabilitySpec: ExpressibleAsUnexpectedNodes? = nil, availabilitySpec: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilitySpecAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundUnavailableKeyword = unexpectedBeforePoundUnavailableKeyword?.createUnexpectedNodes()
    self.poundUnavailableKeyword = poundUnavailableKeyword
    assert(poundUnavailableKeyword.text == #"#unavailable"#)
    self.unexpectedBetweenPoundUnavailableKeywordAndLeftParen = unexpectedBetweenPoundUnavailableKeywordAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndAvailabilitySpec = unexpectedBetweenLeftParenAndAvailabilitySpec?.createUnexpectedNodes()
    self.availabilitySpec = availabilitySpec.createAvailabilitySpecList()
    self.unexpectedBetweenAvailabilitySpecAndRightParen = unexpectedBetweenAvailabilitySpecAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `UnavailabilityConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnavailabilityConditionSyntax`.
  func buildUnavailabilityCondition(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> UnavailabilityConditionSyntax {
    let result = UnavailabilityConditionSyntax(unexpectedBeforePoundUnavailableKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundUnavailableKeyword: poundUnavailableKeyword.buildToken(), unexpectedBetweenPoundUnavailableKeywordAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndAvailabilitySpec?.buildUnexpectedNodes(format: format, leadingTrivia: nil), availabilitySpec: availabilitySpec.buildAvailabilitySpecList(format: format, leadingTrivia: nil), unexpectedBetweenAvailabilitySpecAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildUnavailabilityCondition(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsUnavailabilityCondition`.
  public func createUnavailabilityCondition() -> UnavailabilityCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `UnavailabilityCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DeclarationStmt: StmtBuildable, ExpressibleAsDeclarationStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDeclaration: UnexpectedNodes?
  let declaration: DeclBuildable
  /// Creates a `DeclarationStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeclaration: 
  ///   - declaration: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDeclaration: ExpressibleAsUnexpectedNodes? = nil, declaration: ExpressibleAsDeclBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDeclaration = unexpectedBeforeDeclaration?.createUnexpectedNodes()
    self.declaration = declaration.createDeclBuildable()
  }
  /// Builds a `DeclarationStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclarationStmtSyntax`.
  func buildDeclarationStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DeclarationStmtSyntax {
    let result = DeclarationStmtSyntax(unexpectedBeforeDeclaration?.buildUnexpectedNodes(format: format, leadingTrivia: nil), declaration: declaration.buildDecl(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildDeclarationStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeclarationStmt`.
  public func createDeclarationStmt() -> DeclarationStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DeclarationStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ThrowStmt: StmtBuildable, ExpressibleAsThrowStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeThrowKeyword: UnexpectedNodes?
  let throwKeyword: Token
  let unexpectedBetweenThrowKeywordAndExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `ThrowStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeThrowKeyword: 
  ///   - throwKeyword: 
  ///   - unexpectedBetweenThrowKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeThrowKeyword: ExpressibleAsUnexpectedNodes? = nil, throwKeyword: Token = Token.`throw`, unexpectedBetweenThrowKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeThrowKeyword = unexpectedBeforeThrowKeyword?.createUnexpectedNodes()
    self.throwKeyword = throwKeyword
    assert(throwKeyword.text == #"throw"#)
    self.unexpectedBetweenThrowKeywordAndExpression = unexpectedBetweenThrowKeywordAndExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `ThrowStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ThrowStmtSyntax`.
  func buildThrowStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ThrowStmtSyntax {
    let result = ThrowStmtSyntax(unexpectedBeforeThrowKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), throwKeyword: throwKeyword.buildToken(), unexpectedBetweenThrowKeywordAndExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildThrowStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsThrowStmt`.
  public func createThrowStmt() -> ThrowStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ThrowStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IfStmt: StmtBuildable, ExpressibleAsIfStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIfKeyword: UnexpectedNodes?
  let ifKeyword: Token
  let unexpectedBetweenIfKeywordAndConditions: UnexpectedNodes?
  let conditions: ConditionElementList
  let unexpectedBetweenConditionsAndBody: UnexpectedNodes?
  let body: CodeBlock
  let unexpectedBetweenBodyAndElseKeyword: UnexpectedNodes?
  let elseKeyword: Token?
  let unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodes?
  let elseBody: SyntaxBuildable?
  /// Creates a `IfStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIfKeyword: 
  ///   - ifKeyword: 
  ///   - unexpectedBetweenIfKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndElseBody: 
  ///   - elseBody: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIfKeyword: ExpressibleAsUnexpectedNodes? = nil, ifKeyword: Token = Token.`if`, unexpectedBetweenIfKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token? = nil, unexpectedBetweenElseKeywordAndElseBody: ExpressibleAsUnexpectedNodes? = nil, elseBody: ExpressibleAsSyntaxBuildable? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIfKeyword = unexpectedBeforeIfKeyword?.createUnexpectedNodes()
    self.ifKeyword = ifKeyword
    assert(ifKeyword.text == #"if"#)
    self.unexpectedBetweenIfKeywordAndConditions = unexpectedBetweenIfKeywordAndConditions?.createUnexpectedNodes()
    self.conditions = conditions.createConditionElementList()
    self.unexpectedBetweenConditionsAndBody = unexpectedBetweenConditionsAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
    self.unexpectedBetweenBodyAndElseKeyword = unexpectedBetweenBodyAndElseKeyword?.createUnexpectedNodes()
    self.elseKeyword = elseKeyword
    assert(elseKeyword == nil || elseKeyword!.text == #"else"#)
    self.unexpectedBetweenElseKeywordAndElseBody = unexpectedBetweenElseKeywordAndElseBody?.createUnexpectedNodes()
    self.elseBody = elseBody?.createSyntaxBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIfKeyword: ExpressibleAsUnexpectedNodes? = nil, ifKeyword: Token = Token.`if`, unexpectedBetweenIfKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token? = nil, unexpectedBetweenElseKeywordAndElseBody: ExpressibleAsUnexpectedNodes? = nil, elseBody: ExpressibleAsSyntaxBuildable? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIfKeyword: unexpectedBeforeIfKeyword, ifKeyword: ifKeyword, unexpectedBetweenIfKeywordAndConditions: unexpectedBetweenIfKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndElseKeyword: unexpectedBetweenBodyAndElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndElseBody: unexpectedBetweenElseKeywordAndElseBody, elseBody: elseBody)
  }
  /// Builds a `IfStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfStmtSyntax`.
  func buildIfStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IfStmtSyntax {
    let result = IfStmtSyntax(unexpectedBeforeIfKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ifKeyword: ifKeyword.buildToken(), unexpectedBetweenIfKeywordAndConditions?.buildUnexpectedNodes(format: format, leadingTrivia: nil), conditions: conditions.buildConditionElementList(format: format, leadingTrivia: nil), unexpectedBetweenConditionsAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil), unexpectedBetweenBodyAndElseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elseKeyword: elseKeyword?.buildToken(), unexpectedBetweenElseKeywordAndElseBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elseBody: elseBody?.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildIfStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsIfStmt`.
  public func createIfStmt() -> IfStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `IfStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ElseIfContinuation: SyntaxBuildable, ExpressibleAsElseIfContinuation {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIfStatement: UnexpectedNodes?
  let ifStatement: IfStmt
  /// Creates a `ElseIfContinuation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIfStatement: 
  ///   - ifStatement: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIfStatement: ExpressibleAsUnexpectedNodes? = nil, ifStatement: ExpressibleAsIfStmt) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIfStatement = unexpectedBeforeIfStatement?.createUnexpectedNodes()
    self.ifStatement = ifStatement.createIfStmt()
  }
  /// Builds a `ElseIfContinuationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ElseIfContinuationSyntax`.
  func buildElseIfContinuation(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ElseIfContinuationSyntax {
    let result = ElseIfContinuationSyntax(unexpectedBeforeIfStatement?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ifStatement: ifStatement.buildIfStmt(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildElseIfContinuation(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsElseIfContinuation`.
  public func createElseIfContinuation() -> ElseIfContinuation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ElseIfContinuation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ElseBlock: SyntaxBuildable, ExpressibleAsElseBlock {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeElseKeyword: UnexpectedNodes?
  let elseKeyword: Token
  let unexpectedBetweenElseKeywordAndBody: UnexpectedNodes?
  let body: CodeBlock
  /// Creates a `ElseBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeElseKeyword = unexpectedBeforeElseKeyword?.createUnexpectedNodes()
    self.elseKeyword = elseKeyword
    assert(elseKeyword.text == #"else"#)
    self.unexpectedBetweenElseKeywordAndBody = unexpectedBetweenElseKeywordAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeElseKeyword: unexpectedBeforeElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody, body: bodyBuilder())
  }
  /// Builds a `ElseBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ElseBlockSyntax`.
  func buildElseBlock(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ElseBlockSyntax {
    let result = ElseBlockSyntax(unexpectedBeforeElseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elseKeyword: elseKeyword.buildToken(), unexpectedBetweenElseKeywordAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildElseBlock(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsElseBlock`.
  public func createElseBlock() -> ElseBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ElseBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SwitchCase: SyntaxBuildable, ExpressibleAsSwitchCase {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeUnknownAttr: UnexpectedNodes?
  let unknownAttr: Attribute?
  let unexpectedBetweenUnknownAttrAndLabel: UnexpectedNodes?
  let label: SyntaxBuildable
  let unexpectedBetweenLabelAndStatements: UnexpectedNodes?
  let statements: CodeBlockItemList
  /// Creates a `SwitchCase` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeUnknownAttr: 
  ///   - unknownAttr: 
  ///   - unexpectedBetweenUnknownAttrAndLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndStatements: 
  ///   - statements: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeUnknownAttr: ExpressibleAsUnexpectedNodes? = nil, unknownAttr: ExpressibleAsAttribute? = nil, unexpectedBetweenUnknownAttrAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: ExpressibleAsSyntaxBuildable, unexpectedBetweenLabelAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeUnknownAttr = unexpectedBeforeUnknownAttr?.createUnexpectedNodes()
    self.unknownAttr = unknownAttr?.createAttribute()
    self.unexpectedBetweenUnknownAttrAndLabel = unexpectedBetweenUnknownAttrAndLabel?.createUnexpectedNodes()
    self.label = label.createSyntaxBuildable()
    self.unexpectedBetweenLabelAndStatements = unexpectedBetweenLabelAndStatements?.createUnexpectedNodes()
    self.statements = statements.createCodeBlockItemList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeUnknownAttr: ExpressibleAsUnexpectedNodes? = nil, unknownAttr: ExpressibleAsAttribute? = nil, unexpectedBetweenUnknownAttrAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: ExpressibleAsSyntaxBuildable, unexpectedBetweenLabelAndStatements: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeUnknownAttr: unexpectedBeforeUnknownAttr, unknownAttr: unknownAttr, unexpectedBetweenUnknownAttrAndLabel: unexpectedBetweenUnknownAttrAndLabel, label: label, unexpectedBetweenLabelAndStatements: unexpectedBetweenLabelAndStatements, statements: statementsBuilder())
  }
  /// Builds a `SwitchCaseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchCaseSyntax`.
  func buildSwitchCase(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SwitchCaseSyntax {
    let result = SwitchCaseSyntax(unexpectedBeforeUnknownAttr?.buildUnexpectedNodes(format: format, leadingTrivia: nil), unknownAttr: unknownAttr?.buildAttribute(format: format, leadingTrivia: nil), unexpectedBetweenUnknownAttrAndLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenLabelAndStatements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), statements: statements.buildCodeBlockItemList(format: format._indented(), leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildSwitchCase(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchCase`.
  public func createSwitchCase() -> SwitchCase {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchCase` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SwitchDefaultLabel: SyntaxBuildable, ExpressibleAsSwitchDefaultLabel {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeDefaultKeyword: UnexpectedNodes?
  let defaultKeyword: Token
  let unexpectedBetweenDefaultKeywordAndColon: UnexpectedNodes?
  let colon: Token
  /// Creates a `SwitchDefaultLabel` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDefaultKeyword: 
  ///   - defaultKeyword: 
  ///   - unexpectedBetweenDefaultKeywordAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDefaultKeyword: ExpressibleAsUnexpectedNodes? = nil, defaultKeyword: Token = Token.`default`, unexpectedBetweenDefaultKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeDefaultKeyword = unexpectedBeforeDefaultKeyword?.createUnexpectedNodes()
    self.defaultKeyword = defaultKeyword
    assert(defaultKeyword.text == #"default"#)
    self.unexpectedBetweenDefaultKeywordAndColon = unexpectedBetweenDefaultKeywordAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
  }
  /// Builds a `SwitchDefaultLabelSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchDefaultLabelSyntax`.
  func buildSwitchDefaultLabel(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SwitchDefaultLabelSyntax {
    let result = SwitchDefaultLabelSyntax(unexpectedBeforeDefaultKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), defaultKeyword: defaultKeyword.buildToken(), unexpectedBetweenDefaultKeywordAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildSwitchDefaultLabel(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchDefaultLabel`.
  public func createSwitchDefaultLabel() -> SwitchDefaultLabel {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchDefaultLabel` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct CaseItem: SyntaxBuildable, ExpressibleAsCaseItem, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndWhereClause: UnexpectedNodes?
  let whereClause: WhereClause?
  let unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `CaseItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndWhereClause = unexpectedBetweenPatternAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createWhereClause()
    self.unexpectedBetweenWhereClauseAndTrailingComma = unexpectedBetweenWhereClauseAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `CaseItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CaseItemSyntax`.
  func buildCaseItem(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CaseItemSyntax {
    let result = CaseItemSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whereClause: whereClause?.buildWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenWhereClauseAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCaseItem(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCaseItem`.
  public func createCaseItem() -> CaseItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CaseItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforePattern: unexpectedBeforePattern, pattern: pattern, unexpectedBetweenPatternAndWhereClause: unexpectedBetweenPatternAndWhereClause, whereClause: whereClause, unexpectedBetweenWhereClauseAndTrailingComma: unexpectedBetweenWhereClauseAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct CatchItem: SyntaxBuildable, ExpressibleAsCatchItem, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePattern: UnexpectedNodes?
  let pattern: PatternBuildable?
  let unexpectedBetweenPatternAndWhereClause: UnexpectedNodes?
  let whereClause: WhereClause?
  let unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `CatchItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable? = nil, unexpectedBetweenPatternAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern?.createPatternBuildable()
    self.unexpectedBetweenPatternAndWhereClause = unexpectedBetweenPatternAndWhereClause?.createUnexpectedNodes()
    self.whereClause = whereClause?.createWhereClause()
    self.unexpectedBetweenWhereClauseAndTrailingComma = unexpectedBetweenWhereClauseAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `CatchItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CatchItemSyntax`.
  func buildCatchItem(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CatchItemSyntax {
    let result = CatchItemSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern?.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndWhereClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whereClause: whereClause?.buildWhereClause(format: format, leadingTrivia: nil), unexpectedBetweenWhereClauseAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCatchItem(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCatchItem`.
  public func createCatchItem() -> CatchItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CatchItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforePattern: unexpectedBeforePattern, pattern: pattern, unexpectedBetweenPatternAndWhereClause: unexpectedBetweenPatternAndWhereClause, whereClause: whereClause, unexpectedBetweenWhereClauseAndTrailingComma: unexpectedBetweenWhereClauseAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct SwitchCaseLabel: SyntaxBuildable, ExpressibleAsSwitchCaseLabel {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeCaseKeyword: UnexpectedNodes?
  let caseKeyword: Token
  let unexpectedBetweenCaseKeywordAndCaseItems: UnexpectedNodes?
  let caseItems: CaseItemList
  let unexpectedBetweenCaseItemsAndColon: UnexpectedNodes?
  let colon: Token
  /// Creates a `SwitchCaseLabel` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndCaseItems: 
  ///   - caseItems: 
  ///   - unexpectedBetweenCaseItemsAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndCaseItems: ExpressibleAsUnexpectedNodes? = nil, caseItems: ExpressibleAsCaseItemList, unexpectedBetweenCaseItemsAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeCaseKeyword = unexpectedBeforeCaseKeyword?.createUnexpectedNodes()
    self.caseKeyword = caseKeyword
    assert(caseKeyword.text == #"case"#)
    self.unexpectedBetweenCaseKeywordAndCaseItems = unexpectedBetweenCaseKeywordAndCaseItems?.createUnexpectedNodes()
    self.caseItems = caseItems.createCaseItemList()
    self.unexpectedBetweenCaseItemsAndColon = unexpectedBetweenCaseItemsAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndCaseItems: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenCaseItemsAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, @CaseItemListBuilder caseItemsBuilder: () -> ExpressibleAsCaseItemList =  {
    CaseItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCaseKeyword: unexpectedBeforeCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndCaseItems: unexpectedBetweenCaseKeywordAndCaseItems, caseItems: caseItemsBuilder(), unexpectedBetweenCaseItemsAndColon: unexpectedBetweenCaseItemsAndColon, colon: colon)
  }
  /// Builds a `SwitchCaseLabelSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchCaseLabelSyntax`.
  func buildSwitchCaseLabel(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SwitchCaseLabelSyntax {
    let result = SwitchCaseLabelSyntax(unexpectedBeforeCaseKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), caseKeyword: caseKeyword.buildToken(), unexpectedBetweenCaseKeywordAndCaseItems?.buildUnexpectedNodes(format: format, leadingTrivia: nil), caseItems: caseItems.buildCaseItemList(format: format, leadingTrivia: nil), unexpectedBetweenCaseItemsAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildSwitchCaseLabel(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchCaseLabel`.
  public func createSwitchCaseLabel() -> SwitchCaseLabel {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchCaseLabel` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct CatchClause: SyntaxBuildable, ExpressibleAsCatchClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeCatchKeyword: UnexpectedNodes?
  let catchKeyword: Token
  let unexpectedBetweenCatchKeywordAndCatchItems: UnexpectedNodes?
  let catchItems: CatchItemList?
  let unexpectedBetweenCatchItemsAndBody: UnexpectedNodes?
  let body: CodeBlock
  /// Creates a `CatchClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCatchKeyword: 
  ///   - catchKeyword: 
  ///   - unexpectedBetweenCatchKeywordAndCatchItems: 
  ///   - catchItems: 
  ///   - unexpectedBetweenCatchItemsAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCatchKeyword: ExpressibleAsUnexpectedNodes? = nil, catchKeyword: Token = Token.`catch`, unexpectedBetweenCatchKeywordAndCatchItems: ExpressibleAsUnexpectedNodes? = nil, catchItems: ExpressibleAsCatchItemList? = nil, unexpectedBetweenCatchItemsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeCatchKeyword = unexpectedBeforeCatchKeyword?.createUnexpectedNodes()
    self.catchKeyword = catchKeyword
    assert(catchKeyword.text == #"catch"#)
    self.unexpectedBetweenCatchKeywordAndCatchItems = unexpectedBetweenCatchKeywordAndCatchItems?.createUnexpectedNodes()
    self.catchItems = catchItems?.createCatchItemList()
    self.unexpectedBetweenCatchItemsAndBody = unexpectedBetweenCatchItemsAndBody?.createUnexpectedNodes()
    self.body = body.createCodeBlock()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCatchKeyword: ExpressibleAsUnexpectedNodes? = nil, catchKeyword: Token = Token.`catch`, unexpectedBetweenCatchKeywordAndCatchItems: ExpressibleAsUnexpectedNodes? = nil, catchItems: ExpressibleAsCatchItemList? = nil, unexpectedBetweenCatchItemsAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCatchKeyword: unexpectedBeforeCatchKeyword, catchKeyword: catchKeyword, unexpectedBetweenCatchKeywordAndCatchItems: unexpectedBetweenCatchKeywordAndCatchItems, catchItems: catchItems, unexpectedBetweenCatchItemsAndBody: unexpectedBetweenCatchItemsAndBody, body: bodyBuilder())
  }
  /// Builds a `CatchClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CatchClauseSyntax`.
  func buildCatchClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CatchClauseSyntax {
    let result = CatchClauseSyntax(unexpectedBeforeCatchKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), catchKeyword: catchKeyword.buildToken(), unexpectedBetweenCatchKeywordAndCatchItems?.buildUnexpectedNodes(format: format, leadingTrivia: nil), catchItems: catchItems?.buildCatchItemList(format: format, leadingTrivia: nil), unexpectedBetweenCatchItemsAndBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildCodeBlock(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCatchClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCatchClause`.
  public func createCatchClause() -> CatchClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CatchClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PoundAssertStmt: StmtBuildable, ExpressibleAsPoundAssertStmt {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePoundAssert: UnexpectedNodes?
  let poundAssert: Token
  let unexpectedBetweenPoundAssertAndLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndCondition: UnexpectedNodes?
  let condition: ExprBuildable
  let unexpectedBetweenConditionAndComma: UnexpectedNodes?
  let comma: Token?
  let unexpectedBetweenCommaAndMessage: UnexpectedNodes?
  let message: Token?
  let unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `PoundAssertStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundAssert: 
  ///   - poundAssert: 
  ///   - unexpectedBetweenPoundAssertAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndCondition: 
  ///   - condition: The assertion condition.
  ///   - unexpectedBetweenConditionAndComma: 
  ///   - comma: The comma after the assertion condition.
  ///   - unexpectedBetweenCommaAndMessage: 
  ///   - message: The assertion message.
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundAssert: ExpressibleAsUnexpectedNodes? = nil, poundAssert: Token = Token.`poundAssert`, unexpectedBetweenPoundAssertAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, unexpectedBetweenConditionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: Token? = nil, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePoundAssert = unexpectedBeforePoundAssert?.createUnexpectedNodes()
    self.poundAssert = poundAssert
    assert(poundAssert.text == #"#assert"#)
    self.unexpectedBetweenPoundAssertAndLeftParen = unexpectedBetweenPoundAssertAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndCondition = unexpectedBetweenLeftParenAndCondition?.createUnexpectedNodes()
    self.condition = condition.createExprBuildable()
    self.unexpectedBetweenConditionAndComma = unexpectedBetweenConditionAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndMessage = unexpectedBetweenCommaAndMessage?.createUnexpectedNodes()
    self.message = message
    self.unexpectedBetweenMessageAndRightParen = unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundAssert: ExpressibleAsUnexpectedNodes? = nil, poundAssert: Token = Token.`poundAssert`, unexpectedBetweenPoundAssertAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, unexpectedBetweenConditionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: String?, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePoundAssert: unexpectedBeforePoundAssert, poundAssert: poundAssert, unexpectedBetweenPoundAssertAndLeftParen: unexpectedBetweenPoundAssertAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndCondition: unexpectedBetweenLeftParenAndCondition, condition: condition, unexpectedBetweenConditionAndComma: unexpectedBetweenConditionAndComma, comma: comma, unexpectedBetweenCommaAndMessage: unexpectedBetweenCommaAndMessage, message: message.map {
      Token.`stringLiteral`($0)
    }, unexpectedBetweenMessageAndRightParen: unexpectedBetweenMessageAndRightParen, rightParen: rightParen)
  }
  /// Builds a `PoundAssertStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundAssertStmtSyntax`.
  func buildPoundAssertStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PoundAssertStmtSyntax {
    let result = PoundAssertStmtSyntax(unexpectedBeforePoundAssert?.buildUnexpectedNodes(format: format, leadingTrivia: nil), poundAssert: poundAssert.buildToken(), unexpectedBetweenPoundAssertAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndCondition?.buildUnexpectedNodes(format: format, leadingTrivia: nil), condition: condition.buildExpr(format: format, leadingTrivia: nil), unexpectedBetweenConditionAndComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), comma: comma?.buildToken(), unexpectedBetweenCommaAndMessage?.buildUnexpectedNodes(format: format, leadingTrivia: nil), message: message?.buildToken(), unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> StmtSyntax {
    let result = buildPoundAssertStmt(format: format, leadingTrivia: additionalLeadingTrivia)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundAssertStmt`.
  public func createPoundAssertStmt() -> PoundAssertStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `PoundAssertStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct GenericWhereClause: SyntaxBuildable, ExpressibleAsGenericWhereClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWhereKeyword: UnexpectedNodes?
  let whereKeyword: Token
  let unexpectedBetweenWhereKeywordAndRequirementList: UnexpectedNodes?
  let requirementList: GenericRequirementList
  /// Creates a `GenericWhereClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhereKeyword: 
  ///   - whereKeyword: 
  ///   - unexpectedBetweenWhereKeywordAndRequirementList: 
  ///   - requirementList: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndRequirementList: ExpressibleAsUnexpectedNodes? = nil, requirementList: ExpressibleAsGenericRequirementList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWhereKeyword = unexpectedBeforeWhereKeyword?.createUnexpectedNodes()
    self.whereKeyword = whereKeyword
    assert(whereKeyword.text == #"where"#)
    self.unexpectedBetweenWhereKeywordAndRequirementList = unexpectedBetweenWhereKeywordAndRequirementList?.createUnexpectedNodes()
    self.requirementList = requirementList.createGenericRequirementList()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndRequirementList: ExpressibleAsUnexpectedNodes? = nil, @GenericRequirementListBuilder requirementListBuilder: () -> ExpressibleAsGenericRequirementList =  {
    GenericRequirementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWhereKeyword: unexpectedBeforeWhereKeyword, whereKeyword: whereKeyword, unexpectedBetweenWhereKeywordAndRequirementList: unexpectedBetweenWhereKeywordAndRequirementList, requirementList: requirementListBuilder())
  }
  /// Builds a `GenericWhereClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericWhereClauseSyntax`.
  func buildGenericWhereClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GenericWhereClauseSyntax {
    let result = GenericWhereClauseSyntax(unexpectedBeforeWhereKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), whereKeyword: whereKeyword.buildToken(), unexpectedBetweenWhereKeywordAndRequirementList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), requirementList: requirementList.buildGenericRequirementList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildGenericWhereClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericWhereClause`.
  public func createGenericWhereClause() -> GenericWhereClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericWhereClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct GenericRequirement: SyntaxBuildable, ExpressibleAsGenericRequirement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBody: UnexpectedNodes?
  let body: SyntaxBuildable
  let unexpectedBetweenBodyAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `GenericRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsSyntaxBuildable, unexpectedBetweenBodyAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBody = unexpectedBeforeBody?.createUnexpectedNodes()
    self.body = body.createSyntaxBuildable()
    self.unexpectedBetweenBodyAndTrailingComma = unexpectedBetweenBodyAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `GenericRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericRequirementSyntax`.
  func buildGenericRequirement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GenericRequirementSyntax {
    let result = GenericRequirementSyntax(unexpectedBeforeBody?.buildUnexpectedNodes(format: format, leadingTrivia: nil), body: body.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenBodyAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildGenericRequirement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericRequirement`.
  public func createGenericRequirement() -> GenericRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeBody: unexpectedBeforeBody, body: body, unexpectedBetweenBodyAndTrailingComma: unexpectedBetweenBodyAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct SameTypeRequirement: SyntaxBuildable, ExpressibleAsSameTypeRequirement {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftTypeIdentifier: UnexpectedNodes?
  let leftTypeIdentifier: TypeBuildable
  let unexpectedBetweenLeftTypeIdentifierAndEqualityToken: UnexpectedNodes?
  let equalityToken: Token
  let unexpectedBetweenEqualityTokenAndRightTypeIdentifier: UnexpectedNodes?
  let rightTypeIdentifier: TypeBuildable
  /// Creates a `SameTypeRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftTypeIdentifier: 
  ///   - leftTypeIdentifier: 
  ///   - unexpectedBetweenLeftTypeIdentifierAndEqualityToken: 
  ///   - equalityToken: 
  ///   - unexpectedBetweenEqualityTokenAndRightTypeIdentifier: 
  ///   - rightTypeIdentifier: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, leftTypeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenLeftTypeIdentifierAndEqualityToken: ExpressibleAsUnexpectedNodes? = nil, equalityToken: Token, unexpectedBetweenEqualityTokenAndRightTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, rightTypeIdentifier: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftTypeIdentifier = unexpectedBeforeLeftTypeIdentifier?.createUnexpectedNodes()
    self.leftTypeIdentifier = leftTypeIdentifier.createTypeBuildable()
    self.unexpectedBetweenLeftTypeIdentifierAndEqualityToken = unexpectedBetweenLeftTypeIdentifierAndEqualityToken?.createUnexpectedNodes()
    self.equalityToken = equalityToken
    self.unexpectedBetweenEqualityTokenAndRightTypeIdentifier = unexpectedBetweenEqualityTokenAndRightTypeIdentifier?.createUnexpectedNodes()
    self.rightTypeIdentifier = rightTypeIdentifier.createTypeBuildable()
  }
  /// Builds a `SameTypeRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SameTypeRequirementSyntax`.
  func buildSameTypeRequirement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SameTypeRequirementSyntax {
    let result = SameTypeRequirementSyntax(unexpectedBeforeLeftTypeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftTypeIdentifier: leftTypeIdentifier.buildType(format: format, leadingTrivia: nil), unexpectedBetweenLeftTypeIdentifierAndEqualityToken?.buildUnexpectedNodes(format: format, leadingTrivia: nil), equalityToken: equalityToken.buildToken(), unexpectedBetweenEqualityTokenAndRightTypeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightTypeIdentifier: rightTypeIdentifier.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildSameTypeRequirement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSameTypeRequirement`.
  public func createSameTypeRequirement() -> SameTypeRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SameTypeRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct LayoutRequirement: SyntaxBuildable, ExpressibleAsLayoutRequirement {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeTypeIdentifier: UnexpectedNodes?
  let typeIdentifier: TypeBuildable
  let unexpectedBetweenTypeIdentifierAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndLayoutConstraint: UnexpectedNodes?
  let layoutConstraint: Token
  let unexpectedBetweenLayoutConstraintAndLeftParen: UnexpectedNodes?
  let leftParen: Token?
  let unexpectedBetweenLeftParenAndSize: UnexpectedNodes?
  let size: Token?
  let unexpectedBetweenSizeAndComma: UnexpectedNodes?
  let comma: Token?
  let unexpectedBetweenCommaAndAlignment: UnexpectedNodes?
  let alignment: Token?
  let unexpectedBetweenAlignmentAndRightParen: UnexpectedNodes?
  let rightParen: Token?
  /// Creates a `LayoutRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTypeIdentifier: 
  ///   - typeIdentifier: 
  ///   - unexpectedBetweenTypeIdentifierAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndLayoutConstraint: 
  ///   - layoutConstraint: 
  ///   - unexpectedBetweenLayoutConstraintAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndSize: 
  ///   - size: 
  ///   - unexpectedBetweenSizeAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndAlignment: 
  ///   - alignment: 
  ///   - unexpectedBetweenAlignmentAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, typeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndLayoutConstraint: ExpressibleAsUnexpectedNodes? = nil, layoutConstraint: Token, unexpectedBetweenLayoutConstraintAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndSize: ExpressibleAsUnexpectedNodes? = nil, size: Token? = nil, unexpectedBetweenSizeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndAlignment: ExpressibleAsUnexpectedNodes? = nil, alignment: Token? = nil, unexpectedBetweenAlignmentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeTypeIdentifier = unexpectedBeforeTypeIdentifier?.createUnexpectedNodes()
    self.typeIdentifier = typeIdentifier.createTypeBuildable()
    self.unexpectedBetweenTypeIdentifierAndColon = unexpectedBetweenTypeIdentifierAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndLayoutConstraint = unexpectedBetweenColonAndLayoutConstraint?.createUnexpectedNodes()
    self.layoutConstraint = layoutConstraint
    self.unexpectedBetweenLayoutConstraintAndLeftParen = unexpectedBetweenLayoutConstraintAndLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen == nil || leftParen!.text == #"("#)
    self.unexpectedBetweenLeftParenAndSize = unexpectedBetweenLeftParenAndSize?.createUnexpectedNodes()
    self.size = size
    self.unexpectedBetweenSizeAndComma = unexpectedBetweenSizeAndComma?.createUnexpectedNodes()
    self.comma = comma
    assert(comma == nil || comma!.text == #","#)
    self.unexpectedBetweenCommaAndAlignment = unexpectedBetweenCommaAndAlignment?.createUnexpectedNodes()
    self.alignment = alignment
    self.unexpectedBetweenAlignmentAndRightParen = unexpectedBetweenAlignmentAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen == nil || rightParen!.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, typeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndLayoutConstraint: ExpressibleAsUnexpectedNodes? = nil, layoutConstraint: String, unexpectedBetweenLayoutConstraintAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndSize: ExpressibleAsUnexpectedNodes? = nil, size: String?, unexpectedBetweenSizeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndAlignment: ExpressibleAsUnexpectedNodes? = nil, alignment: String?, unexpectedBetweenAlignmentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeTypeIdentifier: unexpectedBeforeTypeIdentifier, typeIdentifier: typeIdentifier, unexpectedBetweenTypeIdentifierAndColon: unexpectedBetweenTypeIdentifierAndColon, colon: colon, unexpectedBetweenColonAndLayoutConstraint: unexpectedBetweenColonAndLayoutConstraint, layoutConstraint: Token.`identifier`(layoutConstraint), unexpectedBetweenLayoutConstraintAndLeftParen: unexpectedBetweenLayoutConstraintAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndSize: unexpectedBetweenLeftParenAndSize, size: size.map {
      Token.`integerLiteral`($0)
    }, unexpectedBetweenSizeAndComma: unexpectedBetweenSizeAndComma, comma: comma, unexpectedBetweenCommaAndAlignment: unexpectedBetweenCommaAndAlignment, alignment: alignment.map {
      Token.`integerLiteral`($0)
    }, unexpectedBetweenAlignmentAndRightParen: unexpectedBetweenAlignmentAndRightParen, rightParen: rightParen)
  }
  /// Builds a `LayoutRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LayoutRequirementSyntax`.
  func buildLayoutRequirement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> LayoutRequirementSyntax {
    let result = LayoutRequirementSyntax(unexpectedBeforeTypeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeIdentifier: typeIdentifier.buildType(format: format, leadingTrivia: nil), unexpectedBetweenTypeIdentifierAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndLayoutConstraint?.buildUnexpectedNodes(format: format, leadingTrivia: nil), layoutConstraint: layoutConstraint.buildToken(), unexpectedBetweenLayoutConstraintAndLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen?.buildToken(), unexpectedBetweenLeftParenAndSize?.buildUnexpectedNodes(format: format, leadingTrivia: nil), size: size?.buildToken(), unexpectedBetweenSizeAndComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), comma: comma?.buildToken(), unexpectedBetweenCommaAndAlignment?.buildUnexpectedNodes(format: format, leadingTrivia: nil), alignment: alignment?.buildToken(), unexpectedBetweenAlignmentAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildLayoutRequirement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsLayoutRequirement`.
  public func createLayoutRequirement() -> LayoutRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `LayoutRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct GenericParameter: SyntaxBuildable, ExpressibleAsGenericParameter, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndColon: UnexpectedNodes?
  let colon: Token?
  let unexpectedBetweenColonAndInheritedType: UnexpectedNodes?
  let inheritedType: TypeBuildable?
  let unexpectedBetweenInheritedTypeAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `GenericParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndInheritedType: 
  ///   - inheritedType: 
  ///   - unexpectedBetweenInheritedTypeAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndInheritedType: ExpressibleAsUnexpectedNodes? = nil, inheritedType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenInheritedTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeAttributes = unexpectedBeforeAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndName = unexpectedBetweenAttributesAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndColon = unexpectedBetweenNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndInheritedType = unexpectedBetweenColonAndInheritedType?.createUnexpectedNodes()
    self.inheritedType = inheritedType?.createTypeBuildable()
    self.unexpectedBetweenInheritedTypeAndTrailingComma = unexpectedBetweenInheritedTypeAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndInheritedType: ExpressibleAsUnexpectedNodes? = nil, inheritedType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenInheritedTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndName: unexpectedBetweenAttributesAndName, name: Token.`identifier`(name), unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon, unexpectedBetweenColonAndInheritedType: unexpectedBetweenColonAndInheritedType, inheritedType: inheritedType, unexpectedBetweenInheritedTypeAndTrailingComma: unexpectedBetweenInheritedTypeAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `GenericParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericParameterSyntax`.
  func buildGenericParameter(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GenericParameterSyntax {
    let result = GenericParameterSyntax(unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon?.buildToken(), unexpectedBetweenColonAndInheritedType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inheritedType: inheritedType?.buildType(format: format, leadingTrivia: nil), unexpectedBetweenInheritedTypeAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildGenericParameter(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericParameter`.
  public func createGenericParameter() -> GenericParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndName: unexpectedBetweenAttributesAndName, name: name, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon, unexpectedBetweenColonAndInheritedType: unexpectedBetweenColonAndInheritedType, inheritedType: inheritedType, unexpectedBetweenInheritedTypeAndTrailingComma: unexpectedBetweenInheritedTypeAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct PrimaryAssociatedType: SyntaxBuildable, ExpressibleAsPrimaryAssociatedType, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `PrimaryAssociatedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndTrailingComma = unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `PrimaryAssociatedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrimaryAssociatedTypeSyntax`.
  func buildPrimaryAssociatedType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrimaryAssociatedTypeSyntax {
    let result = PrimaryAssociatedTypeSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPrimaryAssociatedType(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrimaryAssociatedType`.
  public func createPrimaryAssociatedType() -> PrimaryAssociatedType {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrimaryAssociatedType` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeName: unexpectedBeforeName, name: name, unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct GenericParameterClause: SyntaxBuildable, ExpressibleAsGenericParameterClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
  let leftAngleBracket: Token
  let unexpectedBetweenLeftAngleBracketAndGenericParameterList: UnexpectedNodes?
  let genericParameterList: GenericParameterList
  let unexpectedBetweenGenericParameterListAndRightAngleBracket: UnexpectedNodes?
  let rightAngleBracket: Token
  /// Creates a `GenericParameterClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndGenericParameterList: 
  ///   - genericParameterList: 
  ///   - unexpectedBetweenGenericParameterListAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndGenericParameterList: ExpressibleAsUnexpectedNodes? = nil, genericParameterList: ExpressibleAsGenericParameterList, unexpectedBetweenGenericParameterListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftAngleBracket = unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes()
    self.leftAngleBracket = leftAngleBracket
    assert(leftAngleBracket.text == #"<"#)
    self.unexpectedBetweenLeftAngleBracketAndGenericParameterList = unexpectedBetweenLeftAngleBracketAndGenericParameterList?.createUnexpectedNodes()
    self.genericParameterList = genericParameterList.createGenericParameterList()
    self.unexpectedBetweenGenericParameterListAndRightAngleBracket = unexpectedBetweenGenericParameterListAndRightAngleBracket?.createUnexpectedNodes()
    self.rightAngleBracket = rightAngleBracket
    assert(rightAngleBracket.text == #">"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndGenericParameterList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenGenericParameterListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`, @GenericParameterListBuilder genericParameterListBuilder: () -> ExpressibleAsGenericParameterList =  {
    GenericParameterList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket, leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndGenericParameterList: unexpectedBetweenLeftAngleBracketAndGenericParameterList, genericParameterList: genericParameterListBuilder(), unexpectedBetweenGenericParameterListAndRightAngleBracket: unexpectedBetweenGenericParameterListAndRightAngleBracket, rightAngleBracket: rightAngleBracket)
  }
  /// Builds a `GenericParameterClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericParameterClauseSyntax`.
  func buildGenericParameterClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GenericParameterClauseSyntax {
    let result = GenericParameterClauseSyntax(unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftAngleBracket: leftAngleBracket.buildToken(), unexpectedBetweenLeftAngleBracketAndGenericParameterList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericParameterList: genericParameterList.buildGenericParameterList(format: format, leadingTrivia: nil), unexpectedBetweenGenericParameterListAndRightAngleBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightAngleBracket: rightAngleBracket.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildGenericParameterClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericParameterClause`.
  public func createGenericParameterClause() -> GenericParameterClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericParameterClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ConformanceRequirement: SyntaxBuildable, ExpressibleAsConformanceRequirement {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftTypeIdentifier: UnexpectedNodes?
  let leftTypeIdentifier: TypeBuildable
  let unexpectedBetweenLeftTypeIdentifierAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndRightTypeIdentifier: UnexpectedNodes?
  let rightTypeIdentifier: TypeBuildable
  /// Creates a `ConformanceRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftTypeIdentifier: 
  ///   - leftTypeIdentifier: 
  ///   - unexpectedBetweenLeftTypeIdentifierAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndRightTypeIdentifier: 
  ///   - rightTypeIdentifier: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, leftTypeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenLeftTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndRightTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, rightTypeIdentifier: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftTypeIdentifier = unexpectedBeforeLeftTypeIdentifier?.createUnexpectedNodes()
    self.leftTypeIdentifier = leftTypeIdentifier.createTypeBuildable()
    self.unexpectedBetweenLeftTypeIdentifierAndColon = unexpectedBetweenLeftTypeIdentifierAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndRightTypeIdentifier = unexpectedBetweenColonAndRightTypeIdentifier?.createUnexpectedNodes()
    self.rightTypeIdentifier = rightTypeIdentifier.createTypeBuildable()
  }
  /// Builds a `ConformanceRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConformanceRequirementSyntax`.
  func buildConformanceRequirement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ConformanceRequirementSyntax {
    let result = ConformanceRequirementSyntax(unexpectedBeforeLeftTypeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftTypeIdentifier: leftTypeIdentifier.buildType(format: format, leadingTrivia: nil), unexpectedBetweenLeftTypeIdentifierAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndRightTypeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightTypeIdentifier: rightTypeIdentifier.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildConformanceRequirement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConformanceRequirement`.
  public func createConformanceRequirement() -> ConformanceRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConformanceRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct PrimaryAssociatedTypeClause: SyntaxBuildable, ExpressibleAsPrimaryAssociatedTypeClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
  let leftAngleBracket: Token
  let unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: UnexpectedNodes?
  let primaryAssociatedTypeList: PrimaryAssociatedTypeList
  let unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: UnexpectedNodes?
  let rightAngleBracket: Token
  /// Creates a `PrimaryAssociatedTypeClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: 
  ///   - primaryAssociatedTypeList: 
  ///   - unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeList: ExpressibleAsPrimaryAssociatedTypeList, unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftAngleBracket = unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes()
    self.leftAngleBracket = leftAngleBracket
    assert(leftAngleBracket.text == #"<"#)
    self.unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList = unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList?.createUnexpectedNodes()
    self.primaryAssociatedTypeList = primaryAssociatedTypeList.createPrimaryAssociatedTypeList()
    self.unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket = unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket?.createUnexpectedNodes()
    self.rightAngleBracket = rightAngleBracket
    assert(rightAngleBracket.text == #">"#)
  }
  /// Builds a `PrimaryAssociatedTypeClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrimaryAssociatedTypeClauseSyntax`.
  func buildPrimaryAssociatedTypeClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PrimaryAssociatedTypeClauseSyntax {
    let result = PrimaryAssociatedTypeClauseSyntax(unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftAngleBracket: leftAngleBracket.buildToken(), unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList?.buildUnexpectedNodes(format: format, leadingTrivia: nil), primaryAssociatedTypeList: primaryAssociatedTypeList.buildPrimaryAssociatedTypeList(format: format, leadingTrivia: nil), unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightAngleBracket: rightAngleBracket.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildPrimaryAssociatedTypeClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrimaryAssociatedTypeClause`.
  public func createPrimaryAssociatedTypeClause() -> PrimaryAssociatedTypeClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrimaryAssociatedTypeClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct SimpleTypeIdentifier: TypeBuildable, ExpressibleAsSimpleTypeIdentifier {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodes?
  let genericArgumentClause: GenericArgumentClause?
  /// Creates a `SimpleTypeIdentifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeName = unexpectedBeforeName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndGenericArgumentClause = unexpectedBetweenNameAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause?.createGenericArgumentClause()
  }
  /// Builds a `SimpleTypeIdentifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SimpleTypeIdentifierSyntax`.
  func buildSimpleTypeIdentifier(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> SimpleTypeIdentifierSyntax {
    let result = SimpleTypeIdentifierSyntax(unexpectedBeforeName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndGenericArgumentClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericArgumentClause: genericArgumentClause?.buildGenericArgumentClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildSimpleTypeIdentifier(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsSimpleTypeIdentifier`.
  public func createSimpleTypeIdentifier() -> SimpleTypeIdentifier {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `SimpleTypeIdentifier` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MemberTypeIdentifier: TypeBuildable, ExpressibleAsMemberTypeIdentifier {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBaseType: UnexpectedNodes?
  let baseType: TypeBuildable
  let unexpectedBetweenBaseTypeAndPeriod: UnexpectedNodes?
  let period: Token
  let unexpectedBetweenPeriodAndName: UnexpectedNodes?
  let name: Token
  let unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodes?
  let genericArgumentClause: GenericArgumentClause?
  /// Creates a `MemberTypeIdentifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: 
  ///   - unexpectedBetweenBaseTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token, unexpectedBetweenPeriodAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBaseType = unexpectedBeforeBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
    self.unexpectedBetweenBaseTypeAndPeriod = unexpectedBetweenBaseTypeAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."# || period.text == #"."#)
    self.unexpectedBetweenPeriodAndName = unexpectedBetweenPeriodAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndGenericArgumentClause = unexpectedBetweenNameAndGenericArgumentClause?.createUnexpectedNodes()
    self.genericArgumentClause = genericArgumentClause?.createGenericArgumentClause()
  }
  /// Builds a `MemberTypeIdentifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberTypeIdentifierSyntax`.
  func buildMemberTypeIdentifier(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MemberTypeIdentifierSyntax {
    let result = MemberTypeIdentifierSyntax(unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), baseType: baseType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenBaseTypeAndPeriod?.buildUnexpectedNodes(format: format, leadingTrivia: nil), period: period.buildToken(), unexpectedBetweenPeriodAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name.buildToken(), unexpectedBetweenNameAndGenericArgumentClause?.buildUnexpectedNodes(format: format, leadingTrivia: nil), genericArgumentClause: genericArgumentClause?.buildGenericArgumentClause(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildMemberTypeIdentifier(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsMemberTypeIdentifier`.
  public func createMemberTypeIdentifier() -> MemberTypeIdentifier {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `MemberTypeIdentifier` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ClassRestrictionType: TypeBuildable, ExpressibleAsClassRestrictionType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeClassKeyword: UnexpectedNodes?
  let classKeyword: Token
  /// Creates a `ClassRestrictionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeClassKeyword: 
  ///   - classKeyword: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeClassKeyword = unexpectedBeforeClassKeyword?.createUnexpectedNodes()
    self.classKeyword = classKeyword
    assert(classKeyword.text == #"class"#)
  }
  /// Builds a `ClassRestrictionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClassRestrictionTypeSyntax`.
  func buildClassRestrictionType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ClassRestrictionTypeSyntax {
    let result = ClassRestrictionTypeSyntax(unexpectedBeforeClassKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), classKeyword: classKeyword.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildClassRestrictionType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsClassRestrictionType`.
  public func createClassRestrictionType() -> ClassRestrictionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ClassRestrictionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ArrayType: TypeBuildable, ExpressibleAsArrayType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftSquareBracket: UnexpectedNodes?
  let leftSquareBracket: Token
  let unexpectedBetweenLeftSquareBracketAndElementType: UnexpectedNodes?
  let elementType: TypeBuildable
  let unexpectedBetweenElementTypeAndRightSquareBracket: UnexpectedNodes?
  let rightSquareBracket: Token
  /// Creates a `ArrayType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquareBracket: 
  ///   - leftSquareBracket: 
  ///   - unexpectedBetweenLeftSquareBracketAndElementType: 
  ///   - elementType: 
  ///   - unexpectedBetweenElementTypeAndRightSquareBracket: 
  ///   - rightSquareBracket: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquareBracket: ExpressibleAsUnexpectedNodes? = nil, leftSquareBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareBracketAndElementType: ExpressibleAsUnexpectedNodes? = nil, elementType: ExpressibleAsTypeBuildable, unexpectedBetweenElementTypeAndRightSquareBracket: ExpressibleAsUnexpectedNodes? = nil, rightSquareBracket: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftSquareBracket = unexpectedBeforeLeftSquareBracket?.createUnexpectedNodes()
    self.leftSquareBracket = leftSquareBracket
    assert(leftSquareBracket.text == #"["#)
    self.unexpectedBetweenLeftSquareBracketAndElementType = unexpectedBetweenLeftSquareBracketAndElementType?.createUnexpectedNodes()
    self.elementType = elementType.createTypeBuildable()
    self.unexpectedBetweenElementTypeAndRightSquareBracket = unexpectedBetweenElementTypeAndRightSquareBracket?.createUnexpectedNodes()
    self.rightSquareBracket = rightSquareBracket
    assert(rightSquareBracket.text == #"]"#)
  }
  /// Builds a `ArrayTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayTypeSyntax`.
  func buildArrayType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ArrayTypeSyntax {
    let result = ArrayTypeSyntax(unexpectedBeforeLeftSquareBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftSquareBracket: leftSquareBracket.buildToken(), unexpectedBetweenLeftSquareBracketAndElementType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elementType: elementType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenElementTypeAndRightSquareBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightSquareBracket: rightSquareBracket.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildArrayType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrayType`.
  public func createArrayType() -> ArrayType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ArrayType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct DictionaryType: TypeBuildable, ExpressibleAsDictionaryType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftSquareBracket: UnexpectedNodes?
  let leftSquareBracket: Token
  let unexpectedBetweenLeftSquareBracketAndKeyType: UnexpectedNodes?
  let keyType: TypeBuildable
  let unexpectedBetweenKeyTypeAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndValueType: UnexpectedNodes?
  let valueType: TypeBuildable
  let unexpectedBetweenValueTypeAndRightSquareBracket: UnexpectedNodes?
  let rightSquareBracket: Token
  /// Creates a `DictionaryType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquareBracket: 
  ///   - leftSquareBracket: 
  ///   - unexpectedBetweenLeftSquareBracketAndKeyType: 
  ///   - keyType: 
  ///   - unexpectedBetweenKeyTypeAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValueType: 
  ///   - valueType: 
  ///   - unexpectedBetweenValueTypeAndRightSquareBracket: 
  ///   - rightSquareBracket: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquareBracket: ExpressibleAsUnexpectedNodes? = nil, leftSquareBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareBracketAndKeyType: ExpressibleAsUnexpectedNodes? = nil, keyType: ExpressibleAsTypeBuildable, unexpectedBetweenKeyTypeAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValueType: ExpressibleAsUnexpectedNodes? = nil, valueType: ExpressibleAsTypeBuildable, unexpectedBetweenValueTypeAndRightSquareBracket: ExpressibleAsUnexpectedNodes? = nil, rightSquareBracket: Token = Token.`rightSquareBracket`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftSquareBracket = unexpectedBeforeLeftSquareBracket?.createUnexpectedNodes()
    self.leftSquareBracket = leftSquareBracket
    assert(leftSquareBracket.text == #"["#)
    self.unexpectedBetweenLeftSquareBracketAndKeyType = unexpectedBetweenLeftSquareBracketAndKeyType?.createUnexpectedNodes()
    self.keyType = keyType.createTypeBuildable()
    self.unexpectedBetweenKeyTypeAndColon = unexpectedBetweenKeyTypeAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValueType = unexpectedBetweenColonAndValueType?.createUnexpectedNodes()
    self.valueType = valueType.createTypeBuildable()
    self.unexpectedBetweenValueTypeAndRightSquareBracket = unexpectedBetweenValueTypeAndRightSquareBracket?.createUnexpectedNodes()
    self.rightSquareBracket = rightSquareBracket
    assert(rightSquareBracket.text == #"]"#)
  }
  /// Builds a `DictionaryTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryTypeSyntax`.
  func buildDictionaryType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> DictionaryTypeSyntax {
    let result = DictionaryTypeSyntax(unexpectedBeforeLeftSquareBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftSquareBracket: leftSquareBracket.buildToken(), unexpectedBetweenLeftSquareBracketAndKeyType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), keyType: keyType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenKeyTypeAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndValueType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), valueType: valueType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenValueTypeAndRightSquareBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightSquareBracket: rightSquareBracket.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildDictionaryType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryType`.
  public func createDictionaryType() -> DictionaryType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `DictionaryType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct MetatypeType: TypeBuildable, ExpressibleAsMetatypeType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeBaseType: UnexpectedNodes?
  let baseType: TypeBuildable
  let unexpectedBetweenBaseTypeAndPeriod: UnexpectedNodes?
  let period: Token
  let unexpectedBetweenPeriodAndTypeOrProtocol: UnexpectedNodes?
  let typeOrProtocol: Token
  /// Creates a `MetatypeType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: 
  ///   - unexpectedBetweenBaseTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndTypeOrProtocol: 
  ///   - typeOrProtocol: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndTypeOrProtocol: ExpressibleAsUnexpectedNodes? = nil, typeOrProtocol: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeBaseType = unexpectedBeforeBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
    self.unexpectedBetweenBaseTypeAndPeriod = unexpectedBetweenBaseTypeAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."#)
    self.unexpectedBetweenPeriodAndTypeOrProtocol = unexpectedBetweenPeriodAndTypeOrProtocol?.createUnexpectedNodes()
    self.typeOrProtocol = typeOrProtocol
    assert(typeOrProtocol.text == #"Type"# || typeOrProtocol.text == #"Protocol"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndTypeOrProtocol: ExpressibleAsUnexpectedNodes? = nil, typeOrProtocol: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBaseType: unexpectedBeforeBaseType, baseType: baseType, unexpectedBetweenBaseTypeAndPeriod: unexpectedBetweenBaseTypeAndPeriod, period: period, unexpectedBetweenPeriodAndTypeOrProtocol: unexpectedBetweenPeriodAndTypeOrProtocol, typeOrProtocol: Token.`identifier`(typeOrProtocol))
  }
  /// Builds a `MetatypeTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MetatypeTypeSyntax`.
  func buildMetatypeType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> MetatypeTypeSyntax {
    let result = MetatypeTypeSyntax(unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), baseType: baseType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenBaseTypeAndPeriod?.buildUnexpectedNodes(format: format, leadingTrivia: nil), period: period.buildToken(), unexpectedBetweenPeriodAndTypeOrProtocol?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeOrProtocol: typeOrProtocol.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildMetatypeType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsMetatypeType`.
  public func createMetatypeType() -> MetatypeType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `MetatypeType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct OptionalType: TypeBuildable, ExpressibleAsOptionalType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWrappedType: UnexpectedNodes?
  let wrappedType: TypeBuildable
  let unexpectedBetweenWrappedTypeAndQuestionMark: UnexpectedNodes?
  let questionMark: Token
  /// Creates a `OptionalType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrappedType: 
  ///   - wrappedType: 
  ///   - unexpectedBetweenWrappedTypeAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWrappedType: ExpressibleAsUnexpectedNodes? = nil, wrappedType: ExpressibleAsTypeBuildable, unexpectedBetweenWrappedTypeAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWrappedType = unexpectedBeforeWrappedType?.createUnexpectedNodes()
    self.wrappedType = wrappedType.createTypeBuildable()
    self.unexpectedBetweenWrappedTypeAndQuestionMark = unexpectedBetweenWrappedTypeAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
  }
  /// Builds a `OptionalTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalTypeSyntax`.
  func buildOptionalType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> OptionalTypeSyntax {
    let result = OptionalTypeSyntax(unexpectedBeforeWrappedType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), wrappedType: wrappedType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenWrappedTypeAndQuestionMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionMark: questionMark.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildOptionalType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalType`.
  public func createOptionalType() -> OptionalType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `OptionalType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ConstrainedSugarType: TypeBuildable, ExpressibleAsConstrainedSugarType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeSomeOrAnySpecifier: UnexpectedNodes?
  let someOrAnySpecifier: Token
  let unexpectedBetweenSomeOrAnySpecifierAndBaseType: UnexpectedNodes?
  let baseType: TypeBuildable
  /// Creates a `ConstrainedSugarType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSomeOrAnySpecifier: 
  ///   - someOrAnySpecifier: 
  ///   - unexpectedBetweenSomeOrAnySpecifierAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSomeOrAnySpecifier: ExpressibleAsUnexpectedNodes? = nil, someOrAnySpecifier: Token, unexpectedBetweenSomeOrAnySpecifierAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeSomeOrAnySpecifier = unexpectedBeforeSomeOrAnySpecifier?.createUnexpectedNodes()
    self.someOrAnySpecifier = someOrAnySpecifier
    assert(someOrAnySpecifier.text == #"some"# || someOrAnySpecifier.text == #"any"#)
    self.unexpectedBetweenSomeOrAnySpecifierAndBaseType = unexpectedBetweenSomeOrAnySpecifierAndBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSomeOrAnySpecifier: ExpressibleAsUnexpectedNodes? = nil, someOrAnySpecifier: String, unexpectedBetweenSomeOrAnySpecifierAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSomeOrAnySpecifier: unexpectedBeforeSomeOrAnySpecifier, someOrAnySpecifier: Token.`identifier`(someOrAnySpecifier), unexpectedBetweenSomeOrAnySpecifierAndBaseType: unexpectedBetweenSomeOrAnySpecifierAndBaseType, baseType: baseType)
  }
  /// Builds a `ConstrainedSugarTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConstrainedSugarTypeSyntax`.
  func buildConstrainedSugarType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ConstrainedSugarTypeSyntax {
    let result = ConstrainedSugarTypeSyntax(unexpectedBeforeSomeOrAnySpecifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), someOrAnySpecifier: someOrAnySpecifier.buildToken(), unexpectedBetweenSomeOrAnySpecifierAndBaseType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), baseType: baseType.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildConstrainedSugarType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsConstrainedSugarType`.
  public func createConstrainedSugarType() -> ConstrainedSugarType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ConstrainedSugarType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ImplicitlyUnwrappedOptionalType: TypeBuildable, ExpressibleAsImplicitlyUnwrappedOptionalType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWrappedType: UnexpectedNodes?
  let wrappedType: TypeBuildable
  let unexpectedBetweenWrappedTypeAndExclamationMark: UnexpectedNodes?
  let exclamationMark: Token
  /// Creates a `ImplicitlyUnwrappedOptionalType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrappedType: 
  ///   - wrappedType: 
  ///   - unexpectedBetweenWrappedTypeAndExclamationMark: 
  ///   - exclamationMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWrappedType: ExpressibleAsUnexpectedNodes? = nil, wrappedType: ExpressibleAsTypeBuildable, unexpectedBetweenWrappedTypeAndExclamationMark: ExpressibleAsUnexpectedNodes? = nil, exclamationMark: Token = Token.`exclamationMark`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWrappedType = unexpectedBeforeWrappedType?.createUnexpectedNodes()
    self.wrappedType = wrappedType.createTypeBuildable()
    self.unexpectedBetweenWrappedTypeAndExclamationMark = unexpectedBetweenWrappedTypeAndExclamationMark?.createUnexpectedNodes()
    self.exclamationMark = exclamationMark
    assert(exclamationMark.text == #"!"#)
  }
  /// Builds a `ImplicitlyUnwrappedOptionalTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImplicitlyUnwrappedOptionalTypeSyntax`.
  func buildImplicitlyUnwrappedOptionalType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    let result = ImplicitlyUnwrappedOptionalTypeSyntax(unexpectedBeforeWrappedType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), wrappedType: wrappedType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenWrappedTypeAndExclamationMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), exclamationMark: exclamationMark.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildImplicitlyUnwrappedOptionalType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsImplicitlyUnwrappedOptionalType`.
  public func createImplicitlyUnwrappedOptionalType() -> ImplicitlyUnwrappedOptionalType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ImplicitlyUnwrappedOptionalType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct CompositionTypeElement: SyntaxBuildable, ExpressibleAsCompositionTypeElement {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeType: UnexpectedNodes?
  let type: TypeBuildable
  let unexpectedBetweenTypeAndAmpersand: UnexpectedNodes?
  let ampersand: Token?
  /// Creates a `CompositionTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndAmpersand: 
  ///   - ampersand: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndAmpersand: ExpressibleAsUnexpectedNodes? = nil, ampersand: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
    self.unexpectedBetweenTypeAndAmpersand = unexpectedBetweenTypeAndAmpersand?.createUnexpectedNodes()
    self.ampersand = ampersand
    assert(ampersand == nil || ampersand!.text == #"&"#)
  }
  /// Builds a `CompositionTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CompositionTypeElementSyntax`.
  func buildCompositionTypeElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CompositionTypeElementSyntax {
    let result = CompositionTypeElementSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildType(format: format, leadingTrivia: nil), unexpectedBetweenTypeAndAmpersand?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ampersand: ampersand?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildCompositionTypeElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCompositionTypeElement`.
  public func createCompositionTypeElement() -> CompositionTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CompositionTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct CompositionType: TypeBuildable, ExpressibleAsCompositionType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeElements: UnexpectedNodes?
  let elements: CompositionTypeElementList
  /// Creates a `CompositionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsCompositionTypeElementList) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeElements = unexpectedBeforeElements?.createUnexpectedNodes()
    self.elements = elements.createCompositionTypeElementList()
  }
  /// Builds a `CompositionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CompositionTypeSyntax`.
  func buildCompositionType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> CompositionTypeSyntax {
    let result = CompositionTypeSyntax(unexpectedBeforeElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildCompositionTypeElementList(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildCompositionType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsCompositionType`.
  public func createCompositionType() -> CompositionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `CompositionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TupleTypeElement: SyntaxBuildable, ExpressibleAsTupleTypeElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeInOut: UnexpectedNodes?
  let inOut: Token?
  let unexpectedBetweenInOutAndName: UnexpectedNodes?
  let name: Token?
  let unexpectedBetweenNameAndSecondName: UnexpectedNodes?
  let secondName: Token?
  let unexpectedBetweenSecondNameAndColon: UnexpectedNodes?
  let colon: Token?
  let unexpectedBetweenColonAndType: UnexpectedNodes?
  let type: TypeBuildable
  let unexpectedBetweenTypeAndEllipsis: UnexpectedNodes?
  let ellipsis: Token?
  let unexpectedBetweenEllipsisAndInitializer: UnexpectedNodes?
  let initializer: InitializerClause?
  let unexpectedBetweenInitializerAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `TupleTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeInOut: 
  ///   - inOut: 
  ///   - unexpectedBetweenInOutAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndSecondName: 
  ///   - secondName: 
  ///   - unexpectedBetweenSecondNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndEllipsis: 
  ///   - ellipsis: 
  ///   - unexpectedBetweenEllipsisAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeInOut: ExpressibleAsUnexpectedNodes? = nil, inOut: Token? = nil, unexpectedBetweenInOutAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndSecondName: ExpressibleAsUnexpectedNodes? = nil, secondName: Token? = nil, unexpectedBetweenSecondNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token? = nil, unexpectedBetweenEllipsisAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil, unexpectedBetweenInitializerAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeInOut = unexpectedBeforeInOut?.createUnexpectedNodes()
    self.inOut = inOut
    assert(inOut == nil || inOut!.text == #"inout"#)
    self.unexpectedBetweenInOutAndName = unexpectedBetweenInOutAndName?.createUnexpectedNodes()
    self.name = name
    self.unexpectedBetweenNameAndSecondName = unexpectedBetweenNameAndSecondName?.createUnexpectedNodes()
    self.secondName = secondName
    self.unexpectedBetweenSecondNameAndColon = unexpectedBetweenSecondNameAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon == nil || colon!.text == #":"#)
    self.unexpectedBetweenColonAndType = unexpectedBetweenColonAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
    self.unexpectedBetweenTypeAndEllipsis = unexpectedBetweenTypeAndEllipsis?.createUnexpectedNodes()
    self.ellipsis = ellipsis
    assert(ellipsis == nil || ellipsis!.text == #"..."#)
    self.unexpectedBetweenEllipsisAndInitializer = unexpectedBetweenEllipsisAndInitializer?.createUnexpectedNodes()
    self.initializer = initializer?.createInitializerClause()
    self.unexpectedBetweenInitializerAndTrailingComma = unexpectedBetweenInitializerAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `TupleTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleTypeElementSyntax`.
  func buildTupleTypeElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TupleTypeElementSyntax {
    let result = TupleTypeElementSyntax(unexpectedBeforeInOut?.buildUnexpectedNodes(format: format, leadingTrivia: nil), inOut: inOut?.buildToken(), unexpectedBetweenInOutAndName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), name: name?.buildToken(), unexpectedBetweenNameAndSecondName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), secondName: secondName?.buildToken(), unexpectedBetweenSecondNameAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon?.buildToken(), unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildType(format: format, leadingTrivia: nil), unexpectedBetweenTypeAndEllipsis?.buildUnexpectedNodes(format: format, leadingTrivia: nil), ellipsis: ellipsis?.buildToken(), unexpectedBetweenEllipsisAndInitializer?.buildUnexpectedNodes(format: format, leadingTrivia: nil), initializer: initializer?.buildInitializerClause(format: format, leadingTrivia: nil), unexpectedBetweenInitializerAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTupleTypeElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTupleTypeElement`.
  public func createTupleTypeElement() -> TupleTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TupleTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeInOut: unexpectedBeforeInOut, inOut: inOut, unexpectedBetweenInOutAndName: unexpectedBetweenInOutAndName, name: name, unexpectedBetweenNameAndSecondName: unexpectedBetweenNameAndSecondName, secondName: secondName, unexpectedBetweenSecondNameAndColon: unexpectedBetweenSecondNameAndColon, colon: colon, unexpectedBetweenColonAndType: unexpectedBetweenColonAndType, type: type, unexpectedBetweenTypeAndEllipsis: unexpectedBetweenTypeAndEllipsis, ellipsis: ellipsis, unexpectedBetweenEllipsisAndInitializer: unexpectedBetweenEllipsisAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndTrailingComma: unexpectedBetweenInitializerAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct TupleType: TypeBuildable, ExpressibleAsTupleType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndElements: UnexpectedNodes?
  let elements: TupleTypeElementList
  let unexpectedBetweenElementsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `TupleType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsTupleTypeElementList, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElements = unexpectedBetweenLeftParenAndElements?.createUnexpectedNodes()
    self.elements = elements.createTupleTypeElementList()
    self.unexpectedBetweenElementsAndRightParen = unexpectedBetweenElementsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// Builds a `TupleTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleTypeSyntax`.
  func buildTupleType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TupleTypeSyntax {
    let result = TupleTypeSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildTupleTypeElementList(format: format, leadingTrivia: nil), unexpectedBetweenElementsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildTupleType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsTupleType`.
  public func createTupleType() -> TupleType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `TupleType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct FunctionType: TypeBuildable, ExpressibleAsFunctionType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
  let arguments: TupleTypeElementList
  let unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  let unexpectedBetweenRightParenAndAsyncKeyword: UnexpectedNodes?
  let asyncKeyword: Token?
  let unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: UnexpectedNodes?
  let throwsOrRethrowsKeyword: Token?
  let unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: UnexpectedNodes?
  let arrow: Token
  let unexpectedBetweenArrowAndReturnType: UnexpectedNodes?
  let returnType: TypeBuildable
  /// Creates a `FunctionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  ///   - unexpectedBetweenRightParenAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: 
  ///   - throwsOrRethrowsKeyword: 
  ///   - unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: 
  ///   - arrow: 
  ///   - unexpectedBetweenArrowAndReturnType: 
  ///   - returnType: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsTupleTypeElementList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, unexpectedBetweenRightParenAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: ExpressibleAsUnexpectedNodes? = nil, arrow: Token = Token.`arrow`, unexpectedBetweenArrowAndReturnType: ExpressibleAsUnexpectedNodes? = nil, returnType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndArguments = unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createTupleTypeElementList()
    self.unexpectedBetweenArgumentsAndRightParen = unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
    self.unexpectedBetweenRightParenAndAsyncKeyword = unexpectedBetweenRightParenAndAsyncKeyword?.createUnexpectedNodes()
    self.asyncKeyword = asyncKeyword
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    self.unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword = unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword?.createUnexpectedNodes()
    self.throwsOrRethrowsKeyword = throwsOrRethrowsKeyword
    assert(throwsOrRethrowsKeyword == nil || throwsOrRethrowsKeyword!.text == #"throws"# || throwsOrRethrowsKeyword!.text == #"rethrows"# || throwsOrRethrowsKeyword!.text == #"throw"#)
    self.unexpectedBetweenThrowsOrRethrowsKeywordAndArrow = unexpectedBetweenThrowsOrRethrowsKeywordAndArrow?.createUnexpectedNodes()
    self.arrow = arrow
    assert(arrow.text == #"->"#)
    self.unexpectedBetweenArrowAndReturnType = unexpectedBetweenArrowAndReturnType?.createUnexpectedNodes()
    self.returnType = returnType.createTypeBuildable()
  }
  /// Builds a `FunctionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionTypeSyntax`.
  func buildFunctionType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> FunctionTypeSyntax {
    let result = FunctionTypeSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arguments: arguments.buildTupleTypeElementList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken(), unexpectedBetweenRightParenAndAsyncKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asyncKeyword: asyncKeyword?.buildToken(), unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), throwsOrRethrowsKeyword: throwsOrRethrowsKeyword?.buildToken(), unexpectedBetweenThrowsOrRethrowsKeywordAndArrow?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arrow: arrow.buildToken(), unexpectedBetweenArrowAndReturnType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), returnType: returnType.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildFunctionType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionType`.
  public func createFunctionType() -> FunctionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `FunctionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AttributedType: TypeBuildable, ExpressibleAsAttributedType {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeSpecifier: UnexpectedNodes?
  let specifier: Token?
  let unexpectedBetweenSpecifierAndAttributes: UnexpectedNodes?
  let attributes: AttributeList?
  let unexpectedBetweenAttributesAndBaseType: UnexpectedNodes?
  let baseType: TypeBuildable
  /// Creates a `AttributedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSpecifier: 
  ///   - specifier: 
  ///   - unexpectedBetweenSpecifierAndAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: Token? = nil, unexpectedBetweenSpecifierAndAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeSpecifier = unexpectedBeforeSpecifier?.createUnexpectedNodes()
    self.specifier = specifier
    assert(specifier == nil || specifier!.text == #"inout"# || specifier!.text == #"__shared"# || specifier!.text == #"__owned"#)
    self.unexpectedBetweenSpecifierAndAttributes = unexpectedBetweenSpecifierAndAttributes?.createUnexpectedNodes()
    self.attributes = attributes?.createAttributeList()
    self.unexpectedBetweenAttributesAndBaseType = unexpectedBetweenAttributesAndBaseType?.createUnexpectedNodes()
    self.baseType = baseType.createTypeBuildable()
  }
  /// Builds a `AttributedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AttributedTypeSyntax`.
  func buildAttributedType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AttributedTypeSyntax {
    let result = AttributedTypeSyntax(unexpectedBeforeSpecifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), specifier: specifier?.buildToken(), unexpectedBetweenSpecifierAndAttributes?.buildUnexpectedNodes(format: format, leadingTrivia: nil), attributes: attributes?.buildAttributeList(format: format, leadingTrivia: nil), unexpectedBetweenAttributesAndBaseType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), baseType: baseType.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeSyntax {
    let result = buildAttributedType(format: format, leadingTrivia: additionalLeadingTrivia)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsAttributedType`.
  public func createAttributedType() -> AttributedType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `AttributedType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct GenericArgument: SyntaxBuildable, ExpressibleAsGenericArgument, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeArgumentType: UnexpectedNodes?
  let argumentType: TypeBuildable
  let unexpectedBetweenArgumentTypeAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `GenericArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeArgumentType: 
  ///   - argumentType: 
  ///   - unexpectedBetweenArgumentTypeAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeArgumentType: ExpressibleAsUnexpectedNodes? = nil, argumentType: ExpressibleAsTypeBuildable, unexpectedBetweenArgumentTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeArgumentType = unexpectedBeforeArgumentType?.createUnexpectedNodes()
    self.argumentType = argumentType.createTypeBuildable()
    self.unexpectedBetweenArgumentTypeAndTrailingComma = unexpectedBetweenArgumentTypeAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `GenericArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericArgumentSyntax`.
  func buildGenericArgument(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GenericArgumentSyntax {
    let result = GenericArgumentSyntax(unexpectedBeforeArgumentType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), argumentType: argumentType.buildType(format: format, leadingTrivia: nil), unexpectedBetweenArgumentTypeAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildGenericArgument(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericArgument`.
  public func createGenericArgument() -> GenericArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeArgumentType: unexpectedBeforeArgumentType, argumentType: argumentType, unexpectedBetweenArgumentTypeAndTrailingComma: unexpectedBetweenArgumentTypeAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct GenericArgumentClause: SyntaxBuildable, ExpressibleAsGenericArgumentClause {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
  let leftAngleBracket: Token
  let unexpectedBetweenLeftAngleBracketAndArguments: UnexpectedNodes?
  let arguments: GenericArgumentList
  let unexpectedBetweenArgumentsAndRightAngleBracket: UnexpectedNodes?
  let rightAngleBracket: Token
  /// Creates a `GenericArgumentClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsGenericArgumentList, unexpectedBetweenArgumentsAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftAngleBracket = unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes()
    self.leftAngleBracket = leftAngleBracket
    assert(leftAngleBracket.text == #"<"#)
    self.unexpectedBetweenLeftAngleBracketAndArguments = unexpectedBetweenLeftAngleBracketAndArguments?.createUnexpectedNodes()
    self.arguments = arguments.createGenericArgumentList()
    self.unexpectedBetweenArgumentsAndRightAngleBracket = unexpectedBetweenArgumentsAndRightAngleBracket?.createUnexpectedNodes()
    self.rightAngleBracket = rightAngleBracket
    assert(rightAngleBracket.text == #">"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndArguments: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentsAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`, @GenericArgumentListBuilder argumentsBuilder: () -> ExpressibleAsGenericArgumentList =  {
    GenericArgumentList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket, leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndArguments: unexpectedBetweenLeftAngleBracketAndArguments, arguments: argumentsBuilder(), unexpectedBetweenArgumentsAndRightAngleBracket: unexpectedBetweenArgumentsAndRightAngleBracket, rightAngleBracket: rightAngleBracket)
  }
  /// Builds a `GenericArgumentClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericArgumentClauseSyntax`.
  func buildGenericArgumentClause(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> GenericArgumentClauseSyntax {
    let result = GenericArgumentClauseSyntax(unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftAngleBracket: leftAngleBracket.buildToken(), unexpectedBetweenLeftAngleBracketAndArguments?.buildUnexpectedNodes(format: format, leadingTrivia: nil), arguments: arguments.buildGenericArgumentList(format: format, leadingTrivia: nil), unexpectedBetweenArgumentsAndRightAngleBracket?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightAngleBracket: rightAngleBracket.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildGenericArgumentClause(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericArgumentClause`.
  public func createGenericArgumentClause() -> GenericArgumentClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericArgumentClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TypeAnnotation: SyntaxBuildable, ExpressibleAsTypeAnnotation {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndType: UnexpectedNodes?
  let type: TypeBuildable
  /// Creates a `TypeAnnotation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeColon = unexpectedBeforeColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndType = unexpectedBetweenColonAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `TypeAnnotationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeAnnotationSyntax`.
  func buildTypeAnnotation(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TypeAnnotationSyntax {
    let result = TypeAnnotationSyntax(unexpectedBeforeColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTypeAnnotation(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeAnnotation`.
  public func createTypeAnnotation() -> TypeAnnotation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeAnnotation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct EnumCasePattern: PatternBuildable, ExpressibleAsEnumCasePattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeType: UnexpectedNodes?
  let type: TypeBuildable?
  let unexpectedBetweenTypeAndPeriod: UnexpectedNodes?
  let period: Token
  let unexpectedBetweenPeriodAndCaseName: UnexpectedNodes?
  let caseName: Token
  let unexpectedBetweenCaseNameAndAssociatedTuple: UnexpectedNodes?
  let associatedTuple: TuplePattern?
  /// Creates a `EnumCasePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndCaseName: 
  ///   - caseName: 
  ///   - unexpectedBetweenCaseNameAndAssociatedTuple: 
  ///   - associatedTuple: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndCaseName: ExpressibleAsUnexpectedNodes? = nil, caseName: Token, unexpectedBetweenCaseNameAndAssociatedTuple: ExpressibleAsUnexpectedNodes? = nil, associatedTuple: ExpressibleAsTuplePattern? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeType = unexpectedBeforeType?.createUnexpectedNodes()
    self.type = type?.createTypeBuildable()
    self.unexpectedBetweenTypeAndPeriod = unexpectedBetweenTypeAndPeriod?.createUnexpectedNodes()
    self.period = period
    assert(period.text == #"."#)
    self.unexpectedBetweenPeriodAndCaseName = unexpectedBetweenPeriodAndCaseName?.createUnexpectedNodes()
    self.caseName = caseName
    self.unexpectedBetweenCaseNameAndAssociatedTuple = unexpectedBetweenCaseNameAndAssociatedTuple?.createUnexpectedNodes()
    self.associatedTuple = associatedTuple?.createTuplePattern()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndCaseName: ExpressibleAsUnexpectedNodes? = nil, caseName: String, unexpectedBetweenCaseNameAndAssociatedTuple: ExpressibleAsUnexpectedNodes? = nil, associatedTuple: ExpressibleAsTuplePattern? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeType: unexpectedBeforeType, type: type, unexpectedBetweenTypeAndPeriod: unexpectedBetweenTypeAndPeriod, period: period, unexpectedBetweenPeriodAndCaseName: unexpectedBetweenPeriodAndCaseName, caseName: Token.`identifier`(caseName), unexpectedBetweenCaseNameAndAssociatedTuple: unexpectedBetweenCaseNameAndAssociatedTuple, associatedTuple: associatedTuple)
  }
  /// Builds a `EnumCasePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCasePatternSyntax`.
  func buildEnumCasePattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> EnumCasePatternSyntax {
    let result = EnumCasePatternSyntax(unexpectedBeforeType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type?.buildType(format: format, leadingTrivia: nil), unexpectedBetweenTypeAndPeriod?.buildUnexpectedNodes(format: format, leadingTrivia: nil), period: period.buildToken(), unexpectedBetweenPeriodAndCaseName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), caseName: caseName.buildToken(), unexpectedBetweenCaseNameAndAssociatedTuple?.buildUnexpectedNodes(format: format, leadingTrivia: nil), associatedTuple: associatedTuple?.buildTuplePattern(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildEnumCasePattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCasePattern`.
  public func createEnumCasePattern() -> EnumCasePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `EnumCasePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IsTypePattern: PatternBuildable, ExpressibleAsIsTypePattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIsKeyword: UnexpectedNodes?
  let isKeyword: Token
  let unexpectedBetweenIsKeywordAndType: UnexpectedNodes?
  let type: TypeBuildable
  /// Creates a `IsTypePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIsKeyword: 
  ///   - isKeyword: 
  ///   - unexpectedBetweenIsKeywordAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIsKeyword: ExpressibleAsUnexpectedNodes? = nil, isKeyword: Token = Token.`is`, unexpectedBetweenIsKeywordAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIsKeyword = unexpectedBeforeIsKeyword?.createUnexpectedNodes()
    self.isKeyword = isKeyword
    assert(isKeyword.text == #"is"#)
    self.unexpectedBetweenIsKeywordAndType = unexpectedBetweenIsKeywordAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `IsTypePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IsTypePatternSyntax`.
  func buildIsTypePattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IsTypePatternSyntax {
    let result = IsTypePatternSyntax(unexpectedBeforeIsKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), isKeyword: isKeyword.buildToken(), unexpectedBetweenIsKeywordAndType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildIsTypePattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsIsTypePattern`.
  public func createIsTypePattern() -> IsTypePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `IsTypePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct OptionalPattern: PatternBuildable, ExpressibleAsOptionalPattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeSubPattern: UnexpectedNodes?
  let subPattern: PatternBuildable
  let unexpectedBetweenSubPatternAndQuestionMark: UnexpectedNodes?
  let questionMark: Token
  /// Creates a `OptionalPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSubPattern: 
  ///   - subPattern: 
  ///   - unexpectedBetweenSubPatternAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSubPattern: ExpressibleAsUnexpectedNodes? = nil, subPattern: ExpressibleAsPatternBuildable, unexpectedBetweenSubPatternAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeSubPattern = unexpectedBeforeSubPattern?.createUnexpectedNodes()
    self.subPattern = subPattern.createPatternBuildable()
    self.unexpectedBetweenSubPatternAndQuestionMark = unexpectedBetweenSubPatternAndQuestionMark?.createUnexpectedNodes()
    self.questionMark = questionMark
    assert(questionMark.text == #"?"#)
  }
  /// Builds a `OptionalPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalPatternSyntax`.
  func buildOptionalPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> OptionalPatternSyntax {
    let result = OptionalPatternSyntax(unexpectedBeforeSubPattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), subPattern: subPattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenSubPatternAndQuestionMark?.buildUnexpectedNodes(format: format, leadingTrivia: nil), questionMark: questionMark.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildOptionalPattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalPattern`.
  public func createOptionalPattern() -> OptionalPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `OptionalPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct IdentifierPattern: PatternBuildable, ExpressibleAsIdentifierPattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeIdentifier: UnexpectedNodes?
  let identifier: Token
  /// Creates a `IdentifierPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeIdentifier = unexpectedBeforeIdentifier?.createUnexpectedNodes()
    self.identifier = identifier
  }
  /// Builds a `IdentifierPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IdentifierPatternSyntax`.
  func buildIdentifierPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> IdentifierPatternSyntax {
    let result = IdentifierPatternSyntax(unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format, leadingTrivia: nil), identifier: identifier.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildIdentifierPattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsIdentifierPattern`.
  public func createIdentifierPattern() -> IdentifierPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `IdentifierPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct AsTypePattern: PatternBuildable, ExpressibleAsAsTypePattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndAsKeyword: UnexpectedNodes?
  let asKeyword: Token
  let unexpectedBetweenAsKeywordAndType: UnexpectedNodes?
  let type: TypeBuildable
  /// Creates a `AsTypePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndAsKeyword: 
  ///   - asKeyword: 
  ///   - unexpectedBetweenAsKeywordAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndAsKeyword: ExpressibleAsUnexpectedNodes? = nil, asKeyword: Token = Token.`as`, unexpectedBetweenAsKeywordAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePattern = unexpectedBeforePattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndAsKeyword = unexpectedBetweenPatternAndAsKeyword?.createUnexpectedNodes()
    self.asKeyword = asKeyword
    assert(asKeyword.text == #"as"#)
    self.unexpectedBetweenAsKeywordAndType = unexpectedBetweenAsKeywordAndType?.createUnexpectedNodes()
    self.type = type.createTypeBuildable()
  }
  /// Builds a `AsTypePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AsTypePatternSyntax`.
  func buildAsTypePattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AsTypePatternSyntax {
    let result = AsTypePatternSyntax(unexpectedBeforePattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndAsKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), asKeyword: asKeyword.buildToken(), unexpectedBetweenAsKeywordAndType?.buildUnexpectedNodes(format: format, leadingTrivia: nil), type: type.buildType(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildAsTypePattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsAsTypePattern`.
  public func createAsTypePattern() -> AsTypePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `AsTypePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TuplePattern: PatternBuildable, ExpressibleAsTuplePattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLeftParen: UnexpectedNodes?
  let leftParen: Token
  let unexpectedBetweenLeftParenAndElements: UnexpectedNodes?
  let elements: TuplePatternElementList
  let unexpectedBetweenElementsAndRightParen: UnexpectedNodes?
  let rightParen: Token
  /// Creates a `TuplePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsTuplePatternElementList, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLeftParen = unexpectedBeforeLeftParen?.createUnexpectedNodes()
    self.leftParen = leftParen
    assert(leftParen.text == #"("#)
    self.unexpectedBetweenLeftParenAndElements = unexpectedBetweenLeftParenAndElements?.createUnexpectedNodes()
    self.elements = elements.createTuplePatternElementList()
    self.unexpectedBetweenElementsAndRightParen = unexpectedBetweenElementsAndRightParen?.createUnexpectedNodes()
    self.rightParen = rightParen
    assert(rightParen.text == #")"#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TuplePatternElementListBuilder elementsBuilder: () -> ExpressibleAsTuplePatternElementList =  {
    TuplePatternElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElements: unexpectedBetweenLeftParenAndElements, elements: elementsBuilder(), unexpectedBetweenElementsAndRightParen: unexpectedBetweenElementsAndRightParen, rightParen: rightParen)
  }
  /// Builds a `TuplePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TuplePatternSyntax`.
  func buildTuplePattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TuplePatternSyntax {
    let result = TuplePatternSyntax(unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), leftParen: leftParen.buildToken(), unexpectedBetweenLeftParenAndElements?.buildUnexpectedNodes(format: format, leadingTrivia: nil), elements: elements.buildTuplePatternElementList(format: format, leadingTrivia: nil), unexpectedBetweenElementsAndRightParen?.buildUnexpectedNodes(format: format, leadingTrivia: nil), rightParen: rightParen.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildTuplePattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsTuplePattern`.
  public func createTuplePattern() -> TuplePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `TuplePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct WildcardPattern: PatternBuildable, ExpressibleAsWildcardPattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeWildcard: UnexpectedNodes?
  let wildcard: Token
  let unexpectedBetweenWildcardAndTypeAnnotation: UnexpectedNodes?
  let typeAnnotation: TypeAnnotation?
  /// Creates a `WildcardPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWildcard: 
  ///   - wildcard: 
  ///   - unexpectedBetweenWildcardAndTypeAnnotation: 
  ///   - typeAnnotation: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWildcard: ExpressibleAsUnexpectedNodes? = nil, wildcard: Token = Token.`wildcard`, unexpectedBetweenWildcardAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeWildcard = unexpectedBeforeWildcard?.createUnexpectedNodes()
    self.wildcard = wildcard
    assert(wildcard.text == #"_"#)
    self.unexpectedBetweenWildcardAndTypeAnnotation = unexpectedBetweenWildcardAndTypeAnnotation?.createUnexpectedNodes()
    self.typeAnnotation = typeAnnotation?.createTypeAnnotation()
  }
  /// Builds a `WildcardPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WildcardPatternSyntax`.
  func buildWildcardPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> WildcardPatternSyntax {
    let result = WildcardPatternSyntax(unexpectedBeforeWildcard?.buildUnexpectedNodes(format: format, leadingTrivia: nil), wildcard: wildcard.buildToken(), unexpectedBetweenWildcardAndTypeAnnotation?.buildUnexpectedNodes(format: format, leadingTrivia: nil), typeAnnotation: typeAnnotation?.buildTypeAnnotation(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildWildcardPattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsWildcardPattern`.
  public func createWildcardPattern() -> WildcardPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `WildcardPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct TuplePatternElement: SyntaxBuildable, ExpressibleAsTuplePatternElement, HasTrailingComma {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabelName: UnexpectedNodes?
  let labelName: Token?
  let unexpectedBetweenLabelNameAndLabelColon: UnexpectedNodes?
  let labelColon: Token?
  let unexpectedBetweenLabelColonAndPattern: UnexpectedNodes?
  let pattern: PatternBuildable
  let unexpectedBetweenPatternAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `TuplePatternElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabelName: 
  ///   - labelName: 
  ///   - unexpectedBetweenLabelNameAndLabelColon: 
  ///   - labelColon: 
  ///   - unexpectedBetweenLabelColonAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: Token? = nil, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token? = nil, unexpectedBetweenLabelColonAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabelName = unexpectedBeforeLabelName?.createUnexpectedNodes()
    self.labelName = labelName
    self.unexpectedBetweenLabelNameAndLabelColon = unexpectedBetweenLabelNameAndLabelColon?.createUnexpectedNodes()
    self.labelColon = labelColon
    assert(labelColon == nil || labelColon!.text == #":"#)
    self.unexpectedBetweenLabelColonAndPattern = unexpectedBetweenLabelColonAndPattern?.createUnexpectedNodes()
    self.pattern = pattern.createPatternBuildable()
    self.unexpectedBetweenPatternAndTrailingComma = unexpectedBetweenPatternAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: String?, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token? = nil, unexpectedBetweenLabelColonAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: labelName.map {
      Token.`identifier`($0)
    }, unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndPattern: unexpectedBetweenLabelColonAndPattern, pattern: pattern, unexpectedBetweenPatternAndTrailingComma: unexpectedBetweenPatternAndTrailingComma, trailingComma: trailingComma)
  }
  /// Builds a `TuplePatternElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TuplePatternElementSyntax`.
  func buildTuplePatternElement(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> TuplePatternElementSyntax {
    let result = TuplePatternElementSyntax(unexpectedBeforeLabelName?.buildUnexpectedNodes(format: format, leadingTrivia: nil), labelName: labelName?.buildToken(), unexpectedBetweenLabelNameAndLabelColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), labelColon: labelColon?.buildToken(), unexpectedBetweenLabelColonAndPattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), pattern: pattern.buildPattern(format: format, leadingTrivia: nil), unexpectedBetweenPatternAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildTuplePatternElement(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTuplePatternElement`.
  public func createTuplePatternElement() -> TuplePatternElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TuplePatternElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    Self(unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: labelName, unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndPattern: unexpectedBetweenLabelColonAndPattern, pattern: pattern, unexpectedBetweenPatternAndTrailingComma: unexpectedBetweenPatternAndTrailingComma, trailingComma: withComma ? .comma : nil)
  }
}
public struct ExpressionPattern: PatternBuildable, ExpressibleAsExpressionPattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeExpression: UnexpectedNodes?
  let expression: ExprBuildable
  /// Creates a `ExpressionPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeExpression = unexpectedBeforeExpression?.createUnexpectedNodes()
    self.expression = expression.createExprBuildable()
  }
  /// Builds a `ExpressionPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionPatternSyntax`.
  func buildExpressionPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ExpressionPatternSyntax {
    let result = ExpressionPatternSyntax(unexpectedBeforeExpression?.buildUnexpectedNodes(format: format, leadingTrivia: nil), expression: expression.buildExpr(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildExpressionPattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionPattern`.
  public func createExpressionPattern() -> ExpressionPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `ExpressionPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
public struct ValueBindingPattern: PatternBuildable, ExpressibleAsValueBindingPattern {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLetOrVarKeyword: UnexpectedNodes?
  let letOrVarKeyword: Token
  let unexpectedBetweenLetOrVarKeywordAndValuePattern: UnexpectedNodes?
  let valuePattern: PatternBuildable
  /// Creates a `ValueBindingPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndValuePattern: 
  ///   - valuePattern: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndValuePattern: ExpressibleAsUnexpectedNodes? = nil, valuePattern: ExpressibleAsPatternBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLetOrVarKeyword = unexpectedBeforeLetOrVarKeyword?.createUnexpectedNodes()
    self.letOrVarKeyword = letOrVarKeyword
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.unexpectedBetweenLetOrVarKeywordAndValuePattern = unexpectedBetweenLetOrVarKeywordAndValuePattern?.createUnexpectedNodes()
    self.valuePattern = valuePattern.createPatternBuildable()
  }
  /// Builds a `ValueBindingPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ValueBindingPatternSyntax`.
  func buildValueBindingPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> ValueBindingPatternSyntax {
    let result = ValueBindingPatternSyntax(unexpectedBeforeLetOrVarKeyword?.buildUnexpectedNodes(format: format, leadingTrivia: nil), letOrVarKeyword: letOrVarKeyword.buildToken(), unexpectedBetweenLetOrVarKeywordAndValuePattern?.buildUnexpectedNodes(format: format, leadingTrivia: nil), valuePattern: valuePattern.buildPattern(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> PatternSyntax {
    let result = buildValueBindingPattern(format: format, leadingTrivia: additionalLeadingTrivia)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsValueBindingPattern`.
  public func createValueBindingPattern() -> ValueBindingPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `ValueBindingPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A single argument to an `@available` argument like `*`, `iOS 10.1`,or `message: "This has been deprecated"`.
public struct AvailabilityArgument: SyntaxBuildable, ExpressibleAsAvailabilityArgument {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeEntry: UnexpectedNodes?
  let entry: SyntaxBuildable
  let unexpectedBetweenEntryAndTrailingComma: UnexpectedNodes?
  let trailingComma: Token?
  /// Creates a `AvailabilityArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEntry: 
  ///   - entry: The actual argument
  ///   - unexpectedBetweenEntryAndTrailingComma: 
  ///   - trailingComma: A trailing comma if the argument is followed by anotherargument
  public init (leadingTrivia: Trivia = [], unexpectedBeforeEntry: ExpressibleAsUnexpectedNodes? = nil, entry: ExpressibleAsSyntaxBuildable, unexpectedBetweenEntryAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeEntry = unexpectedBeforeEntry?.createUnexpectedNodes()
    self.entry = entry.createSyntaxBuildable()
    self.unexpectedBetweenEntryAndTrailingComma = unexpectedBetweenEntryAndTrailingComma?.createUnexpectedNodes()
    self.trailingComma = trailingComma
    assert(trailingComma == nil || trailingComma!.text == #","#)
  }
  /// Builds a `AvailabilityArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityArgumentSyntax`.
  func buildAvailabilityArgument(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AvailabilityArgumentSyntax {
    let result = AvailabilityArgumentSyntax(unexpectedBeforeEntry?.buildUnexpectedNodes(format: format, leadingTrivia: nil), entry: entry.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenEntryAndTrailingComma?.buildUnexpectedNodes(format: format, leadingTrivia: nil), trailingComma: trailingComma?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAvailabilityArgument(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityArgument`.
  public func createAvailabilityArgument() -> AvailabilityArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A argument to an `@available` attribute that consists of a label anda value, e.g. `message: "This has been deprecated"`.
public struct AvailabilityLabeledArgument: SyntaxBuildable, ExpressibleAsAvailabilityLabeledArgument {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeLabel: UnexpectedNodes?
  let label: Token
  let unexpectedBetweenLabelAndColon: UnexpectedNodes?
  let colon: Token
  let unexpectedBetweenColonAndValue: UnexpectedNodes?
  let value: SyntaxBuildable
  /// Creates a `AvailabilityLabeledArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating label and value
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: The value of this labeled argument
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsSyntaxBuildable) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeLabel = unexpectedBeforeLabel?.createUnexpectedNodes()
    self.label = label
    self.unexpectedBetweenLabelAndColon = unexpectedBetweenLabelAndColon?.createUnexpectedNodes()
    self.colon = colon
    assert(colon.text == #":"#)
    self.unexpectedBetweenColonAndValue = unexpectedBetweenColonAndValue?.createUnexpectedNodes()
    self.value = value.createSyntaxBuildable()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsSyntaxBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value)
  }
  /// Builds a `AvailabilityLabeledArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityLabeledArgumentSyntax`.
  func buildAvailabilityLabeledArgument(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AvailabilityLabeledArgumentSyntax {
    let result = AvailabilityLabeledArgumentSyntax(unexpectedBeforeLabel?.buildUnexpectedNodes(format: format, leadingTrivia: nil), label: label.buildToken(), unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format, leadingTrivia: nil), colon: colon.buildToken(), unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format, leadingTrivia: nil), value: value.buildSyntax(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAvailabilityLabeledArgument(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityLabeledArgument`.
  public func createAvailabilityLabeledArgument() -> AvailabilityLabeledArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityLabeledArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// An argument to `@available` that restricts the availability on acertain platform to a version, e.g. `iOS 10` or `swift 3.4`.
public struct AvailabilityVersionRestriction: SyntaxBuildable, ExpressibleAsAvailabilityVersionRestriction {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforePlatform: UnexpectedNodes?
  let platform: Token
  let unexpectedBetweenPlatformAndVersion: UnexpectedNodes?
  let version: VersionTuple?
  /// Creates a `AvailabilityVersionRestriction` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePlatform: 
  ///   - platform: The name of the OS on which the availability should berestricted or 'swift' if the availability should berestricted based on a Swift version.
  ///   - unexpectedBetweenPlatformAndVersion: 
  ///   - version: 
  public init (leadingTrivia: Trivia = [], unexpectedBeforePlatform: ExpressibleAsUnexpectedNodes? = nil, platform: Token, unexpectedBetweenPlatformAndVersion: ExpressibleAsUnexpectedNodes? = nil, version: ExpressibleAsVersionTuple? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforePlatform = unexpectedBeforePlatform?.createUnexpectedNodes()
    self.platform = platform
    self.unexpectedBetweenPlatformAndVersion = unexpectedBetweenPlatformAndVersion?.createUnexpectedNodes()
    self.version = version?.createVersionTuple()
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePlatform: ExpressibleAsUnexpectedNodes? = nil, platform: String, unexpectedBetweenPlatformAndVersion: ExpressibleAsUnexpectedNodes? = nil, version: ExpressibleAsVersionTuple? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePlatform: unexpectedBeforePlatform, platform: Token.`identifier`(platform), unexpectedBetweenPlatformAndVersion: unexpectedBetweenPlatformAndVersion, version: version)
  }
  /// Builds a `AvailabilityVersionRestrictionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityVersionRestrictionSyntax`.
  func buildAvailabilityVersionRestriction(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> AvailabilityVersionRestrictionSyntax {
    let result = AvailabilityVersionRestrictionSyntax(unexpectedBeforePlatform?.buildUnexpectedNodes(format: format, leadingTrivia: nil), platform: platform.buildToken(), unexpectedBetweenPlatformAndVersion?.buildUnexpectedNodes(format: format, leadingTrivia: nil), version: version?.buildVersionTuple(format: format, leadingTrivia: nil))
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildAvailabilityVersionRestriction(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityVersionRestriction`.
  public func createAvailabilityVersionRestriction() -> AvailabilityVersionRestriction {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityVersionRestriction` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
/// A version number of the form major.minor.patch in which the minorand patch part may be omitted.
public struct VersionTuple: SyntaxBuildable, ExpressibleAsVersionTuple {
  /// The leading trivia attached to this syntax node once built.
  /// This is typically used to add comments (e.g. for documentation).
  let leadingTrivia: Trivia
  let unexpectedBeforeMajorMinor: UnexpectedNodes?
  let majorMinor: SyntaxBuildable
  let unexpectedBetweenMajorMinorAndPatchPeriod: UnexpectedNodes?
  let patchPeriod: Token?
  let unexpectedBetweenPatchPeriodAndPatchVersion: UnexpectedNodes?
  let patchVersion: Token?
  /// Creates a `VersionTuple` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMajorMinor: 
  ///   - majorMinor: In case the version consists only of the major version, aninteger literal that specifies the major version. In casethe version consists of major and minor version number, afloating literal in which the decimal part is interpretedas the minor version.
  ///   - unexpectedBetweenMajorMinorAndPatchPeriod: 
  ///   - patchPeriod: If the version contains a patch number, the periodseparating the minor from the patch number.
  ///   - unexpectedBetweenPatchPeriodAndPatchVersion: 
  ///   - patchVersion: The patch version if specified.
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMajorMinor: ExpressibleAsUnexpectedNodes? = nil, majorMinor: ExpressibleAsSyntaxBuildable, unexpectedBetweenMajorMinorAndPatchPeriod: ExpressibleAsUnexpectedNodes? = nil, patchPeriod: Token? = nil, unexpectedBetweenPatchPeriodAndPatchVersion: ExpressibleAsUnexpectedNodes? = nil, patchVersion: Token? = nil) {
    self.leadingTrivia = leadingTrivia
    self.unexpectedBeforeMajorMinor = unexpectedBeforeMajorMinor?.createUnexpectedNodes()
    self.majorMinor = majorMinor.createSyntaxBuildable()
    self.unexpectedBetweenMajorMinorAndPatchPeriod = unexpectedBetweenMajorMinorAndPatchPeriod?.createUnexpectedNodes()
    self.patchPeriod = patchPeriod
    assert(patchPeriod == nil || patchPeriod!.text == #"."#)
    self.unexpectedBetweenPatchPeriodAndPatchVersion = unexpectedBetweenPatchPeriodAndPatchVersion?.createUnexpectedNodes()
    self.patchVersion = patchVersion
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMajorMinor: ExpressibleAsUnexpectedNodes? = nil, majorMinor: ExpressibleAsSyntaxBuildable, unexpectedBetweenMajorMinorAndPatchPeriod: ExpressibleAsUnexpectedNodes? = nil, patchPeriod: Token? = nil, unexpectedBetweenPatchPeriodAndPatchVersion: ExpressibleAsUnexpectedNodes? = nil, patchVersion: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMajorMinor: unexpectedBeforeMajorMinor, majorMinor: majorMinor, unexpectedBetweenMajorMinorAndPatchPeriod: unexpectedBetweenMajorMinorAndPatchPeriod, patchPeriod: patchPeriod, unexpectedBetweenPatchPeriodAndPatchVersion: unexpectedBetweenPatchPeriodAndPatchVersion, patchVersion: patchVersion.map {
      Token.`integerLiteral`($0)
    })
  }
  /// Builds a `VersionTupleSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `VersionTupleSyntax`.
  func buildVersionTuple(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> VersionTupleSyntax {
    let result = VersionTupleSyntax(unexpectedBeforeMajorMinor?.buildUnexpectedNodes(format: format, leadingTrivia: nil), majorMinor: majorMinor.buildSyntax(format: format, leadingTrivia: nil), unexpectedBetweenMajorMinorAndPatchPeriod?.buildUnexpectedNodes(format: format, leadingTrivia: nil), patchPeriod: patchPeriod?.buildToken(), unexpectedBetweenPatchPeriodAndPatchVersion?.buildUnexpectedNodes(format: format, leadingTrivia: nil), patchVersion: patchVersion?.buildToken())
    let combinedLeadingTrivia = leadingTrivia + (additionalLeadingTrivia ?? []) + (result.leadingTrivia ?? [])
    if combinedLeadingTrivia.isEmpty {
      return result
    } else {
      return result.withLeadingTrivia(combinedLeadingTrivia.addingSpacingAfterNewlinesIfNeeded())
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format, leadingTrivia additionalLeadingTrivia: Trivia? = nil) -> Syntax {
    let result = buildVersionTuple(format: format, leadingTrivia: additionalLeadingTrivia)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsVersionTuple`.
  public func createVersionTuple() -> VersionTuple {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `VersionTuple` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
}
